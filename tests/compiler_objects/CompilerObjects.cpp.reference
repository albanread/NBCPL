// CompilerObjects.cpp
// Implementation of optimized compiler objects for BCPL compiler infrastructure
// Designed for high-performance allocation with SAMM integration

#include "CompilerObjects.h"
#include <iostream>
#include <cassert>
#include <cstring>
#include <algorithm>

// Global factory instance
CompilerObjectFactory g_compiler_factory;

// CompilerToken Implementation
CompilerToken::CompilerToken(TokenType t, int line_num, int col_num, const std::string& val)
    : type(t), line(line_num), column(col_num) {
    set_value(val);
}

CompilerToken::~CompilerToken() {
    if (!is_small_string && value_storage.large_str.ptr) {
        delete[] value_storage.large_str.ptr;
        value_storage.large_str.ptr = nullptr;
    }
}

std::string CompilerToken::get_value() const {
    if (is_small_string) {
        return std::string(value_storage.small_str);
    } else {
        return std::string(value_storage.large_str.ptr, value_storage.large_str.length);
    }
}

void CompilerToken::set_value(const std::string& val) {
    // Clean up existing large string if any
    if (!is_small_string && value_storage.large_str.ptr) {
        delete[] value_storage.large_str.ptr;
        value_storage.large_str.ptr = nullptr;
    }
    
    if (val.length() < 24) {
        is_small_string = true;
        std::strncpy(value_storage.small_str, val.c_str(), 23);
        value_storage.small_str[23] = '\0';
    } else {
        is_small_string = false;
        value_storage.large_str.length = val.length();
        value_storage.large_str.capacity = val.length() + 1;
        value_storage.large_str.ptr = new char[value_storage.large_str.capacity];
        std::strcpy(value_storage.large_str.ptr, val.c_str());
    }
}

CompilerToken* CompilerToken::from_token(const Token& tok) {
    return new CompilerToken(tok.type, tok.line, tok.column, tok.value);
}

std::string CompilerToken::to_string() const {
    return "Token{" + ::to_string(type) + ", line:" + std::to_string(line) + 
           ", col:" + std::to_string(column) + ", value:\"" + get_value() + "\"}";
}

// CompilerSymbol Implementation
CompilerSymbol::CompilerSymbol(SymbolType type, const std::string& sym_name, int scope)
    : symbol_type(type), name(sym_name), scope_level(scope), declaration_line(0) {
    std::memset(&data, 0, sizeof(data));
}

void CompilerSymbol::set_manifest_value(int64_t value) {
    assert(symbol_type == MANIFEST);
    data.manifest.value = value;
}

void CompilerSymbol::set_function_info(void* ast_node, size_t param_count) {
    assert(symbol_type == FUNCTION);
    data.function.ast_node = ast_node;
    data.function.parameter_count = param_count;
}

void CompilerSymbol::set_class_info(void* class_info, size_t member_count) {
    assert(symbol_type == CLASS);
    data.class_info.class_info = class_info;
    data.class_info.member_count = member_count;
}

void CompilerSymbol::set_variable_info(void* var_info, bool is_param) {
    assert(symbol_type == VARIABLE);
    data.variable.variable_info = var_info;
    data.variable.is_parameter = is_param;
}

std::string CompilerSymbol::to_string() const {
    std::string type_str;
    switch (symbol_type) {
        case VARIABLE: type_str = "VAR"; break;
        case FUNCTION: type_str = "FUNC"; break;
        case CLASS: type_str = "CLASS"; break;
        case LABEL: type_str = "LABEL"; break;
        case MANIFEST: type_str = "MANIFEST"; break;
        case GLOBAL: type_str = "GLOBAL"; break;
    }
    
    return "Symbol{" + type_str + ", name:\"" + name + "\", scope:" + 
           std::to_string(scope_level) + ", line:" + std::to_string(declaration_line) + "}";
}

// CompilerScope Implementation
CompilerScope::CompilerScope(ScopeType type, int id, int parent_id, int level)
    : scope_id(id), parent_scope_id(parent_id), nesting_level(level), scope_type(type) {
    symbols.reserve(16);      // Reserve space for typical scope
    child_scopes.reserve(4);  // Most scopes have few children
}

CompilerScope::~CompilerScope() {
    // SAMM will clean up symbols and child scopes automatically
    // if they're registered with SAMM
}

CompilerSymbol* CompilerScope::find_symbol(const std::string& name) const {
    for (auto* sym : symbols) {
        if (sym && sym->name == name) {
            return sym;
        }
    }
    return nullptr;
}

CompilerSymbol* CompilerScope::find_symbol_recursive(const std::string& name) const {
    // First check this scope
    auto* symbol = find_symbol(name);
    if (symbol) {
        return symbol;
    }
    
    // Then check parent scopes (would need parent pointer for full implementation)
    // This is a simplified version - full implementation would walk up scope chain
    return nullptr;
}

void CompilerScope::add_symbol(CompilerSymbol* symbol) {
    assert(symbol != nullptr);
    symbols.push_back(symbol);
}

void CompilerScope::add_child_scope(CompilerScope* child) {
    assert(child != nullptr);
    child_scopes.push_back(child);
}

size_t CompilerScope::get_symbol_count() const {
    return symbols.size();
}

size_t CompilerScope::get_total_symbol_count() const {
    size_t total = symbols.size();
    for (const auto* child : child_scopes) {
        if (child) {
            total += child->get_total_symbol_count();
        }
    }
    return total;
}

std::string CompilerScope::to_string() const {
    std::string type_str;
    switch (scope_type) {
        case GLOBAL: type_str = "GLOBAL"; break;
        case FUNCTION: type_str = "FUNCTION"; break;
        case BLOCK: type_str = "BLOCK"; break;
        case CLASS: type_str = "CLASS"; break;
        case LOOP: type_str = "LOOP"; break;
    }
    
    return "Scope{" + type_str + ", id:" + std::to_string(scope_id) + 
           ", parent:" + std::to_string(parent_scope_id) + 
           ", level:" + std::to_string(nesting_level) + 
           ", symbols:" + std::to_string(symbols.size()) + "}";
}

// CallGraphNode Implementation
CallGraphNode::CallGraphNode(const std::string& name)
    : function_name(name), is_recursive(false), is_leaf_function(true),
      call_depth(0), estimated_cost(0) {
    callers.reserve(4);
    callees.reserve(8);
}

void CallGraphNode::add_call_to(CallGraphNode* target) {
    assert(target != nullptr);
    
    // Check if call relationship already exists
    for (const auto* existing : callees) {
        if (existing == target) {
            return; // Already exists
        }
    }
    
    callees.push_back(target);
    target->callers.push_back(this);
    is_leaf_function = false;
    
    // Check for recursion
    if (target == this) {
        is_recursive = true;
        target->is_recursive = true;
    }
}

void CallGraphNode::remove_call_to(CallGraphNode* target) {
    // Remove from callees
    auto it = std::find(callees.begin(), callees.end(), target);
    if (it != callees.end()) {
        callees.erase(it);
    }
    
    // Remove from target's callers
    auto caller_it = std::find(target->callers.begin(), target->callers.end(), this);
    if (caller_it != target->callers.end()) {
        target->callers.erase(caller_it);
    }
    
    // Update leaf status
    is_leaf_function = callees.empty();
}

bool CallGraphNode::has_cycle() const {
    std::vector<const CallGraphNode*> visited;
    return has_cycle_impl(visited);
}

bool CallGraphNode::has_cycle_impl(std::vector<const CallGraphNode*>& visited) const {
    for (const auto* node : visited) {
        if (node == this) return true;
    }
    
    visited.push_back(this);
    for (const auto* callee : callees) {
        if (callee && callee->has_cycle_impl(visited)) {
            return true;
        }
    }
    visited.pop_back();
    return false;
}

int32_t CallGraphNode::compute_call_depth() {
    if (call_depth > 0) {
        return call_depth; // Already computed
    }
    
    if (is_leaf_function) {
        call_depth = 1;
        return call_depth;
    }
    
    int32_t max_depth = 0;
    for (auto* callee : callees) {
        if (callee && callee != this) { // Avoid infinite recursion
            int32_t depth = callee->compute_call_depth();
            max_depth = std::max(max_depth, depth);
        }
    }
    
    call_depth = max_depth + 1;
    return call_depth;
}

std::string CallGraphNode::to_string() const {
    return "CallGraphNode{name:\"" + function_name + 
           "\", callers:" + std::to_string(callers.size()) +
           ", callees:" + std::to_string(callees.size()) +
           ", recursive:" + (is_recursive ? "true" : "false") +
           ", leaf:" + (is_leaf_function ? "true" : "false") + "}";
}

// CompilerObjectFactory Implementation
CompilerObjectFactory::CompilerObjectFactory() 
    : heap_manager_(HeapManager::getInstance()) {
    // Ensure SAMM is enabled for automatic cleanup
    heap_manager_.setSAMMEnabled(true);
}

CompilerToken* CompilerObjectFactory::create_token(TokenType type, int line, int column, const std::string& value) {
    auto* token = new CompilerToken(type, line, column, value);
    // Register with SAMM for automatic cleanup
    heap_manager_.trackInCurrentScope(token);
    return token;
}

CompilerSymbol* CompilerObjectFactory::create_symbol(CompilerSymbol::SymbolType type, const std::string& name, int scope) {
    auto* symbol = new CompilerSymbol(type, name, scope);
    heap_manager_.trackInCurrentScope(symbol);
    return symbol;
}

CompilerScope* CompilerObjectFactory::create_scope(CompilerScope::ScopeType type, int id, int parent_id, int level) {
    auto* scope = new CompilerScope(type, id, parent_id, level);
    heap_manager_.trackInCurrentScope(scope);
    return scope;
}

CallGraphNode* CompilerObjectFactory::create_call_graph_node(const std::string& function_name) {
    auto* node = new CallGraphNode(function_name);
    heap_manager_.trackInCurrentScope(node);
    return node;
}

std::vector<CompilerToken*> CompilerObjectFactory::create_token_batch(const std::vector<Token>& tokens) {
    std::vector<CompilerToken*> result;
    result.reserve(tokens.size());
    
    // Enter SAMM scope for batch cleanup
    heap_manager_.enterScope();
    
    for (const auto& token : tokens) {
        result.push_back(create_token(token.type, token.line, token.column, token.value));
    }
    
    return result;
}

void CompilerObjectFactory::enter_compilation_phase() {
    heap_manager_.enterScope();
}

void CompilerObjectFactory::exit_compilation_phase() {
    heap_manager_.exitScope(); // Automatic cleanup of phase objects
}

// Performance monitoring
void CompilerObjectFactory::print_allocation_stats() const {
    // This would integrate with the heap manager's statistics
    std::cout << "=== Compiler Object Allocation Statistics ===" << std::endl;
    auto stats = heap_manager_.getSAMMStats();
    std::cout << "SAMM Scopes Entered: " << stats.scopes_entered << std::endl;
    std::cout << "SAMM Scopes Exited: " << stats.scopes_exited << std::endl;
    std::cout << "SAMM Objects Cleaned: " << stats.objects_cleaned << std::endl;
    std::cout << "Current Scope Depth: " << stats.current_scope_depth << std::endl;
}

// Utility functions for debugging
void print_compiler_object_info(const CompilerObject* obj) {
    if (!obj) {
        std::cout << "NULL CompilerObject" << std::endl;
        return;
    }
    
    std::cout << "CompilerObject at " << obj << ", size_class: " << obj->get_size_class() << std::endl;
    
    // Try to cast to known types for more detailed info
    if (const auto* token = dynamic_cast<const CompilerToken*>(obj)) {
        std::cout << "  " << token->to_string() << std::endl;
    } else if (const auto* symbol = dynamic_cast<const CompilerSymbol*>(obj)) {
        std::cout << "  " << symbol->to_string() << std::endl;
    } else if (const auto* scope = dynamic_cast<const CompilerScope*>(obj)) {
        std::cout << "  " << scope->to_string() << std::endl;
    } else if (const auto* node = dynamic_cast<const CallGraphNode*>(obj)) {
        std::cout << "  " << node->to_string() << std::endl;
    }
}