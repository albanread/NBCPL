#ifndef COMPILER_OBJECTS_H
#define COMPILER_OBJECTS_H

#include <string>
#include <vector>
#include <memory>
#include <cstdint>
#include <cstring>
#include "Lexer.h"
#include "HeapManager/HeapManager.h"

// Forward declarations
class CompilerToken;
class CompilerSymbol;
class CompilerScope;

// Base class for all compiler objects with SAMM integration
class CompilerObject {
public:
    // SAMM vtable functions
    virtual void RELEASE() { delete this; }
    virtual CompilerObject* CREATE() { return nullptr; }
    
    virtual ~CompilerObject() = default;
    
    // Size class hint for allocator optimization
    virtual size_t get_size_class() const = 0;
    
protected:
    CompilerObject() = default;
};

// High-frequency token object optimized for recycling
class CompilerToken : public CompilerObject {
public:
    TokenType type;
    int32_t line;      // 32-bit is sufficient for line numbers
    int32_t column;    // 32-bit is sufficient for column numbers
    
    // Optimized string storage - use small string optimization
    union StringStorage {
        char small_str[24];  // 24 bytes for small strings (fits in cache line)
        struct {
            char* ptr;
            size_t length;
            size_t capacity;
        } large_str;
    } value_storage;
    
    bool is_small_string;
    
    CompilerToken(TokenType t, int line_num, int col_num, const std::string& val);
    ~CompilerToken() override;
    
    void RELEASE() override {
        // For high-frequency objects, consider returning to pool instead of delete
        delete this;
    }
    
    size_t get_size_class() const override {
        return 48; // Token objects are ~48 bytes (16-byte aligned)
    }
    
    std::string get_value() const;
    void set_value(const std::string& val);
    std::string to_string() const;
    
    // Convert from existing Token struct
    static CompilerToken* from_token(const Token& tok);
};

// Symbol table entry optimized for compiler use
class CompilerSymbol : public CompilerObject {
public:
    enum SymbolType {
        VARIABLE,
        FUNCTION,
        CLASS,
        LABEL,
        MANIFEST,
        GLOBAL
    };
    
    SymbolType symbol_type;
    std::string name;           // Symbol name
    std::string unique_name;    // Mangled/unique name
    std::string type_signature; // Type information
    int32_t scope_level;        // Scope depth
    int32_t declaration_line;   // Where declared
    
    union SymbolData {
        struct {
            int64_t value;      // For manifest constants
        } manifest;
        
        struct {
            void* ast_node;     // Pointer to AST node
            size_t parameter_count;
        } function;
        
        struct {
            size_t member_count;
            void* class_info;
        } class_info;
        
        struct {
            void* variable_info;
            bool is_parameter;
        } variable;
    } data;
    
    CompilerSymbol(SymbolType type, const std::string& sym_name, int scope);
    
    size_t get_size_class() const override {
        return 128; // Symbol objects are larger due to strings
    }
    
    void RELEASE() override {
        delete this;
    }
    
    // Type-specific setters
    void set_manifest_value(int64_t value);
    void set_function_info(void* ast_node, size_t param_count);
    void set_class_info(void* class_info, size_t member_count);
    void set_variable_info(void* var_info, bool is_param);
    
    std::string to_string() const;
};

// Optimized scope management for compiler phases
class CompilerScope : public CompilerObject {
public:
    int32_t scope_id;
    int32_t parent_scope_id;
    int32_t nesting_level;
    
    // Use vectors for cache-friendly iteration
    std::vector<CompilerSymbol*> symbols;
    std::vector<CompilerScope*> child_scopes;
    
    // Scope type information
    enum ScopeType {
        GLOBAL,
        FUNCTION,
        BLOCK,
        CLASS,
        LOOP
    } scope_type;
    
    CompilerScope(ScopeType type, int id, int parent_id, int level);
    ~CompilerScope() override;
    
    size_t get_size_class() const override {
        return 96; // Scope objects with vectors
    }
    
    void RELEASE() override {
        delete this;
    }
    
    CompilerSymbol* find_symbol(const std::string& name) const;
    CompilerSymbol* find_symbol_recursive(const std::string& name) const;
    void add_symbol(CompilerSymbol* symbol);
    void add_child_scope(CompilerScope* child);
    size_t get_symbol_count() const;
    size_t get_total_symbol_count() const;
    std::string to_string() const;
};

// Call graph node for optimization phases
class CallGraphNode : public CompilerObject {
public:
    std::string function_name;
    std::vector<CallGraphNode*> callers;    // Functions that call this one
    std::vector<CallGraphNode*> callees;    // Functions this one calls
    
    // Analysis data
    bool is_recursive;
    bool is_leaf_function;
    int32_t call_depth;
    int32_t estimated_cost;
    
    CallGraphNode(const std::string& name);
    
    size_t get_size_class() const override {
        return 96; // Similar to scope objects
    }
    
    void RELEASE() override {
        delete this;
    }
    
    void add_call_to(CallGraphNode* target);
    void remove_call_to(CallGraphNode* target);
    bool has_cycle() const;
    int32_t compute_call_depth();
    std::string to_string() const;
    
private:
    bool has_cycle_impl(std::vector<const CallGraphNode*>& visited) const;
};

// Factory class for optimized object allocation
class CompilerObjectFactory {
private:
    HeapManager& heap_manager_;
    
public:
    CompilerObjectFactory();
    
    CompilerToken* create_token(TokenType type, int line, int column, const std::string& value);
    CompilerSymbol* create_symbol(CompilerSymbol::SymbolType type, const std::string& name, int scope);
    CompilerScope* create_scope(CompilerScope::ScopeType type, int id, int parent_id, int level);
    CallGraphNode* create_call_graph_node(const std::string& function_name);
    
    // Batch creation for high-frequency objects
    std::vector<CompilerToken*> create_token_batch(const std::vector<Token>& tokens);
    
    void enter_compilation_phase();
    void exit_compilation_phase();
    void print_allocation_stats() const;
};

// Global factory instance
extern CompilerObjectFactory g_compiler_factory;

// Convenience macros for common operations
#define CREATE_TOKEN(type, line, col, val) g_compiler_factory.create_token(type, line, col, val)
#define CREATE_SYMBOL(type, name, scope) g_compiler_factory.create_symbol(type, name, scope)
#define CREATE_SCOPE(type, id, parent, level) g_compiler_factory.create_scope(type, id, parent, level)
#define CREATE_CALL_NODE(name) g_compiler_factory.create_call_graph_node(name)

#define ENTER_PHASE() g_compiler_factory.enter_compilation_phase()
#define EXIT_PHASE() g_compiler_factory.exit_compilation_phase()

// Utility functions
void print_compiler_object_info(const CompilerObject* obj);

#endif // COMPILER_OBJECTS_H