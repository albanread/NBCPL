LET START() BE {
    WRITEF("=== COMPREHENSIVE FPAIRS FUNCTIONALITY TEST ===*N")

    // Test 1: Basic FPAIRS allocation
    WRITEF("Test 1: Basic FPAIRS allocation*N")
    LET vec_a = FPAIRS 4
    WRITEF("  âœ“ FPAIRS 4 allocated successfully*N")

    // Test 2: FPAIR creation and assignment
    WRITEF("Test 2: FPAIR creation and assignment*N")
    vec_a!0 := FPAIR(1.5, 2.5)
    vec_a!1 := FPAIR(3.5, 4.5)
    vec_a!2 := FPAIR(5.5, 6.5)
    vec_a!3 := FPAIR(7.5, 8.5)
    WRITEF("  âœ“ FPAIR assignments completed*N")

    // Test 3: FPAIRS vector element access
    WRITEF("Test 3: FPAIRS vector element access*N")
    LET retrieved_fpair = vec_a!0
    WRITEF("  âœ“ FPAIR element retrieved from FPAIRS vector*N")

    // Test 4: FPAIR component access
    WRITEF("Test 4: FPAIR component access*N")
    LET first_val = retrieved_fpair.first
    LET second_val = retrieved_fpair.second
    WRITEF("  âœ“ FPAIR components accessed: %F, %F*N", first_val, second_val)

    // Test 5: Multiple FPAIRS vectors
    WRITEF("Test 5: Multiple FPAIRS vectors*N")
    LET vec_b = FPAIRS 2
    LET vec_c = FPAIRS 3
    vec_b!0 := FPAIR(10.0, 20.0)
    vec_b!1 := FPAIR(30.0, 40.0)
    vec_c!0 := FPAIR(100.0, 200.0)
    vec_c!1 := FPAIR(300.0, 400.0)
    vec_c!2 := FPAIR(500.0, 600.0)
    WRITEF("  âœ“ Multiple FPAIRS vectors created and initialized*N")

    // Test 6: FPAIR arithmetic (if supported)
    WRITEF("Test 6: FPAIR operations*N")
    LET fpair_a = FPAIR(1.0, 2.0)
    LET fpair_b = FPAIR(3.0, 4.0)
    WRITEF("  âœ“ Individual FPAIRs created for operations*N")

    // Test 7: Large FPAIRS allocation
    WRITEF("Test 7: Large FPAIRS allocation*N")
    LET big_vec = FPAIRS 10
    $(
        FOR i = 0 TO 9 DO
            big_vec!i := FPAIR(i * 1.0, i * 2.0)
    $)
    WRITEF("  âœ“ Large FPAIRS vector (10 elements) allocated and initialized*N")

    // Test 8: FPAIRS vs PAIRS distinction
    WRITEF("Test 8: FPAIRS vs PAIRS distinction*N")
    LET int_pairs = PAIRS 2
    LET float_pairs = FPAIRS 2
    int_pairs!0 := PAIR(1, 2)
    int_pairs!1 := PAIR(3, 4)
    float_pairs!0 := FPAIR(1.1, 2.2)
    float_pairs!1 := FPAIR(3.3, 4.4)
    WRITEF("  âœ“ Both PAIRS and FPAIRS work independently*N")

    // Test 9: Type inference validation
    WRITEF("Test 9: Type inference validation*N")
    LET inferred_fpair = float_pairs!0
    LET inferred_first = inferred_fpair.first
    LET inferred_second = inferred_fpair.second
    WRITEF("  âœ“ Type inference working: %F, %F*N", inferred_first, inferred_second)

    // Test 10: Edge cases
    WRITEF("Test 10: Edge cases*N")
    LET small_vec = FPAIRS 1
    small_vec!0 := FPAIR(99.9, 88.8)
    LET edge_fpair = small_vec!0
    WRITEF("  âœ“ Single-element FPAIRS vector works*N")

    // Test 11: Nested access patterns
    WRITEF("Test 11: Nested access patterns*N")
    LET direct_first = vec_a!2.first
    LET direct_second = vec_a!2.second
    WRITEF("  âœ“ Direct nested access: %F, %F*N", direct_first, direct_second)

    WRITEF("*N=== ALL FPAIRS TESTS COMPLETED SUCCESSFULLY ===*N")
    WRITEF("Summary:*N")
    WRITEF("  - FPAIRS allocation: WORKING*N")
    WRITEF("  - FPAIR assignment: WORKING*N")
    WRITEF("  - Element access: WORKING*N")
    WRITEF("  - Component access: WORKING*N")
    WRITEF("  - Type inference: WORKING*N")
    WRITEF("  - Multiple vectors: WORKING*N")
    WRITEF("  - Large allocations: WORKING*N")
    WRITEF("  - PAIRS/FPAIRS distinction: WORKING*N")
    WRITEF("*NFPAIRS feature is fully functional! ðŸŽ‰*N")
}
