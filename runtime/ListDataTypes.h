#ifndef LIST_DATA_TYPES_H
#define LIST_DATA_TYPES_H

#include <stdint.h>
#include <stddef.h>

// --- Type Tags ---
#define ATOM_SENTINEL 0
#define ATOM_INT      1
#define ATOM_FLOAT    2
#define ATOM_STRING   3
#define ATOM_LIST_POINTER 4
#define ATOM_OBJECT   5
#define ATOM_PAIR     6

// This structure for data nodes remains the same.
typedef struct ListAtom {
    int32_t type;
    int32_t pad;
    union {
        int64_t int_value;
        double float_value;
        void* ptr_value;
    } value;
    struct ListAtom* next;
} ListAtom;

// **NEW:** A dedicated, unambiguous structure for the list header.
typedef struct ListHeader {
    int32_t  type;       // **ALWAYS** set to ATOM_SENTINEL
    int32_t  contains_literals; // Flag: 1 if contains literal string data, 0 if fully heap-allocated
    int64_t  length;     // Dedicated 8 bytes for length.
    ListAtom* head;      // 8-byte pointer to the first data node.
    ListAtom* tail;      // 8-byte pointer to the last data node for O(1) appends.
} ListHeader;

// A helper struct to mirror the layout of read-only list literals
// generated by the compiler.
typedef struct ListLiteralHeader {
    int32_t type;
    int32_t pad;
    ListAtom* tail;    // offset 8
    ListAtom* head;    // offset 16
    int64_t length;    // offset 24
} ListLiteralHeader;

// Offsets for code generation (C guarantees struct layout order)
#define LIST_ATOM_TYPE_OFFSET   offsetof(ListAtom, type)
#define LIST_ATOM_VALUE_OFFSET  offsetof(ListAtom, value)
#define LIST_ATOM_NEXT_OFFSET   offsetof(ListAtom, next)

#ifdef __cplusplus
extern "C" {
#endif

struct ListHeader;
struct ListHeader* getHeaderFromFreelist(void);
void returnHeaderToFreelist(struct ListHeader* header);

#ifdef __cplusplus
}
#endif

#endif // LIST_DATA_TYPES_H