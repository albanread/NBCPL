// runtime.c
// Standalone C runtime for BCPL
// This file is only compiled for standalone builds, not for JIT.

#include "runtime.h"
#include "runtime_core.inc"
#include "runtime_string_utils.inc"
#include "runtime_io.inc"
#include "runtime_file_api.inc"
#include "BCPLError.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Forward declaration for error tracking
extern void _BCPL_SET_ERROR(BCPLErrorCode code, const char* func, const char* msg);

// Forward declaration for HeapManager free function
extern void Heap_free(void* payload);

// Forward declaration of the compiled BCPL entry point
// This function will be defined in the assembly generated by the BCPL compiler
extern int64_t START(void);

// Simple C-based allocator implementations for standalone builds
// These replace the C++ HeapManager used in JIT mode

void* bcpl_alloc_words(int64_t num_words, const char* func, const char* var) {
    if (num_words <= 0) {
        _BCPL_SET_ERROR(ERROR_INVALID_ARGUMENT, func ? func : "bcpl_alloc_words", "Attempted to allocate negative or zero words");
        return NULL;
    }

    // Allocate memory with header: [size][data...]
    // The size is stored as a 64-bit value before the actual data
    size_t total_size = sizeof(uint64_t) + num_words * sizeof(uint64_t);
    uint64_t* vec = (uint64_t*)malloc(total_size);
    
    if (!vec) {
        _BCPL_SET_ERROR(ERROR_OUT_OF_MEMORY, func ? func : "bcpl_alloc_words", "System malloc failed for word vector");
        fprintf(stderr, "ERROR: Failed to allocate %lld words in %s for %s\n",
                (long long)num_words, func ? func : "unknown", var ? var : "unknown");
        return NULL;
    }
    
    // Store the size in the header
    vec[0] = num_words;
    
    // Return a pointer to the data section (after the header)
    return (void*)(vec + 1);
}

void* bcpl_alloc_chars(int64_t num_chars) {
    if (num_chars < 0) {
        _BCPL_SET_ERROR(ERROR_INVALID_ARGUMENT, "bcpl_alloc_chars", "Attempted to allocate negative number of chars");
        return NULL;
    }

    // For strings, we allocate: [size][data...][0]
    // The data is an array of uint32_t values, and we add space for a null terminator
    size_t total_size = sizeof(uint64_t) + (num_chars + 1) * sizeof(uint32_t);
    uint64_t* str = (uint64_t*)malloc(total_size);
    
    if (!str) {
        _BCPL_SET_ERROR(ERROR_OUT_OF_MEMORY, "bcpl_alloc_chars", "System malloc failed for char buffer");
        fprintf(stderr, "ERROR: Failed to allocate string with %lld chars\n",
                (long long)num_chars);
        return NULL;
    }
    
    // Store the size in the header
    str[0] = num_chars;
    
    // Get a pointer to the data section
    uint32_t* payload = (uint32_t*)(str + 1);
    
    // Add null terminator
    payload[num_chars] = 0;
    
    // Clear the string for safety
    memset(payload, 0, num_chars * sizeof(uint32_t));
    
    // Return a pointer to the data section
    return (void*)payload;
}

void bcpl_free(void* ptr) {
    if (!ptr) {
        _BCPL_SET_ERROR(ERROR_INVALID_ARGUMENT, "bcpl_free", "Attempted to free NULL pointer");
        return;
    }
    
    // Call HeapManager's free method for proper double-free detection
    // Note: HeapManager::free handles the payload-to-base address conversion internally
    Heap_free(ptr);
}

// Include the shared implementations


// Main entry point for standalone executables
/*
int main(int argc, char *argv[]) {
    // Initialize the runtime environment
    printf("BCPL Runtime v%s initializing...\n", BCPL_RUNTIME_VERSION);
    
    // Process command line arguments if needed
    if (argc > 0) {
        printf("Program: %s\n", argv[0]);
    }
    
    // Create arguments for BCPL program if needed
    // This could be expanded to properly convert argc/argv to BCPL format
    
    // Call the BCPL program's entry point
    printf("Starting BCPL program...\n");
    int64_t result = START();
    printf("BCPL program finished with result: %lld\n", (long long)result);
    
    return (int)result;
}
*/