#include "DataTypes.h"
#define _DARWIN_C_SOURCE // Required for ucontext.h on macOS

#include "RuntimeManager.h"
#include "runtime/RuntimeBridge.h"

#include "RuntimeSymbols.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "PeepholeOptimizer.h"
#include "HeapManager/HeapManager.h"
#include "HeapManager/heap_manager_defs.h"
#include <memory>
#include <stdexcept>
#include <cstring>
#include <csignal>
#include <cstdlib>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/ucontext.h>
#include <sys/wait.h>
#include <execinfo.h>
#include <unistd.h>

// --- Project Headers ---
#include "Preprocessor.h"
#include "AST.h"


#include "AssemblyWriter.h"
#include "CodeBuffer.h"
#include "CommonSubexpressionEliminationPass.h"
#include "ConstantFoldingPass.h"
#include "DataGenerator.h"
#include "DebugPrinter.h"
#include "InstructionStream.h"
#include "JITExecutor.h"
#include "LabelManager.h"
#include "Lexer.h"
#include "LexerDebug.h"
#include "Linker.h"
#include "NewCodeGenerator.h"
#include "Parser.h"
#include "RegisterManager.h"
#include "RuntimeManager.h"
#include "SignalSafeUtils.h"
#include "analysis/ASTAnalyzer.h"
#include "passes/ManifestResolutionPass.h"
#include "LivenessAnalysisPass.h"
#include "CFGBuilderPass.h"
#include "analysis/SymbolTableBuilder.h"
#include "runtime.h"
#include "version.h"

// --- Global Variables ---
bool g_enable_lexer_trace = false;
std::unique_ptr<CodeBuffer> g_jit_code_buffer;
std::unique_ptr<JITExecutor> g_jit_executor;
std::string g_jit_breakpoint_label;
int g_jit_breakpoint_offset = 0;
std::string g_source_code;

// --- Forward Declarations ---
#include "include/SignalHandler.h"
std::string read_file_content(const std::string& filepath);
bool parse_arguments(int argc, char* argv[], bool& run_jit, bool& generate_asm, bool& exec_mode, 
                    bool& enable_opt, bool& enable_tracing, 
                    bool& trace_lexer, bool& trace_parser, bool& trace_ast, bool& trace_cfg, 
                    bool& trace_codegen, bool& trace_optimizer, bool& trace_liveness, 
                    bool& trace_runtime, bool& trace_symbols, bool& trace_heap,
                    bool& trace_preprocessor, bool& enable_preprocessor,
                    bool& enable_peephole, bool& trace_peephole,
                    bool& dump_jit_stack, std::string& input_filepath, 
                    std::string& call_entry_name, int& offset_instructions,
                    std::vector<std::string>& include_paths);
void handle_static_compilation(bool exec_mode, const std::string& base_name, const InstructionStream& instruction_stream, const DataGenerator& data_generator, bool enable_debug_output);
void* handle_jit_compilation(void* jit_data_memory_base, InstructionStream& instruction_stream, int offset_instructions, bool enable_debug_output);
void handle_jit_execution(void* code_buffer_base, const std::string& call_entry_name, bool dump_jit_stack, bool enable_debug_output);

// =================================================================================
// Main Execution Logic
// =================================================================================


int main(int argc, char* argv[]) {
    bool run_jit = false;
    bool generate_asm = false;
    bool exec_mode = false;
    bool enable_opt = false;
    bool enable_tracing = false;
    bool dump_jit_stack = false;
    bool enable_preprocessor = true;  // Enabled by default
    bool trace_preprocessor = false;
    
    // Granular tracing flags for different compiler passes
    bool trace_lexer = false;
    bool trace_parser = false;
    bool trace_ast = false;
    bool trace_cfg = false;


    bool trace_codegen = false;
    bool trace_optimizer = false;
    bool trace_liveness = false;
    bool trace_runtime = false;
    bool trace_symbols = false;
    bool trace_heap = false;
    bool enable_peephole = true;  // Enable peephole by default
    bool trace_peephole = false;
    std::string input_filepath;
    std::string call_entry_name = "START";
    g_jit_breakpoint_offset = 0;
    std::vector<std::string> include_paths;

    if (!parse_arguments(argc, argv, run_jit, generate_asm, exec_mode, enable_opt, enable_tracing, 
                        trace_lexer, trace_parser, trace_ast, trace_cfg, trace_codegen, 
                        trace_optimizer, trace_liveness, trace_runtime, trace_symbols, trace_heap,
                        trace_preprocessor, enable_preprocessor, enable_peephole, trace_peephole,
                        dump_jit_stack, input_filepath, call_entry_name, g_jit_breakpoint_offset, include_paths)) {
        return 1;
    }

    // Set individual trace flags based on global tracing or specific flags
    g_enable_lexer_trace = enable_tracing || trace_lexer;
    HeapManager::getInstance().setTraceEnabled(enable_tracing || trace_heap);
    if (enable_tracing || trace_runtime) {
        RuntimeManager::instance().enableTracing();
    }
    
    // Print version if any tracing is enabled
    if (enable_tracing || trace_lexer || trace_parser || trace_ast || trace_cfg || 
        trace_codegen || trace_optimizer || trace_liveness || trace_runtime || 
        trace_symbols || trace_heap) {
        print_version();
    }

    SignalHandler::setup();

    try {
        if (enable_preprocessor) {
            Preprocessor preprocessor;
            preprocessor.enableDebug(trace_preprocessor);
            
            // Add any include paths specified on command line
            for (const auto& path : include_paths) {
                preprocessor.addIncludePath(path);
            }
            
            // Add current directory as default include path
            char current_dir[PATH_MAX];
            if (getcwd(current_dir, sizeof(current_dir)) != nullptr) {
                preprocessor.addIncludePath(std::string(current_dir));
            }
            
            // Process the file and handle GET directives
            g_source_code = preprocessor.process(input_filepath);
        } else {
            g_source_code = read_file_content(input_filepath);
        }
        
        if (enable_tracing) {
            std::cout << "Compiling this source Code:\n" << g_source_code << std::endl;
        }
        // Initialize and register runtime functions using the new runtime bridge
        runtime::initialize_runtime();
        runtime::register_runtime_functions();
        
        if (enable_tracing) {
            std::cout << "Using " << runtime::get_runtime_version() << std::endl;
        }

        // --- Parsing and AST Construction ---
        Lexer lexer(g_source_code, enable_tracing || trace_lexer);
        Parser parser(lexer, enable_tracing || trace_parser);
        ProgramPtr ast = parser.parse_program();
        if (enable_tracing || trace_parser) {
            std::cout << "Parsing complete. AST built.\n";
        }
        
        if (enable_tracing || trace_ast) {
            std::cout << "\n--- Initial Abstract Syntax Tree ---\n";
            DebugPrinter printer;
            printer.print(*ast);
            std::cout << "----------------------------------\n\n";
        }

        // --- Semantic and Optimization Passes ---
        static std::unordered_map<std::string, int64_t> g_global_manifest_constants;
        if (enable_tracing || trace_optimizer) std::cout << "Applying Manifest Resolution Pass...\n";
        ManifestResolutionPass manifest_pass(g_global_manifest_constants);
        ast = manifest_pass.apply(std::move(ast));
        
        // --- NEW: Build Symbol Table ---
        if (enable_tracing || trace_symbols) std::cout << "Building symbol table...\n";
        SymbolTableBuilder symbol_table_builder(enable_tracing || trace_symbols);
        std::unique_ptr<SymbolTable> symbol_table = symbol_table_builder.build(*ast);
        
        // Register runtime functions in symbol table
        if (enable_tracing || trace_symbols || trace_runtime) std::cout << "Registering runtime functions in symbol table...\n";
        RuntimeSymbols::registerAll(*symbol_table);
        
        if (enable_tracing || trace_symbols) std::cout << "Symbol table construction complete.\n";

        if (enable_opt) {
            if (enable_tracing || trace_optimizer) std::cout << "Optimization enabled. Applying passes...\n";
            ConstantFoldingPass constant_folding_pass(g_global_manifest_constants);
            ast = constant_folding_pass.apply(std::move(ast));
            CommonSubexpressionEliminationPass cse_pass(g_global_manifest_constants);
            ast = cse_pass.apply(std::move(ast));
        }

        ASTAnalyzer& analyzer = ASTAnalyzer::getInstance();

       // Pass 1: Analyze the original tree to get hints from specific nodes like FVALOF
       // Now that we have a symbol table, pass it to the analyzer
       analyzer.analyze(*ast, symbol_table.get());
       if (enable_tracing || trace_ast) {
           std::cout << "Initial AST analysis complete.\n";
           analyzer.print_report();
       }

       // Pass 2: Transform the tree
       analyzer.transform(*ast);
       if (enable_tracing || trace_ast) std::cout << "AST transformation complete.\n";



        // --- NEW: CFG Construction Pass ---
        if (enable_tracing || trace_cfg) std::cout << "Building Control Flow Graphs...\n";
        CFGBuilderPass cfg_builder(enable_tracing || trace_cfg);
        cfg_builder.build(*ast);
        if (enable_tracing || trace_cfg) {
            const auto& cfgs = cfg_builder.get_cfgs();
            for (const auto& pair : cfgs) {
                pair.second->print_cfg();
            }
        }

        // --- NEW: Liveness Analysis Pass ---
        if (enable_tracing || trace_liveness) std::cout << "Running Liveness Analysis...\n";
        LivenessAnalysisPass liveness_analyzer(cfg_builder.get_cfgs(), enable_tracing || trace_liveness);
        liveness_analyzer.run();
        if (enable_tracing || trace_liveness) {
            liveness_analyzer.print_results();
        }

        // --- NEW: Update ASTAnalyzer with precise register pressure ---
        if (enable_tracing || trace_liveness) std::cout << "Updating register pressure from liveness data...\n";
        auto pressure_results = liveness_analyzer.calculate_register_pressure();

        // Get a mutable reference to the analyzer's metrics
        auto& function_metrics = ASTAnalyzer::getInstance().get_function_metrics_mut();

        for (const auto& pair : pressure_results) {
            const std::string& func_name = pair.first;
            int pressure = pair.second;

            if (function_metrics.count(func_name)) {
                function_metrics.at(func_name).max_live_variables = pressure;
            }
        }
        // --- END OF NEW CODE ---

        // --- Code Generation ---
        InstructionStream instruction_stream(LabelManager::instance());
        DataGenerator data_generator(enable_tracing || trace_codegen);
        RegisterManager& register_manager = RegisterManager::getInstance();
        LabelManager& label_manager = LabelManager::instance();
        int debug_level = (enable_tracing || trace_codegen) ? 5 : 0;

        // --- Allocate JIT data pool before code generation ---
        const size_t JIT_DATA_POOL_SIZE = 512 * 1024;
        // supports 32k 64bit global variables.

        void* jit_data_memory_base = mmap(nullptr, JIT_DATA_POOL_SIZE, PROT_READ | PROT_WRITE,
                                          MAP_PRIVATE | MAP_ANON, -1, 0);
        if (jit_data_memory_base == MAP_FAILED) {
            std::cerr << "Failed to allocate JIT data pool." << std::endl;
            return 1;
        }

        // --- Code Generation ---
        NewCodeGenerator code_generator(
            instruction_stream,
            register_manager,
            label_manager,
            enable_tracing || trace_codegen,
            debug_level,
            data_generator,
            reinterpret_cast<uint64_t>(jit_data_memory_base),
            cfg_builder, // <-- Pass the CFGBuilderPass object
            std::move(symbol_table) // <-- Pass the populated symbol table
        );
        code_generator.generate_code(*ast);
        if (enable_tracing || trace_codegen) std::cout << "Code generation complete.\n";
        
        // Apply peephole optimization if enabled
        if (enable_peephole) {
            if (enable_tracing || trace_peephole) {
                std::cout << "Applying peephole optimization...\n";
            }
            
            PeepholeOptimizer optimizer(enable_tracing || trace_peephole);
            
            // Apply the optimization - the optimizer will report its own statistics
            optimizer.optimize(instruction_stream);
            
            // Display optimization statistics if tracing is enabled
            if (trace_peephole) {
                const auto& stats = optimizer.getStats();
                std::cout << "Peephole optimization summary:\n";
                std::cout << "  - Applied " << stats.optimizations_applied 
                          << " optimizations\n";
                std::cout << "  - Instructions reduced from " << stats.total_instructions_before
                          << " to " << stats.total_instructions_after << "\n";
            }
        }

        data_generator.generate_rodata_section(instruction_stream);
        data_generator.generate_data_section(instruction_stream);
        if (enable_tracing || trace_codegen) std::cout << "Data sections generated.\n";

        if (generate_asm || exec_mode) {
            // FIX: Strip the file extension to get the base name.
            std::string base_name = input_filepath.substr(0, input_filepath.find_last_of('.'));
            handle_static_compilation(exec_mode, base_name, instruction_stream, data_generator, enable_tracing || trace_codegen);
        }

        if (run_jit) {
            void* code_buffer_base = handle_jit_compilation(jit_data_memory_base, instruction_stream, g_jit_breakpoint_offset, enable_tracing || trace_codegen);
            handle_jit_execution(code_buffer_base, call_entry_name, dump_jit_stack, enable_tracing || trace_runtime);

            // --- NEW: Call the listing functions here ---
            if (enable_tracing || trace_codegen) {
                std::cout << data_generator.generate_rodata_listing(label_manager);
                std::cout << data_generator.generate_data_listing(label_manager, jit_data_memory_base);
            }
        }
    } catch (const std::exception& ex) {
        std::cerr << "NewBCPL Compiler Error: " << ex.what() << std::endl;
        return 1;
    }

    if (enable_tracing || trace_runtime || trace_heap) {
        print_runtime_metrics();
    }

    return 0;
}

// =================================================================================
// Helper Function Implementations
// =================================================================================

/**
 * @brief Parses command-line arguments.
 * @return True if parsing is successful, false otherwise.
 */
bool parse_arguments(int argc, char* argv[], bool& run_jit, bool& generate_asm, bool& exec_mode, 
                    bool& enable_opt, bool& enable_tracing, 
                    bool& trace_lexer, bool& trace_parser, bool& trace_ast, bool& trace_cfg, 
                    bool& trace_codegen, bool& trace_optimizer, bool& trace_liveness, 
                    bool& trace_runtime, bool& trace_symbols, bool& trace_heap,
                    bool& trace_preprocessor, bool& enable_preprocessor,
                    bool& enable_peephole, bool& trace_peephole,
                    bool& dump_jit_stack, std::string& input_filepath, 
                    std::string& call_entry_name, int& offset_instructions,
                    std::vector<std::string>& include_paths) {
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--run" || arg == "-r") run_jit = true;
        else if (arg == "--asm" || arg == "-a") generate_asm = true;
        else if (arg == "--exec" || arg == "-e") exec_mode = true;
        else if (arg == "--opt" || arg == "-o") enable_opt = true;
        else if (arg == "--trace" || arg == "-T") enable_tracing = true;
        else if (arg == "--trace-lexer") trace_lexer = true;
        else if (arg == "--trace-parser") trace_parser = true;
        else if (arg == "--trace-ast") trace_ast = true;
        else if (arg == "--trace-cfg") trace_cfg = true;
        else if (arg == "--trace-codegen") trace_codegen = true;
        else if (arg == "--trace-preprocessor") trace_preprocessor = true;
        else if (arg == "--trace-opt") trace_optimizer = true;
        else if (arg == "--trace-liveness") trace_liveness = true;
        else if (arg == "--trace-runtime") trace_runtime = true;
        else if (arg == "--trace-symbols") trace_symbols = true;
        else if (arg == "--trace-heap") trace_heap = true;
        else if (arg == "--no-preprocessor") enable_preprocessor = false;
        else if (arg == "--no-peephole") enable_peephole = false;
        else if (arg == "--peephole") enable_peephole = true;
        else if (arg == "--trace-peephole") { enable_peephole = true; trace_peephole = true; }
        else if (arg == "--dump-jit-stack") dump_jit_stack = true;
        else if (arg == "-I" || arg == "--include-path") {
            if (i + 1 < argc) include_paths.push_back(argv[++i]);
            else {
                std::cerr << "Error: -I/--include-path requires a directory path argument" << std::endl;
                return false;
            }
        }
        else if (arg == "--call" || arg == "-c") {
            if (i + 1 < argc) call_entry_name = argv[++i];
            else { std::cerr << "Error: --call option requires a name." << std::endl; return false; }
        } else if (arg == "--break" || arg == "-b") {
            if (i + 1 < argc) {
                g_jit_breakpoint_label = argv[++i];
                if (i + 1 < argc) {
                    std::string next_arg = argv[i+1];
                    if (next_arg.length() > 0 && (next_arg[0] == '+' || next_arg[0] == '-')) {
                        try { offset_instructions = std::stoi(next_arg); ++i; }
                        catch (const std::exception&) { std::cerr << "Error: Invalid offset for --break: " << next_arg << std::endl; return false; }
                    }
                }
            } else { std::cerr << "Error: --break option requires a label name." << std::endl; return false; }
        } else if (arg == "--help" || arg == "-h") {
            std::cout << "Usage: " << argv[0] << " [options] <input_file.bcl>\n"
                      << "Options:\n"
                      << "  --run, -r              : JIT compile and execute the code.\n"
                      << "  --asm, -a              : Generate ARM64 assembly file.\n"
                      << "  --exec, -e             : Assemble, build with clang, and execute.\n"
                      << "  --opt, -o              : Enable AST-to-AST optimization passes.\n"
                      << "  --trace, -T            : Enable all detailed tracing (verbose).\n"
                      << "  --trace-lexer          : Enable lexer tracing.\n"
                      << "  --trace-parser         : Enable parser tracing.\n"
                      << "  --trace-ast            : Enable AST building and transformation tracing.\n"
                      << "  --trace-cfg            : Enable control flow graph construction tracing.\n"
                      << "  --trace-codegen        : Enable code generation tracing.\n"
                      << "  --trace-opt            : Enable optimizer tracing.\n"
                      << "  --trace-liveness       : Enable liveness analysis tracing.\n"
                      << "  --trace-runtime        : Enable runtime function tracing.\n"
                      << "  --trace-symbols        : Enable symbol table construction tracing.\n"
                      << "  --trace-heap           : Enable heap manager tracing.\n"
                      << "  --trace-preprocessor   : Enable preprocessor tracing.\n"
                      << "  --no-preprocessor      : Disable GET directive processing.\n"
                      << "  --peephole             : Enable peephole optimization (enabled by default).\n"
                      << "  --no-peephole          : Disable peephole optimization.\n"
                      << "  --trace-peephole       : Enable detailed peephole optimization tracing.\n"
                      << "  -I path, --include-path path : Add directory to include search path for GET directives.\n"
                      << "                          Multiple -I flags can be specified for additional paths.\n"
                      << "                          Search order: 1) Current file's directory 2) Specified include paths\n"
                      << "  --dump-jit-stack       : Dumps the JIT stack memory after execution.\n"
                      << "  --call name, -c name   : JIT-call the routine with the given label.\n"
                      << "  --break label[+/-off]  : Insert a BRK #0 instruction at the specified label, with optional offset.\n"
                      << "  --help, -h             : Display this help message.\n";
            return false;
        } else if (input_filepath.empty() && arg[0] != '-') {
            input_filepath = arg;
        } else if (!input_filepath.empty() && arg[0] != '-') {
            std::cerr << "Error: Multiple input files specified: '" << input_filepath << "' and '" << arg << "'" << std::endl;
            return false;
        } else {
            std::cerr << "Error: Unknown argument: " << arg << std::endl;
            std::cerr << "Use --help for a list of valid options." << std::endl;
            return false;
        }
    }

    if (input_filepath.empty()) {
        std::cerr << "Error: No input file specified. Use --help for usage.\n";
        return false;
    }
    return true;
}

/**
 * @brief Handles static compilation to an assembly file and optionally builds and runs it.
 */
void handle_static_compilation(bool exec_mode, const std::string& base_name, const InstructionStream& instruction_stream, const DataGenerator& data_generator, bool enable_debug_output) {
    if (enable_debug_output) std::cout << "Performing static linking for assembly file generation...\n";
    Linker static_linker;
    std::vector<Instruction> static_instructions = static_linker.process(
        instruction_stream, LabelManager::instance(), RuntimeManager::instance(), 0, nullptr, nullptr, enable_debug_output);

    std::string asm_output_path = base_name + ".s";
    AssemblyWriter asm_writer;
    asm_writer.write_to_file(asm_output_path, static_instructions, LabelManager::instance(), data_generator);

    if (exec_mode) {
        if (enable_debug_output) std::cout << "\n--- Exec Mode (via clang) ---\n";
        std::string executable_output_path = "testrun";
        std::string clang_command = "clang -g -o " + executable_output_path  + " " + asm_output_path + " bcpl_runtime.o";
       if (enable_debug_output) std::cout << "Executing: " << clang_command << std::endl;

        int build_result = system(clang_command.c_str());
        if (build_result == 0) {
            if (enable_debug_output) std::cout << "Build successful." << std::endl;
            std::string run_command = "./" + executable_output_path;
            if (enable_debug_output) std::cout << "\n--- Running '" << run_command << "' ---\n";
            int run_result = system(run_command.c_str());
            if (enable_debug_output) std::cout << "--- Program finished with exit code: " << WEXITSTATUS(run_result) << " ---\n";
        } else {
            std::cerr << "Error: Build failed with code " << build_result << std::endl;
        }
    }
}

/**
 * @brief Handles the JIT compilation process: linking, memory population, and final code commit.
 * @return A pointer to the executable code buffer.
 */
void* handle_jit_compilation(void* jit_data_memory_base, InstructionStream& instruction_stream, int offset_instructions, bool enable_debug_output) {
    if (!g_jit_code_buffer) {
        g_jit_code_buffer = std::make_unique<CodeBuffer>(32 * 1024 * 1024, enable_debug_output);
    }
    void* code_buffer_base = g_jit_code_buffer->getMemoryPointer();
    Linker jit_linker;

    std::vector<Instruction> finalized_jit_instructions = jit_linker.process(
        instruction_stream, LabelManager::instance(), RuntimeManager::instance(),
        reinterpret_cast<size_t>(code_buffer_base),
        code_buffer_base,
        jit_data_memory_base, enable_debug_output);

    if (enable_debug_output) std::cout << "Populating JIT memory...\n";

    std::vector<Instruction> code_and_rodata_segment;
    // Separate code/rodata from RW data
    for (size_t i = 0; i < finalized_jit_instructions.size(); ++i) {
        const auto& instr = finalized_jit_instructions[i];

        // **FIX**: Explicitly skip label-defining pseudo-instructions.
        if (instr.is_label_definition) {
            continue;
        }

        bool is_rw_data = instr.is_data_value && instr.target_label.rfind("L_str", 0) != 0;

        if (!is_rw_data) {
            code_and_rodata_segment.push_back(instr);
        } else {
            // RW data: copy initial value into jit_data_memory_base
            size_t offset = instr.address - reinterpret_cast<size_t>(jit_data_memory_base);
            char* dest = static_cast<char*>(jit_data_memory_base) + offset;

            if (instr.assembly_text.find("DCQ") != std::string::npos) {
                if (i + 1 < finalized_jit_instructions.size()) {
                    const auto& upper_instr = finalized_jit_instructions[i + 1];
                    uint64_t value = (static_cast<uint64_t>(upper_instr.encoding) << 32) | instr.encoding;
                    memcpy(dest, &value, sizeof(uint64_t));
                    i++; // Skip next instruction (upper half)
                } else {
                    if (enable_debug_output) std::cerr << "Warning: DCQ lower half found without upper half at end of stream.\n";
                }
            } else {
                memcpy(dest, &instr.encoding, sizeof(uint32_t));
            }
        }
    }

    // Set breakpoint if requested
    if (!g_jit_breakpoint_label.empty()) {
        try {
            size_t breakpoint_target_address = LabelManager::instance().get_label_address(g_jit_breakpoint_label) + (offset_instructions * 4);
            bool breakpoint_set = false;
            for (Instruction& instr : code_and_rodata_segment) {
                if (instr.address == breakpoint_target_address) {
                    instr.encoding = 0xD4200000; // BRK #0
                    instr.assembly_text = "BRK #0 ; [DEBUG BREAKPOINT]";
                    breakpoint_set = true;
                    if (enable_debug_output) std::cout << "DEBUG: Breakpoint set at 0x" << std::hex << breakpoint_target_address << std::dec << "\n";
                    break;
                }
            }
            if (!breakpoint_set) std::cerr << "Warning: Breakpoint label '" << g_jit_breakpoint_label << "' not found. Breakpoint not set.\n";
        } catch (const std::runtime_error& e) {
            std::cerr << "Error setting breakpoint: " << e.what() << "\n";
        }
    }

    // Only code/rodata go into the executable buffer
    return g_jit_code_buffer->commit(code_and_rodata_segment);
}

/**
 * @brief Handles the execution of the JIT-compiled code.
 */
void handle_jit_execution(void* code_buffer_base, const std::string& call_entry_name, bool dump_jit_stack, bool enable_debug_output) {
    if (!code_buffer_base) {
        std::cerr << "Cannot execute JIT code: function pointer is null." << std::endl;
        return;
    }

    if (enable_debug_output) std::cout << "\n--- JIT Execution ---\n";

    size_t entry_offset = LabelManager::instance().get_label_address(call_entry_name) - reinterpret_cast<size_t>(code_buffer_base);
    void* entry_address = static_cast<char*>(code_buffer_base) + entry_offset;

    if (enable_debug_output) std::cout << "JIT execution enabled. Entry point '" << call_entry_name << "' at " << entry_address << std::endl;

    JITFunc jit_func = reinterpret_cast<JITFunc>(entry_address);
    g_jit_executor = std::make_unique<JITExecutor>(dump_jit_stack);

    if (RuntimeManager::instance().isTracingEnabled()) {
        std::cout << "[JITExecutor] Starting execution of JIT-compiled function at address: "
                  << entry_address << std::endl;
    }
    
    // Execute the JIT-compiled function
    std::cout << "Starting BCPL program..." << std::endl;
    std::cout.flush(); // Ensure the message is displayed
    fflush(stdout);    // Force flush stdout buffer
    
    int64_t result = g_jit_executor->execute(jit_func);
    
    std::cout.flush(); // Flush again to ensure output is visible
    fflush(stdout);    // Force flush stdout buffer
    
    if (enable_debug_output) {
        std::cout << "JIT function completed with result: " << result << std::endl;
    }

}

    // JIT execution code moved to handle_jit_execution function

/**
 * @brief Reads the entire content of a file into a string.
 */
std::string read_file_content(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        throw std::runtime_error("Could not open file: " + filepath);
    }
    return std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
}



/**
 * @brief Sets up signal handlers for common fatal errors.
 */
