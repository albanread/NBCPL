[DEBUG EARLY] Compiler starting with argc=5
Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=tests/bcl_tests/class1.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.1578
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/tests/bcl_tests/class1.bcl"
// class1.bcl - Test for class member variable access

CLASS Point $(

    DECL x, y

    // Constructor
    ROUTINE CREATE(initialX, initialY) BE $(
        x := initialX
        y := initialY

        WRITES("Point created at (")
        WRITEN(x)
        WRITES(", ")
        WRITEN(y)
        WRITES(")*N")
    $)

    // Accessor methods
    FUNCTION getX() = VALOF $(
        RESULTIS x
    $)

    FUNCTION getY() = VALOF $(
        RESULTIS y
    $)

    // Setter method
    ROUTINE set(newX, newY) BE $(
        x := newX
        y := newY
        //WRITES("Point moved to (")
        //WRITEN(x)
        //WRITES(", ")
        //WRITEN(y)
        //WRITES(")*N")
    $)

    // Destructor (optional but good practice)
    ROUTINE RELEASE() BE $(
        WRITES("Point destroyed*N")
    $)
$)

// Test class inheritance and member variable offsets
CLASS ColorPoint EXTENDS Point $(

    DECL color

    // Override constructor to include color
    ROUTINE CREATE(initialX, initialY, initialColor) BE $(
        SUPER.CREATE(initialX, initialY)
        color := initialColor
        WRITES("ColorPoint created at (")
        WRITEN(x)
        WRITES(", ")
        WRITEN(y)
        WRITES(") with color ")
        WRITEN(color)
        WRITES("*N")
    $)

    ROUTINE setColor( c ) BE $(
        SELF.color := c
    $)

    // Color accessor
    FUNCTION getColor() = VALOF $(
        RESULTIS color
    $)

$)

LET makePoint() = VALOF $(
    LET p = NEW Point(50,75)
    SEND p
$)

LET START() BE $(
    WRITES("Testing class member variable access with correct offsets*N")
    WRITES("=================================================*N*N")

    // Test basic Point class
    WRITES("1. Basic Point class test:*N")
    LET p = makePoint()
    ACCEPT p
    WRITES("Reading values: x=")
    WRITEN(p.getX())
    WRITES(", y=")
    WRITEN(p.getY())
    WRITES("*N")

    WRITES("Setting new values...*N")
    p.set(100, 200)

    WRITES("Reading new values: x=")
    WRITEN(p.getX())
    WRITES(", y=")
    WRITEN(p.getY())
    WRITES("*N*N")

    // Test inheritance with ColorPoint
    WRITES("2. Inherited ColorPoint class test:*N")
    LET cp = NEW ColorPoint
    cp.CREATE(130, 140, 255)

    WRITES("Reading values: x=")
    WRITEN(cp.getX())
    WRITES(", y=")
    WRITEN(cp.getY())
    WRITES(", color=")
    WRITEN(cp.getColor())
    WRITES("*N")

    WRITES("Setting new values...*N")
    cp.set(60, 80)  // Note: using inherited set() method
    cp.setColor(123)
    WRITES("Reading new values: x=")
    WRITEN(cp.getX())
    WRITES(", y=")
    WRITEN(cp.getY())
    WRITES(", color=")
    WRITEN(cp.getColor())
    WRITES("*N")

    WRITES("*NTest completed successfully*N")
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x10091c7c8
Registered 91 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x10091b4fc | args: 0 | table_offset: 712
  FINISH           | address: 0x10091a2ac | args: 0 | table_offset: 704
  FABS             | address: 0x10091a65c | args: 1 | table_offset: 672
  FSIN             | address: 0x10091a620 | args: 1 | table_offset: 648
  FILE_EOF         | address: 0x10091d914 | args: 1 | table_offset: 616
  RAND             | address: 0x10091a4ac | args: 1 | table_offset: 624
  FILE_TELL        | address: 0x10091d8bc | args: 1 | table_offset: 608
  FILE_SEEK        | address: 0x10091d7f8 | args: 3 | table_offset: 600
  FILE_WRITE       | address: 0x10091d6e0 | args: 3 | table_offset: 592
  FIX              | address: 0x10091a69c | args: 1 | table_offset: 696
  FILE_READS       | address: 0x10091d12c | args: 1 | table_offset: 576
  FILE_WRITES      | address: 0x10091ce50 | args: 2 | table_offset: 568
  FEXP             | address: 0x10091a688 | args: 1 | table_offset: 688
  FILE_CLOSE       | address: 0x10091cde4 | args: 1 | table_offset: 560
  FILE_OPEN_APPEND | address: 0x10091cd54 | args: 1 | table_offset: 552
  SLURP            | address: 0x10091ad84 | args: 1 | table_offset: 520
  PACKSTRING       | address: 0x10091a6b4 | args: 1 | table_offset: 504
  STRLEN           | address: 0x10091a2bc | args: 1 | table_offset: 496
  FCOS             | address: 0x10091a634 | args: 1 | table_offset: 656
  STRCMP           | address: 0x10091a31c | args: 2 | table_offset: 488
  STRCOPY          | address: 0x10091a400 | args: 2 | table_offset: 480
  FIND             | address: 0x100920e3c | args: 3 | table_offset: 448
  DEEPCOPYLITERALLIST | address: 0x100920ab4 | args: 1 | table_offset: 432
  DEEPCOPYLIST     | address: 0x10092091c | args: 1 | table_offset: 424
  COPYLIST         | address: 0x10092081c | args: 1 | table_offset: 416
  CONCAT           | address: 0x100920c54 | args: 2 | table_offset: 408
  BCPL_CONCAT_LISTS | address: 0x100920c54 | args: 2 | table_offset: 400
  SPIT             | address: 0x10091b2b0 | args: 2 | table_offset: 528
  JOIN             | address: 0x10091feb8 | args: 2 | table_offset: 472
  LPND             | address: 0x1009203c8 | args: 2 | table_offset: 392
  SPND             | address: 0x1009202f8 | args: 2 | table_offset: 384
  FPND             | address: 0x100920228 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x10092130c | args: 1 | table_offset: 720
  BCPL_LIST_APPEND_INT | address: 0x100920158 | args: 2 | table_offset: 344
  GETVEC           | address: 0x10091c88c | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x1007e37d8 | args: 0 | table_offset: 312
  APND             | address: 0x100920158 | args: 2 | table_offset: 368
  HEAPMANAGER_ENTER_SCOPE | address: 0x1007e3710 | args: 0 | table_offset: 280
  HEAPMANAGER_SETSAMMENABLED | address: 0x1007e36bc | args: 1 | table_offset: 296
  HEAPMANAGER_EXIT_SCOPE | address: 0x1007e373c | args: 0 | table_offset: 288
  PIC_RUNTIME_HELPER | address: 0x10091c940 | args: 0 | table_offset: 272
  OBJECT_HEAP_FREE | address: 0x10091c904 | args: 1 | table_offset: 256
  OBJECT_HEAP_ALLOC | address: 0x10091c8e0 | args: 1 | table_offset: 248
  BCPL_LIST_GET_REST | address: 0x100920684 | args: 1 | table_offset: 216
  FRND             | address: 0x10091a538 | args: 0 | table_offset: 640
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x1009205cc | args: 1 | table_offset: 200
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x100920568 | args: 1 | table_offset: 192
  RUNTIME_METHOD_LOOKUP | address: 0x10091c928 | args: 2 | table_offset: 264
  FREEVEC          | address: 0x10091c7c8 | args: 1 | table_offset: 136
  BCPL_BOUNDS_ERROR | address: 0x10091878c | args: 3 | table_offset: 184
  WRITEF4          | address: 0x100919de0 | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x100920fe0 | args: 1 | table_offset: 144
  BCPL_ALLOC_CHARS | address: 0x10091c770 | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x100920228 | args: 2 | table_offset: 352
  GET_FREE_LIST_HEAD_ADDR | address: 0x100921300 | args: 0 | table_offset: 328
  BCPL_GET_ATOM_TYPE | address: 0x1009206e8 | args: 1 | table_offset: 224
  FWRITE           | address: 0x1009197bc | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x1009200f8 | args: 0 | table_offset: 336
  SPLIT            | address: 0x10091fb4c | args: 2 | table_offset: 464
  BCPL_FREE_CELLS  | address: 0x1009212fc | args: 0 | table_offset: 320
  RND              | address: 0x10091a58c | args: 1 | table_offset: 632
  HEAPMANAGER_ISSAMMENABLED | address: 0x1007e36ec | args: 0 | table_offset: 304
  WRITEC           | address: 0x10091a09c | args: 1 | table_offset: 88
  MALLOC           | address: 0x10091c710 | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x10091c710 | args: 3 | table_offset: 104
  FTAN             | address: 0x10091a648 | args: 1 | table_offset: 664
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 240
  BCPL_GET_LAST_ERROR | address: 0x10091860c | args: 1 | table_offset: 160
  RDCH             | address: 0x10091a260 | args: 0 | table_offset: 96
  FILE_READ        | address: 0x10091d5cc | args: 3 | table_offset: 584
  UNPACKSTRING     | address: 0x10091a9ec | args: 1 | table_offset: 512
  WRITEF5          | address: 0x100919e6c | args: 6 | table_offset: 64
  FILTER           | address: 0x100920f30 | args: 2 | table_offset: 456
  BCPL_FREE_LIST_SAFE | address: 0x1009210e8 | args: 1 | table_offset: 152
  FILE_OPEN_WRITE  | address: 0x10091ccc4 | args: 1 | table_offset: 544
  FILE_OPEN_READ   | address: 0x10091c944 | args: 1 | table_offset: 536
  BCPL_LIST_GET_NTH | address: 0x100920750 | args: 2 | table_offset: 232
  WRITEF7          | address: 0x100919fa8 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x100919d60 | args: 4 | table_offset: 48
  WRITEF6          | address: 0x100919f04 | args: 7 | table_offset: 72
  REVERSE          | address: 0x100920d54 | args: 1 | table_offset: 440
  WRITEF2          | address: 0x100919cec | args: 3 | table_offset: 40
  WRITEF1          | address: 0x100919c84 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x100920634 | args: 1 | table_offset: 208
  BCPL_CLEAR_ERRORS | address: 0x1009186bc | args: 0 | table_offset: 168
  WRITEF           | address: 0x100919800 | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x1009202f8 | args: 2 | table_offset: 360
  WRITES           | address: 0x10091954c | args: 1 | table_offset: 0
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x100921354 | args: 0 | table_offset: 176
  FLOG             | address: 0x10091a674 | args: 1 | table_offset: 680
  WRITEN           | address: 0x10091a058 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
        RoutineDeclaration: RELEASE
          Parameters: _this 
          Body:
            BlockStatement:
              Statements:
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point destroyed
"
    ClassDeclaration: ColorPoint
      Extends: Point
      Members:
        LetDeclaration:
          Name: color
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY initialColor 
          Body:
            BlockStatement:
              Statements:
                RoutineCallStatement:
                  Callee:
                    SuperMethodAccess: CREATE
                  Arguments:
                    VariableAccess: initialX
                    VariableAccess: initialY
                AssignmentStatement:
                  LHS:
                    VariableAccess: color
                  RHS:
                    VariableAccess: initialColor
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "ColorPoint created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ") with color "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: color
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "
"
        RoutineDeclaration: setColor
          Parameters: _this c 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    MemberAccess: color
                      Object:
                        VariableAccess: SELF
                    RHS:
                      VariableAccess: c
          FunctionDeclaration: getColor
            Parameters: _this 
            Body:
              ValofExpression:
                BlockStatement:
                  Statements:
                    ResultisStatement:
                      VariableAccess: color
      FunctionDeclaration: makePoint
        Body:
          ValofExpression:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: p
                  RHS:
                    NewExpression: Point
                      Arguments:
                        NumberLiteral: 50
                        NumberLiteral: 75
                ResultisStatement:
                  VariableAccess: p
      RoutineDeclaration: START
        Body:
          BlockStatement:
            Statements:
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Testing class member variable access with correct offsets
"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "=================================================

"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "1. Basic Point class test:
"
              AssignmentStatement:
                LHS:
                  VariableAccess: p
                RHS:
                  FunctionCall:
                    Callee:
                      VariableAccess: makePoint
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Reading values: x="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getX
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", y="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    FunctionCall:
                      Callee:
                        MemberAccess: getY
                          Object:
                            VariableAccess: p
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "
"
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Setting new values...
"
                  RoutineCallStatement:
                    Callee:
                      MemberAccess: set
                        Object:
                          VariableAccess: p
                      Arguments:
                        NumberLiteral: 100
                        NumberLiteral: 200
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "Reading new values: x="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getX
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: ", y="
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITEN
                        Arguments:
                          FunctionCall:
                            Callee:
                              MemberAccess: getY
                                Object:
                                  VariableAccess: p
                        RoutineCallStatement:
                          Callee:
                            VariableAccess: WRITES
                          Arguments:
                            StringLiteral: "

"
                        RoutineCallStatement:
                          Callee:
                            VariableAccess: WRITES
                          Arguments:
                            StringLiteral: "2. Inherited ColorPoint class test:
"
                        AssignmentStatement:
                          LHS:
                            VariableAccess: cp
                          RHS:
                            NewExpression: ColorPoint
                        RoutineCallStatement:
                          Callee:
                            MemberAccess: CREATE
                              Object:
                                VariableAccess: cp
                            Arguments:
                              NumberLiteral: 130
                              NumberLiteral: 140
                              NumberLiteral: 255
                          RoutineCallStatement:
                            Callee:
                              VariableAccess: WRITES
                            Arguments:
                              StringLiteral: "Reading values: x="
                          RoutineCallStatement:
                            Callee:
                              VariableAccess: WRITEN
                            Arguments:
                              FunctionCall:
                                Callee:
                                  MemberAccess: getX
                                    Object:
                                      VariableAccess: cp
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: ", y="
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITEN
                              Arguments:
                                FunctionCall:
                                  Callee:
                                    MemberAccess: getY
                                      Object:
                                        VariableAccess: cp
                              RoutineCallStatement:
                                Callee:
                                  VariableAccess: WRITES
                                Arguments:
                                  StringLiteral: ", color="
                              RoutineCallStatement:
                                Callee:
                                  VariableAccess: WRITEN
                                Arguments:
                                  FunctionCall:
                                    Callee:
                                      MemberAccess: getColor
                                        Object:
                                          VariableAccess: cp
                                RoutineCallStatement:
                                  Callee:
                                    VariableAccess: WRITES
                                  Arguments:
                                    StringLiteral: "
"
                                RoutineCallStatement:
                                  Callee:
                                    VariableAccess: WRITES
                                  Arguments:
                                    StringLiteral: "Setting new values...
"
                                RoutineCallStatement:
                                  Callee:
                                    MemberAccess: set
                                      Object:
                                        VariableAccess: cp
                                    Arguments:
                                      NumberLiteral: 60
                                      NumberLiteral: 80
                                  RoutineCallStatement:
                                    Callee:
                                      MemberAccess: setColor
                                        Object:
                                          VariableAccess: cp
                                      Arguments:
                                        NumberLiteral: 123
                                    RoutineCallStatement:
                                      Callee:
                                        VariableAccess: WRITES
                                      Arguments:
                                        StringLiteral: "Reading new values: x="
                                    RoutineCallStatement:
                                      Callee:
                                        VariableAccess: WRITEN
                                      Arguments:
                                        FunctionCall:
                                          Callee:
                                            MemberAccess: getX
                                              Object:
                                                VariableAccess: cp
                                      RoutineCallStatement:
                                        Callee:
                                          VariableAccess: WRITES
                                        Arguments:
                                          StringLiteral: ", y="
                                      RoutineCallStatement:
                                        Callee:
                                          VariableAccess: WRITEN
                                        Arguments:
                                          FunctionCall:
                                            Callee:
                                              MemberAccess: getY
                                                Object:
                                                  VariableAccess: cp
                                        RoutineCallStatement:
                                          Callee:
                                            VariableAccess: WRITES
                                          Arguments:
                                            StringLiteral: ", color="
                                        RoutineCallStatement:
                                          Callee:
                                            VariableAccess: WRITEN
                                          Arguments:
                                            FunctionCall:
                                              Callee:
                                                MemberAccess: getColor
                                                  Object:
                                                    VariableAccess: cp
                                          RoutineCallStatement:
                                            Callee:
                                              VariableAccess: WRITES
                                            Arguments:
                                              StringLiteral: "
"
                                          RoutineCallStatement:
                                            Callee:
                                              VariableAccess: WRITES
                                            Arguments:
                                              StringLiteral: "
Test completed successfully
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
        RoutineDeclaration: RELEASE
          Parameters: _this 
          Body:
            BlockStatement:
              Statements:
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point destroyed
"
    ClassDeclaration: ColorPoint
      Extends: Point
      Members:
        LetDeclaration:
          Name: color
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY initialColor 
          Body:
            BlockStatement:
              Statements:
                RoutineCallStatement:
                  Callee:
                    SuperMethodAccess: CREATE
                  Arguments:
                    VariableAccess: initialX
                    VariableAccess: initialY
                AssignmentStatement:
                  LHS:
                    VariableAccess: color
                  RHS:
                    VariableAccess: initialColor
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "ColorPoint created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ") with color "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: color
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "
"
        RoutineDeclaration: setColor
          Parameters: _this c 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    MemberAccess: color
                      Object:
                        VariableAccess: SELF
                    RHS:
                      VariableAccess: c
          FunctionDeclaration: getColor
            Parameters: _this 
            Body:
              ValofExpression:
                BlockStatement:
                  Statements:
                    ResultisStatement:
                      VariableAccess: color
      FunctionDeclaration: makePoint
        Body:
          ValofExpression:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: p
                  RHS:
                    NewExpression: Point
                      Arguments:
                        NumberLiteral: 50
                        NumberLiteral: 75
                ResultisStatement:
                  VariableAccess: p
      RoutineDeclaration: START
        Body:
          BlockStatement:
            Statements:
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Testing class member variable access with correct offsets
"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "=================================================

"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "1. Basic Point class test:
"
              AssignmentStatement:
                LHS:
                  VariableAccess: p
                RHS:
                  FunctionCall:
                    Callee:
                      VariableAccess: makePoint
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Reading values: x="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getX
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", y="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    FunctionCall:
                      Callee:
                        MemberAccess: getY
                          Object:
                            VariableAccess: p
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "
"
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Setting new values...
"
                  RoutineCallStatement:
                    Callee:
                      MemberAccess: set
                        Object:
                          VariableAccess: p
                      Arguments:
                        NumberLiteral: 100
                        NumberLiteral: 200
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "Reading new values: x="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getX
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: ", y="
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITEN
                        Arguments:
                          FunctionCall:
                            Callee:
                              MemberAccess: getY
                                Object:
                                  VariableAccess: p
                        RoutineCallStatement:
                          Callee:
                            VariableAccess: WRITES
                          Arguments:
                            StringLiteral: "

"
                        RoutineCallStatement:
                          Callee:
                            VariableAccess: WRITES
                          Arguments:
                            StringLiteral: "2. Inherited ColorPoint class test:
"
                        AssignmentStatement:
                          LHS:
                            VariableAccess: cp
                          RHS:
                            NewExpression: ColorPoint
                        RoutineCallStatement:
                          Callee:
                            MemberAccess: CREATE
                              Object:
                                VariableAccess: cp
                            Arguments:
                              NumberLiteral: 130
                              NumberLiteral: 140
                              NumberLiteral: 255
                          RoutineCallStatement:
                            Callee:
                              VariableAccess: WRITES
                            Arguments:
                              StringLiteral: "Reading values: x="
                          RoutineCallStatement:
                            Callee:
                              VariableAccess: WRITEN
                            Arguments:
                              FunctionCall:
                                Callee:
                                  MemberAccess: getX
                                    Object:
                                      VariableAccess: cp
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: ", y="
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITEN
                              Arguments:
                                FunctionCall:
                                  Callee:
                                    MemberAccess: getY
                                      Object:
                                        VariableAccess: cp
                              RoutineCallStatement:
                                Callee:
                                  VariableAccess: WRITES
                                Arguments:
                                  StringLiteral: ", color="
                              RoutineCallStatement:
                                Callee:
                                  VariableAccess: WRITEN
                                Arguments:
                                  FunctionCall:
                                    Callee:
                                      MemberAccess: getColor
                                        Object:
                                          VariableAccess: cp
                                RoutineCallStatement:
                                  Callee:
                                    VariableAccess: WRITES
                                  Arguments:
                                    StringLiteral: "
"
                                RoutineCallStatement:
                                  Callee:
                                    VariableAccess: WRITES
                                  Arguments:
                                    StringLiteral: "Setting new values...
"
                                RoutineCallStatement:
                                  Callee:
                                    MemberAccess: set
                                      Object:
                                        VariableAccess: cp
                                    Arguments:
                                      NumberLiteral: 60
                                      NumberLiteral: 80
                                  RoutineCallStatement:
                                    Callee:
                                      MemberAccess: setColor
                                        Object:
                                          VariableAccess: cp
                                      Arguments:
                                        NumberLiteral: 123
                                    RoutineCallStatement:
                                      Callee:
                                        VariableAccess: WRITES
                                      Arguments:
                                        StringLiteral: "Reading new values: x="
                                    RoutineCallStatement:
                                      Callee:
                                        VariableAccess: WRITEN
                                      Arguments:
                                        FunctionCall:
                                          Callee:
                                            MemberAccess: getX
                                              Object:
                                                VariableAccess: cp
                                      RoutineCallStatement:
                                        Callee:
                                          VariableAccess: WRITES
                                        Arguments:
                                          StringLiteral: ", y="
                                      RoutineCallStatement:
                                        Callee:
                                          VariableAccess: WRITEN
                                        Arguments:
                                          FunctionCall:
                                            Callee:
                                              MemberAccess: getY
                                                Object:
                                                  VariableAccess: cp
                                        RoutineCallStatement:
                                          Callee:
                                            VariableAccess: WRITES
                                          Arguments:
                                            StringLiteral: ", color="
                                        RoutineCallStatement:
                                          Callee:
                                            VariableAccess: WRITEN
                                          Arguments:
                                            FunctionCall:
                                              Callee:
                                                MemberAccess: getColor
                                                  Object:
                                                    VariableAccess: cp
                                          RoutineCallStatement:
                                            Callee:
                                              VariableAccess: WRITES
                                            Arguments:
                                              StringLiteral: "
"
                                          RoutineCallStatement:
                                            Callee:
                                              VariableAccess: WRITES
                                            Arguments:
                                              StringLiteral: "
Test completed successfully
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing class declaration: Point
[SymbolDiscoveryPass] Processing member variable declaration in class: Point
[SymbolDiscoveryPass] Added member variable: x to class Point
[SymbolDiscoveryPass] Added member variable: y to class Point
[SymbolDiscoveryPass] Added class method routine: Point::CREATE
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::CREATE
[SymbolDiscoveryPass] Added parameter: _this in method Point::CREATE
[SymbolDiscoveryPass] Added parameter: initialX in method Point::CREATE
[SymbolDiscoveryPass] Added parameter: initialY in method Point::CREATE
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method function: Point::getX
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::getX
[SymbolDiscoveryPass] Added parameter: _this in method Point::getX
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method function: Point::getY
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::getY
[SymbolDiscoveryPass] Added parameter: _this in method Point::getY
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method routine: Point::set
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::set
[SymbolDiscoveryPass] Added parameter: _this in method Point::set
[SymbolDiscoveryPass] Added parameter: newX in method Point::set
[SymbolDiscoveryPass] Added parameter: newY in method Point::set
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method routine: Point::RELEASE
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::RELEASE
[SymbolDiscoveryPass] Added parameter: _this in method Point::RELEASE
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing class declaration: ColorPoint
[SymbolDiscoveryPass] Processing member variable declaration in class: ColorPoint
[SymbolDiscoveryPass] Added member variable: color to class ColorPoint
[SymbolDiscoveryPass] Added class method routine: ColorPoint::CREATE
[SymbolDiscoveryPass] Added implicit _this parameter for method: ColorPoint::CREATE
[SymbolDiscoveryPass] Added parameter: _this in method ColorPoint::CREATE
[SymbolDiscoveryPass] Added parameter: initialX in method ColorPoint::CREATE
[SymbolDiscoveryPass] Added parameter: initialY in method ColorPoint::CREATE
[SymbolDiscoveryPass] Added parameter: initialColor in method ColorPoint::CREATE
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method routine: ColorPoint::setColor
[SymbolDiscoveryPass] Added implicit _this parameter for method: ColorPoint::setColor
[SymbolDiscoveryPass] Added parameter: _this in method ColorPoint::setColor
[SymbolDiscoveryPass] Added parameter: c in method ColorPoint::setColor
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method function: ColorPoint::getColor
[SymbolDiscoveryPass] Added implicit _this parameter for method: ColorPoint::getColor
[SymbolDiscoveryPass] Added parameter: _this in method ColorPoint::getColor
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing function declaration: makePoint
[SymbolDiscoveryPass] Added function: makePoint returns INTEGER with 0 parameters
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: p as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: p as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: cp as INTEGER (default INTEGER)

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'x' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'y' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'Point::CREATE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'Point::getX' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol 'Point::getY' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol 'Point::set' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::set')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'Point::RELEASE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::RELEASE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::RELEASE')
Symbol 'color' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='ColorPoint')
Symbol 'ColorPoint::CREATE' (class: ColorPoint, ROUTINE, INTEGER, scope=0, block=0, class_name='ColorPoint', function_name='ColorPoint::CREATE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'initialColor' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'ColorPoint::setColor' (class: ColorPoint, ROUTINE, INTEGER, scope=0, block=0, class_name='ColorPoint', function_name='ColorPoint::setColor')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='ColorPoint::setColor')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::setColor')
Symbol 'c' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::setColor')
Symbol 'ColorPoint::getColor' (class: ColorPoint, FUNCTION, INTEGER, scope=0, block=0, class_name='ColorPoint', function_name='ColorPoint::getColor')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='ColorPoint::getColor')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::getColor')
Symbol 'makePoint' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='makePoint')
Symbol 'p' (LOCAL_VAR, INTEGER, scope=3, block=0, class_name='', function_name='makePoint')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'cp' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered successfully.
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing function signature: makePoint
[SignatureAnalysis] Processing function signature: makePoint
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Function: makePoint
Pass 2: Full AST analysis...
[FIX] Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER] Checking makePoint: is_float_function=0, has_FloatValofExpression=0
[ANALYZER] Set makePoint return type to INTEGER
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting ClassDeclaration: Point
[ANALYZER TRACE] Visiting class.
[ANALYZER TRACE] Visiting RoutineDeclaration: CREATE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::CREATE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Set parameter type: initialX in Point::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialX in Point::CREATE set to 0
[ANALYZER] Set parameter type: initialY in Point::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialY in Point::CREATE set to 0
[ANALYZER] Starting parameter type inference for function: Point::CREATE
[ANALYZER] Analyzing parameter: initialX
[ANALYZER] Parameter 'initialX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: initialY
[ANALYZER] Parameter 'initialY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in Point::CREATE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::CREATE to 1056768 after inference
[ANALYZER] Set parameter type: initialX in Point::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialX in Point::CREATE to 0 after inference
[ANALYZER] Set parameter type: initialY in Point::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialY in Point::CREATE to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: CREATE
[ANALYZER TRACE] Entering block scope: Point::CREATE_block_3 (Function scope remains: Point::CREATE)
[ANALYZER TRACE] BlockStatement: Traversing 7 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialX
[DEBUG get_effective_variable_name] Called with: 'initialX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialX'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialY
[DEBUG get_effective_variable_name] Called with: 'initialY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialY'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939380
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039393b0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939410
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939440
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039394a0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: Point::CREATE
[ANALYZER TRACE] Visiting FunctionDeclaration: getX
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::getX
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::getX
[ANALYZER] Set parameter type: _this in Point::getX to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::getX to 1056768 after inference
[ANALYZER TRACE] Entering block scope: Point::getX_block_3 (Function scope remains: Point::getX)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[DEBUG get_variable_type] Looking for 'x' in function 'Point::getX'
[DEBUG get_variable_type] Found function metrics for 'Point::getX'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'x' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::getX')
[DEBUG get_variable_type] Found in symbol table: x -> 1
[ANALYZER TRACE] Exiting block scope, returning to: Point::getX
[DEBUG get_variable_type] Looking for 'x' in function 'Point::getX'
[DEBUG get_variable_type] Found function metrics for 'Point::getX'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'x' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::getX')
[DEBUG get_variable_type] Found in symbol table: x -> 1
[ANALYZER TRACE] Detected trivial accessor method: Point::getX (accesses: x)
[ANALYZER TRACE] Visiting FunctionDeclaration: getY
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::getY
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::getY
[ANALYZER] Set parameter type: _this in Point::getY to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::getY to 1056768 after inference
[ANALYZER TRACE] Entering block scope: Point::getY_block_3 (Function scope remains: Point::getY)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[DEBUG get_variable_type] Looking for 'y' in function 'Point::getY'
[DEBUG get_variable_type] Found function metrics for 'Point::getY'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'y' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::getY')
[DEBUG get_variable_type] Found in symbol table: y -> 1
[ANALYZER TRACE] Exiting block scope, returning to: Point::getY
[DEBUG get_variable_type] Looking for 'y' in function 'Point::getY'
[DEBUG get_variable_type] Found function metrics for 'Point::getY'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'y' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::getY')
[DEBUG get_variable_type] Found in symbol table: y -> 1
[ANALYZER TRACE] Detected trivial accessor method: Point::getY (accesses: y)
[ANALYZER TRACE] Visiting RoutineDeclaration: set
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::set
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Set parameter type: newX in Point::set to 0
[ANALYZER TRACE] Early parameter type for newX in Point::set set to 0
[ANALYZER] Set parameter type: newY in Point::set to 0
[ANALYZER TRACE] Early parameter type for newY in Point::set set to 0
[ANALYZER] Starting parameter type inference for function: Point::set
[ANALYZER] Analyzing parameter: newX
[ANALYZER] Parameter 'newX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: newY
[ANALYZER] Parameter 'newY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in Point::set to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::set to 1056768 after inference
[ANALYZER] Set parameter type: newX in Point::set to 0
[ANALYZER TRACE] Updated parameter type for newX in Point::set to 0 after inference
[ANALYZER] Set parameter type: newY in Point::set to 0
[ANALYZER TRACE] Updated parameter type for newY in Point::set to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: set
[ANALYZER TRACE] Entering block scope: Point::set_block_5 (Function scope remains: Point::set)
[ANALYZER TRACE] BlockStatement: Traversing 2 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: newX
[DEBUG get_effective_variable_name] Called with: 'newX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'newX'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: newY
[DEBUG get_effective_variable_name] Called with: 'newY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'newY'
[ANALYZER TRACE] Exiting block scope, returning to: Point::set
[ANALYZER TRACE] Visiting RoutineDeclaration: RELEASE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::RELEASE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::RELEASE
[ANALYZER] Set parameter type: _this in Point::RELEASE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::RELEASE to 1056768 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: RELEASE
[ANALYZER TRACE] Entering block scope: Point::RELEASE_block_5 (Function scope remains: Point::RELEASE)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939500
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: Point::RELEASE
[ANALYZER TRACE] Visiting ClassDeclaration: ColorPoint
[ANALYZER TRACE] Visiting class.
[ANALYZER TRACE] Visiting RoutineDeclaration: CREATE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for ColorPoint::CREATE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: ColorPoint
[ANALYZER] Set parameter type: initialX in ColorPoint::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialX in ColorPoint::CREATE set to 0
[ANALYZER] Set parameter type: initialY in ColorPoint::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialY in ColorPoint::CREATE set to 0
[ANALYZER] Set parameter type: initialColor in ColorPoint::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialColor in ColorPoint::CREATE set to 0
[ANALYZER] Starting parameter type inference for function: ColorPoint::CREATE
[ANALYZER] Analyzing parameter: initialX
[ANALYZER] Parameter 'initialX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: initialY
[ANALYZER] Parameter 'initialY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: initialColor
[ANALYZER] Parameter 'initialColor' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in ColorPoint::CREATE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in ColorPoint::CREATE to 1056768 after inference
[ANALYZER] Set parameter type: initialX in ColorPoint::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialX in ColorPoint::CREATE to 0 after inference
[ANALYZER] Set parameter type: initialY in ColorPoint::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialY in ColorPoint::CREATE to 0 after inference
[ANALYZER] Set parameter type: initialColor in ColorPoint::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialColor in ColorPoint::CREATE to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: CREATE
[ANALYZER TRACE] Entering block scope: ColorPoint::CREATE_block_6 (Function scope remains: ColorPoint::CREATE)
[ANALYZER TRACE] BlockStatement: Traversing 9 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939560
[ANALYZER TRACE] Visiting VariableAccess: initialX
[DEBUG get_effective_variable_name] Called with: 'initialX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialX'
[ANALYZER TRACE] Visiting VariableAccess: initialY
[DEBUG get_effective_variable_name] Called with: 'initialY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialY'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialColor
[DEBUG get_effective_variable_name] Called with: 'initialColor'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialColor'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039395c0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039395f0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'ColorPoint'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939650
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939680
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'ColorPoint'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039396e0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939710
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: color
[DEBUG get_effective_variable_name] Called with: 'color'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'color'
[ANALYZER TRACE] Identified 'color' as class member of 'ColorPoint'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939770
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: ColorPoint::CREATE
[ANALYZER TRACE] Visiting RoutineDeclaration: setColor
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for ColorPoint::setColor
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: ColorPoint
[ANALYZER] Set parameter type: c in ColorPoint::setColor to 0
[ANALYZER TRACE] Early parameter type for c in ColorPoint::setColor set to 0
[ANALYZER] Starting parameter type inference for function: ColorPoint::setColor
[ANALYZER] Analyzing parameter: c
[ANALYZER] Parameter 'c' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in ColorPoint::setColor to 1056768
[ANALYZER TRACE] Updated parameter type for _this in ColorPoint::setColor to 1056768 after inference
[ANALYZER] Set parameter type: c in ColorPoint::setColor to 0
[ANALYZER TRACE] Updated parameter type for c in ColorPoint::setColor to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: setColor
[ANALYZER TRACE] Entering block scope: ColorPoint::setColor_block_7 (Function scope remains: ColorPoint::setColor)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: c
[DEBUG get_effective_variable_name] Called with: 'c'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'c'
[ANALYZER TRACE] Visiting VariableAccess: SELF
[ANALYZER TRACE] Rewriting 'SELF' to '_this' in method of class 'ColorPoint'
[DEBUG get_effective_variable_name] Called with: '_this'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: '_this'
[ANALYZER TRACE] Exiting block scope, returning to: ColorPoint::setColor
[ANALYZER TRACE] Detected trivial setter routine: ColorPoint::setColor (sets: color)
[ANALYZER TRACE] Visiting FunctionDeclaration: getColor
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for ColorPoint::getColor
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: ColorPoint
[ANALYZER] Starting parameter type inference for function: ColorPoint::getColor
[ANALYZER] Set parameter type: _this in ColorPoint::getColor to 1056768
[ANALYZER TRACE] Updated parameter type for _this in ColorPoint::getColor to 1056768 after inference
[ANALYZER TRACE] Entering block scope: ColorPoint::getColor_block_7 (Function scope remains: ColorPoint::getColor)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: color
[DEBUG get_effective_variable_name] Called with: 'color'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'color'
[ANALYZER TRACE] Identified 'color' as class member of 'ColorPoint'
[DEBUG get_variable_type] Looking for 'color' in function 'ColorPoint::getColor'
[DEBUG get_variable_type] Found function metrics for 'ColorPoint::getColor'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'color' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'color' in different context 'ColorPoint' (requested context was 'ColorPoint::getColor')
[DEBUG get_variable_type] Found in symbol table: color -> 1
[ANALYZER TRACE] Exiting block scope, returning to: ColorPoint::getColor
[DEBUG get_variable_type] Looking for 'color' in function 'ColorPoint::getColor'
[DEBUG get_variable_type] Found function metrics for 'ColorPoint::getColor'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'color' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'color' in different context 'ColorPoint' (requested context was 'ColorPoint::getColor')
[DEBUG get_variable_type] Found in symbol table: color -> 1
[ANALYZER TRACE] Detected trivial accessor method: ColorPoint::getColor (accesses: color)
[ANALYZER TRACE] Visiting FunctionDeclaration: makePoint
[ANALYZER] Starting parameter type inference for function: makePoint
[ANALYZER TRACE] Entering block scope: makePoint_block_7 (Function scope remains: makePoint)
[ANALYZER TRACE] BlockStatement: Traversing 2 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: p
[DEBUG get_effective_variable_name] Called with: 'p'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 60
[ANALYZER TRACE] Visiting VariableAccess: p
[DEBUG get_effective_variable_name] Called with: 'p'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p'
[DEBUG get_variable_type] Looking for 'p' in function 'makePoint'
[DEBUG get_variable_type] Found function metrics for 'makePoint'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Found in variable_types: p -> 1056768
[ANALYZER TRACE] Exiting block scope, returning to: makePoint
[DEBUG get_variable_type] Looking for 'p' in function 'makePoint'
[DEBUG get_variable_type] Found function metrics for 'makePoint'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Found in variable_types: p -> 1056768
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_8 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 38 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939830
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939890
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039398f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 43
[CALL GRAPH] START calls makePoint
[ANALYZER TRACE]   Detected call to local function: makePoint
[ANALYZER TRACE] Visiting VariableAccess: p
[DEBUG get_effective_variable_name] Called with: 'p'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 72
[ANALYZER TRACE] REMANAGE on 'p'. Automatic cleanup re-enabled.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939980
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x6000039399e0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939a40
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939aa0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 9 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939b00
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 10 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939b60
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 11 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939bc0
[ANALYZER TRACE] BlockStatement: Calling accept on statement 12 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939c20
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 13 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939c80
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 14 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939ce0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 15 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939d40
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 16 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939da0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 17 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939e60
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 18 of type 43
[ANALYZER TRACE] Visiting VariableAccess: cp
[DEBUG get_effective_variable_name] Called with: 'cp'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'cp'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 19 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939e90
[ANALYZER TRACE] BlockStatement: Calling accept on statement 20 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939ef0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 21 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939f50
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 22 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x600003939fb0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 23 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a010
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 24 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a070
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 25 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a0d0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 26 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a130
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 27 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a190
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 28 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a1f0
[ANALYZER TRACE] BlockStatement: Calling accept on statement 29 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a250
[ANALYZER TRACE] BlockStatement: Calling accept on statement 30 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a2b0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 31 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a310
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 32 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a370
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 33 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a3d0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 34 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a430
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 35 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a490
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 36 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a4f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 37 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x60000393a550
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 10
  Allocation-free functions: 8
  Allocation-free leaf functions: 5
  Allocation-free non-leaf functions: 3
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: ColorPoint::CREATE
  Type: int
  Parameters: 4
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 7
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: ColorPoint::getColor
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: ColorPoint::setColor
  Type: int
  Parameters: 2
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::CREATE
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::RELEASE
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 1
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getX
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getY
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::set
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 3
  Float Locals: 0
  Runtime Calls: 31
  Local Function Calls: 1
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: makePoint
  Type: int
  Parameters: 0
  Integer Locals: 2
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
[FIX] Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting ClassDeclaration: Point
[CreateMethodReorderPass] Visiting RoutineDeclaration: CREATE
[CreateMethodReorderPass] Found CREATE method in class Point
[CreateMethodReorderPass] Analyzing CREATE method body (BlockStatement)...
[CreateMethodReorderPass] Analyzing BlockStatement body with 7 statements
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: x
[CreateMethodReorderPass] Variable x is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 0
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: y
[CreateMethodReorderPass] Variable y is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 1
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] No reordering needed - missing _this assignments or SUPER.CREATE calls
[CreateMethodReorderPass] No reordering needed for CREATE method in class Point
[CreateMethodReorderPass] Visiting RoutineDeclaration: set
[CreateMethodReorderPass] Visiting RoutineDeclaration: RELEASE
[CreateMethodReorderPass] Visiting ClassDeclaration: ColorPoint
[CreateMethodReorderPass] Visiting RoutineDeclaration: CREATE
[CreateMethodReorderPass] Found CREATE method in class ColorPoint
[CreateMethodReorderPass] Analyzing CREATE method body (BlockStatement)...
[CreateMethodReorderPass] Analyzing BlockStatement body with 9 statements
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] Found SuperMethodAccessExpression: CREATE
[CreateMethodReorderPass] This is a SUPER.CREATE call!
[CreateMethodReorderPass] Found SUPER.CREATE call at index 0
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: color
[CreateMethodReorderPass] Variable color is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 1
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Reordering needed - moving SUPER.CREATE after _this assignments
[CreateMethodReorderPass] Successfully reordered BlockStatement statements
[CreateMethodReorderPass] Reordered CREATE method in class ColorPoint
[CreateMethodReorderPass] Visiting RoutineDeclaration: setColor
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] CREATE method reordering transformations applied
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
[FIX] Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found ClassDecl at index 0
[CFGBuilderPass] Processing class: Point
[CFGBuilderPass] Found routine method 'CREATE' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::CREATE
[CFGBuilderPass] Creating CFG for routine: Point::CREATE
[CFGBuilderPass] Created CFG for routine: Point::CREATE
[CFGBuilderPass] Created new basic block: Point::CREATE_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::CREATE (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Created new basic block: Point::CREATE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found function method 'getX' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::getX
[CFGBuilderPass] visit(FunctionDeclaration) for function: Point::getX
[CFGBuilderPass] Created CFG for function: Point::getX
[CFGBuilderPass] Created new basic block: Point::getX_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::getX (leaf)
[CFGBuilderPass] Starting optimized block 2 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: Point::getX_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getX
[CFGBuilderPass] Found function method 'getY' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::getY
[CFGBuilderPass] visit(FunctionDeclaration) for function: Point::getY
[CFGBuilderPass] Created CFG for function: Point::getY
[CFGBuilderPass] Created new basic block: Point::getY_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::getY (leaf)
[CFGBuilderPass] Starting optimized block 3 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: Point::getY_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getY
[CFGBuilderPass] Found routine method 'set' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::set
[CFGBuilderPass] Creating CFG for routine: Point::set
[CFGBuilderPass] Created CFG for routine: Point::set
[CFGBuilderPass] Created new basic block: Point::set_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::set (leaf)
[CFGBuilderPass] Starting optimized block 4 variable tracking
[CFGBuilderPass] Created new basic block: Point::set_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found routine method 'RELEASE' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::RELEASE
[CFGBuilderPass] Creating CFG for routine: Point::RELEASE
[CFGBuilderPass] Created CFG for routine: Point::RELEASE
[CFGBuilderPass] Created new basic block: Point::RELEASE_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::RELEASE (call tree)
[CFGBuilderPass] Starting optimized block 5 variable tracking
[CFGBuilderPass] Created new basic block: Point::RELEASE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Processing declaration #1
[CFGBuilderPass] Found ClassDecl at index 1
[CFGBuilderPass] Processing class: ColorPoint
[CFGBuilderPass] Found routine method 'CREATE' in class 'ColorPoint'
[CFGBuilderPass] Using qualified name for method: ColorPoint::CREATE
[CFGBuilderPass] Creating CFG for routine: ColorPoint::CREATE
[CFGBuilderPass] Created CFG for routine: ColorPoint::CREATE
[CFGBuilderPass] Created new basic block: ColorPoint::CREATE_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: ColorPoint::CREATE (call tree)
[CFGBuilderPass] Starting optimized block 6 variable tracking
[CFGBuilderPass] Created new basic block: ColorPoint::CREATE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found routine method 'setColor' in class 'ColorPoint'
[CFGBuilderPass] Using qualified name for method: ColorPoint::setColor
[CFGBuilderPass] Creating CFG for routine: ColorPoint::setColor
[CFGBuilderPass] Created CFG for routine: ColorPoint::setColor
[CFGBuilderPass] Created new basic block: ColorPoint::setColor_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: ColorPoint::setColor (leaf)
[CFGBuilderPass] Starting optimized block 7 variable tracking
[CFGBuilderPass] Created new basic block: ColorPoint::setColor_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found function method 'getColor' in class 'ColorPoint'
[CFGBuilderPass] Using qualified name for method: ColorPoint::getColor
[CFGBuilderPass] visit(FunctionDeclaration) for function: ColorPoint::getColor
[CFGBuilderPass] Created CFG for function: ColorPoint::getColor
[CFGBuilderPass] Created new basic block: ColorPoint::getColor_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: ColorPoint::getColor (leaf)
[CFGBuilderPass] Starting optimized block 8 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: ColorPoint::getColor_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getColor
[CFGBuilderPass] Processing declaration #2
[CFGBuilderPass] Found FunctionDecl at index 2
[CFGBuilderPass] visit(FunctionDeclaration) for function: makePoint
[CFGBuilderPass] Created CFG for function: makePoint
[CFGBuilderPass] Created new basic block: makePoint_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 0 for function 'makePoint'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 0 for function 'makePoint'
[CFGBuilderPass] Starting block 9 variable tracking
[CFGBuilderPass] Tracking variable 'p' in current block
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: makePoint_ResultisCleanup_1
[CFGBuilderPass] Generating scope exit cleanup for: p
[CFGBuilderPass] Skipping legacy cleanup for p - SAMM is active
[CFGBuilderPass] Created new basic block: makePoint_Exit_2
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: makePoint
[CFGBuilderPass] Processing declaration #3
[CFGBuilderPass] Found RoutineDecl at index 3
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 173 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 173 for function 'START'
[CFGBuilderPass] Starting block 10 variable tracking
[CFGBuilderPass] Tracking variable 'p' in current block
[CFGBuilderPass] Tracking variable 'cp' in current block
[CFGBuilderPass] Generating normal block-end cleanup for 2 variables
[CFGBuilderPass] Generating block-end cleanup for: cp
[CFGBuilderPass] Skipping legacy cleanup for cp - SAMM is active
[CFGBuilderPass] Generating block-end cleanup for: p
[CFGBuilderPass] Skipping legacy cleanup for p - SAMM is active
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 174 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 174 for function 'START'
[CFGBuilderPass] Created new basic block: START_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] CFG found for: ColorPoint::setColor
[CFGBuilderPass] CFG found for: ColorPoint::CREATE
[CFGBuilderPass] CFG found for: Point::getY
[CFGBuilderPass] CFG found for: Point::RELEASE
[CFGBuilderPass] CFG found for: Point::getX
[CFGBuilderPass] CFG found for: ColorPoint::getColor
[CFGBuilderPass] CFG found for: Point::set
[CFGBuilderPass] CFG found for: makePoint
[CFGBuilderPass] CFG found for: Point::CREATE
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: ColorPoint::setColor
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: ColorPoint::CREATE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::getY
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::RELEASE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::getX
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: ColorPoint::getColor
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::set
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: makePoint
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]     Found jump-only block: makePoint_ResultisCleanup_1 -> makePoint_Exit_2
[CFGSimplificationPass]       Redirected edge: makePoint_Entry_0 -> makePoint_Exit_2
[CFGSimplificationPass]     Eliminated block: makePoint_ResultisCleanup_1
[CFGSimplificationPass]     Removing unreachable block: makePoint_ResultisCleanup_1
[CFGSimplificationPass]   Iteration 2
[CFGSimplificationPass]   Simplification completed after 2 iterations
[CFGSimplificationPass] Processing function: Point::CREATE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 10
  Blocks eliminated: 1
  Edges redirected: 1
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 39 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] CFG #2 for function 'ColorPoint::setColor' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=ColorPoint::setColor_Exit_1) in function 'ColorPoint::setColor'
[LivenessAnalysisPass] Entering analyze_block for block: ColorPoint::setColor_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for ColorPoint::setColor_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: ColorPoint::setColor_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=ColorPoint::setColor_Entry_0) in function 'ColorPoint::setColor'
[LivenessAnalysisPass] Entering analyze_block for block: ColorPoint::setColor_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for ColorPoint::setColor_Entry_0 with 1 statements
[LivenessAnalysisPass] Statement uses variables: c 
[LivenessAnalysisPass] Exiting analyze_block for block: ColorPoint::setColor_Entry_0
[LivenessAnalysisPass] CFG #3 for function 'ColorPoint::CREATE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=ColorPoint::CREATE_Exit_1) in function 'ColorPoint::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: ColorPoint::CREATE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for ColorPoint::CREATE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: ColorPoint::CREATE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=ColorPoint::CREATE_Entry_0) in function 'ColorPoint::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: ColorPoint::CREATE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for ColorPoint::CREATE_Entry_0 with 9 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: initialX initialY 
[LivenessAnalysisPass] Variables used after call: initialX initialY 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: initialColor 
[LivenessAnalysisPass] Variables used after call: initialColor 
[LivenessAnalysisPass] Intra-block call interval detected in ColorPoint::CREATE_Entry_0 - variables live across calls: initialColor initialX initialY 
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block ColorPoint::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: ColorPoint::CREATE_Entry_0
[LivenessAnalysisPass] CFG #4 for function 'Point::getY' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::getY_Exit_1) in function 'Point::getY'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getY_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::getY_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getY_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::getY_Entry_0) in function 'Point::getY'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getY_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::getY_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getY_Entry_0
[LivenessAnalysisPass] CFG #5 for function 'Point::RELEASE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::RELEASE_Exit_1) in function 'Point::RELEASE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::RELEASE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::RELEASE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::RELEASE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::RELEASE_Entry_0) in function 'Point::RELEASE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::RELEASE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::RELEASE_Entry_0 with 1 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block Point::RELEASE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: Point::RELEASE_Entry_0
[LivenessAnalysisPass] CFG #6 for function 'Point::getX' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::getX_Exit_1) in function 'Point::getX'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getX_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::getX_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getX_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::getX_Entry_0) in function 'Point::getX'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getX_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::getX_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getX_Entry_0
[LivenessAnalysisPass] CFG #7 for function 'ColorPoint::getColor' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=ColorPoint::getColor_Exit_1) in function 'ColorPoint::getColor'
[LivenessAnalysisPass] Entering analyze_block for block: ColorPoint::getColor_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for ColorPoint::getColor_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: ColorPoint::getColor_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=ColorPoint::getColor_Entry_0) in function 'ColorPoint::getColor'
[LivenessAnalysisPass] Entering analyze_block for block: ColorPoint::getColor_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for ColorPoint::getColor_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: ColorPoint::getColor_Entry_0
[LivenessAnalysisPass] CFG #8 for function 'Point::set' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::set_Exit_1) in function 'Point::set'
[LivenessAnalysisPass] Entering analyze_block for block: Point::set_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::set_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::set_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::set_Entry_0) in function 'Point::set'
[LivenessAnalysisPass] Entering analyze_block for block: Point::set_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::set_Entry_0 with 2 statements
[LivenessAnalysisPass] Statement uses variables: newY 
[LivenessAnalysisPass] Statement uses variables: newX 
[LivenessAnalysisPass] Exiting analyze_block for block: Point::set_Entry_0
[LivenessAnalysisPass] CFG #9 for function 'makePoint' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=makePoint_Exit_2) in function 'makePoint'
[LivenessAnalysisPass] Entering analyze_block for block: makePoint_Exit_2
[LivenessAnalysisPass] Starting intra-block analysis for makePoint_Exit_2 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: makePoint_Exit_2
[LivenessAnalysisPass] Analyzing block #2 (id=makePoint_Entry_0) in function 'makePoint'
[LivenessAnalysisPass] Entering analyze_block for block: makePoint_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for makePoint_Entry_0 with 2 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block makePoint_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[LivenessAnalysisPass] Exiting analyze_block for block: makePoint_Entry_0
[LivenessAnalysisPass] CFG #10 for function 'Point::CREATE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::CREATE_Exit_1) in function 'Point::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::CREATE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::CREATE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::CREATE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::CREATE_Entry_0) in function 'Point::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::CREATE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::CREATE_Entry_0 with 7 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: initialY 
[LivenessAnalysisPass] Variables used after call: initialY 
[LivenessAnalysisPass] Statement uses variables: initialX 
[LivenessAnalysisPass] Variables used after call: initialX 
[LivenessAnalysisPass] Intra-block call interval detected in Point::CREATE_Entry_0 - variables live across calls: initialX initialY 
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: Point::CREATE_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: ColorPoint::setColor_Exit_1 in function: ColorPoint::setColor
[LivenessAnalysisPass] Processing block: ColorPoint::setColor_Entry_0 in function: ColorPoint::setColor
[LivenessAnalysisPass] Processing block: ColorPoint::CREATE_Exit_1 in function: ColorPoint::CREATE
[LivenessAnalysisPass] Processing block: ColorPoint::CREATE_Entry_0 in function: ColorPoint::CREATE
[LivenessAnalysisPass] Applying call interval fix to block ColorPoint::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getY_Exit_1 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::getY_Entry_0 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::RELEASE_Exit_1 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::RELEASE_Entry_0 in function: Point::RELEASE
[LivenessAnalysisPass] Applying call interval fix to block Point::RELEASE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getX_Exit_1 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::getX_Entry_0 in function: Point::getX
[LivenessAnalysisPass] Processing block: ColorPoint::getColor_Exit_1 in function: ColorPoint::getColor
[LivenessAnalysisPass] Processing block: ColorPoint::getColor_Entry_0 in function: ColorPoint::getColor
[LivenessAnalysisPass] Processing block: Point::set_Exit_1 in function: Point::set
[LivenessAnalysisPass] Processing block: Point::set_Entry_0 in function: Point::set
[LivenessAnalysisPass] Processing block: makePoint_Exit_2 in function: makePoint
[LivenessAnalysisPass] Processing block: makePoint_Entry_0 in function: makePoint
[LivenessAnalysisPass] Applying call interval fix to block makePoint_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::CREATE_Exit_1 in function: Point::CREATE
[LivenessAnalysisPass] Processing block: Point::CREATE_Entry_0 in function: Point::CREATE
[LivenessAnalysisPass] Applying call interval fix to block Point::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: ColorPoint::setColor_Exit_1 in function: ColorPoint::setColor
[LivenessAnalysisPass] Processing block: ColorPoint::setColor_Entry_0 in function: ColorPoint::setColor
[LivenessAnalysisPass] Processing block: ColorPoint::CREATE_Exit_1 in function: ColorPoint::CREATE
[LivenessAnalysisPass] Processing block: ColorPoint::CREATE_Entry_0 in function: ColorPoint::CREATE
[LivenessAnalysisPass] Applying call interval fix to block ColorPoint::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getY_Exit_1 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::getY_Entry_0 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::RELEASE_Exit_1 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::RELEASE_Entry_0 in function: Point::RELEASE
[LivenessAnalysisPass] Applying call interval fix to block Point::RELEASE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getX_Exit_1 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::getX_Entry_0 in function: Point::getX
[LivenessAnalysisPass] Processing block: ColorPoint::getColor_Exit_1 in function: ColorPoint::getColor
[LivenessAnalysisPass] Processing block: ColorPoint::getColor_Entry_0 in function: ColorPoint::getColor
[LivenessAnalysisPass] Processing block: Point::set_Exit_1 in function: Point::set
[LivenessAnalysisPass] Processing block: Point::set_Entry_0 in function: Point::set
[LivenessAnalysisPass] Processing block: makePoint_Exit_2 in function: makePoint
[LivenessAnalysisPass] Processing block: makePoint_Entry_0 in function: makePoint
[LivenessAnalysisPass] Applying call interval fix to block makePoint_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::CREATE_Exit_1 in function: Point::CREATE
[LivenessAnalysisPass] Processing block: Point::CREATE_Entry_0 in function: Point::CREATE
[LivenessAnalysisPass] Applying call interval fix to block Point::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { }
  Def: { cp p }
  In : { }
  Out: { }

Liveness Analysis for function: ColorPoint::setColor
-------------------------------------------
Block ID: ColorPoint::setColor_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: ColorPoint::setColor_Entry_0
  Use: { c }
  Def: { }
  In : { c }
  Out: { }

Liveness Analysis for function: ColorPoint::CREATE
-------------------------------------------
Block ID: ColorPoint::CREATE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: ColorPoint::CREATE_Entry_0
  Use: { initialColor initialX initialY }
  Def: { color }
  In : { initialColor initialX initialY }
  Out: { }

Liveness Analysis for function: Point::getY
-------------------------------------------
Block ID: Point::getY_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::getY_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::RELEASE
-------------------------------------------
Block ID: Point::RELEASE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::RELEASE_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::getX
-------------------------------------------
Block ID: Point::getX_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::getX_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: ColorPoint::getColor
-------------------------------------------
Block ID: ColorPoint::getColor_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: ColorPoint::getColor_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::set
-------------------------------------------
Block ID: Point::set_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::set_Entry_0
  Use: { newX newY }
  Def: { x y }
  In : { newX newY }
  Out: { }

Liveness Analysis for function: makePoint
-------------------------------------------
Block ID: makePoint_Exit_2
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: makePoint_Entry_0
  Use: { }
  Def: { p }
  In : { }
  Out: { }

Liveness Analysis for function: Point::CREATE
-------------------------------------------
Block ID: Point::CREATE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::CREATE_Entry_0
  Use: { initialX initialY }
  Def: { x y }
  In : { initialX initialY }
  Out: { }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_1 (conceptual)

Block ID: START_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: ColorPoint::setColor
----------------------------------------
Entry Block: ColorPoint::setColor_Entry_0
Exit Block: ColorPoint::setColor_Exit_1 (conceptual)

Block ID: ColorPoint::setColor_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: ColorPoint::setColor_Entry_0

Block ID: ColorPoint::setColor_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
  Successors: ColorPoint::setColor_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: ColorPoint::CREATE
----------------------------------------
Entry Block: ColorPoint::CREATE_Entry_0
Exit Block: ColorPoint::CREATE_Exit_1 (conceptual)

Block ID: ColorPoint::CREATE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: ColorPoint::CREATE_Entry_0

Block ID: ColorPoint::CREATE_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: ColorPoint::CREATE_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::getY
----------------------------------------
Entry Block: Point::getY_Entry_0
Exit Block: Point::getY_Exit_1 (conceptual)

Block ID: Point::getY_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::getY_Entry_0

Block ID: Point::getY_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: Point::getY_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::RELEASE
----------------------------------------
Entry Block: Point::RELEASE_Entry_0
Exit Block: Point::RELEASE_Exit_1 (conceptual)

Block ID: Point::RELEASE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::RELEASE_Entry_0

Block ID: Point::RELEASE_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
  Successors: Point::RELEASE_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::getX
----------------------------------------
Entry Block: Point::getX_Entry_0
Exit Block: Point::getX_Exit_1 (conceptual)

Block ID: Point::getX_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::getX_Entry_0

Block ID: Point::getX_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: Point::getX_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: ColorPoint::getColor
----------------------------------------
Entry Block: ColorPoint::getColor_Entry_0
Exit Block: ColorPoint::getColor_Exit_1 (conceptual)

Block ID: ColorPoint::getColor_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: ColorPoint::getColor_Entry_0

Block ID: ColorPoint::getColor_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: ColorPoint::getColor_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::set
----------------------------------------
Entry Block: Point::set_Entry_0
Exit Block: Point::set_Exit_1 (conceptual)

Block ID: Point::set_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::set_Entry_0

Block ID: Point::set_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - AssignmentStmt
  Successors: Point::set_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: makePoint
----------------------------------------
Entry Block: makePoint_Entry_0
Exit Block: makePoint_Exit_2 (conceptual)

Block ID: makePoint_Exit_2 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: makePoint_Entry_0

Block ID: makePoint_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
  Successors: makePoint_Exit_2
  Predecessors: (none)
----------------------------------------

CFG for function: Point::CREATE
----------------------------------------
Entry Block: Point::CREATE_Entry_0
Exit Block: Point::CREATE_Exit_1 (conceptual)

Block ID: Point::CREATE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::CREATE_Entry_0

Block ID: Point::CREATE_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: Point::CREATE_Exit_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
        RoutineDeclaration: RELEASE
          Parameters: _this 
          Body:
            BlockStatement:
              Statements:
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point destroyed
"
    ClassDeclaration: ColorPoint
      Extends: Point
      Members:
        LetDeclaration:
          Name: color
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY initialColor 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: color
                  RHS:
                    VariableAccess: initialColor
                RoutineCallStatement:
                  Callee:
                    SuperMethodAccess: CREATE
                  Arguments:
                    VariableAccess: initialX
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "ColorPoint created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ") with color "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: color
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "
"
        RoutineDeclaration: setColor
          Parameters: _this c 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    MemberAccess: color
                      Object:
                        VariableAccess: _this
                    RHS:
                      VariableAccess: c
          FunctionDeclaration: getColor
            Parameters: _this 
            Body:
              ValofExpression:
                BlockStatement:
                  Statements:
                    ResultisStatement:
                      VariableAccess: color
      FunctionDeclaration: makePoint
        Body:
          ValofExpression:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: p
                  RHS:
                    NewExpression: Point
                      Arguments:
                        NumberLiteral: 50
                        NumberLiteral: 75
                ResultisStatement:
                  VariableAccess: p
      RoutineDeclaration: START
        Body:
          BlockStatement:
            Statements:
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Testing class member variable access with correct offsets
"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "=================================================

"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "1. Basic Point class test:
"
              AssignmentStatement:
                LHS:
                  VariableAccess: p
                RHS:
                  FunctionCall:
                    Callee:
                      VariableAccess: makePoint
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Reading values: x="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getX
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", y="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    FunctionCall:
                      Callee:
                        MemberAccess: getY
                          Object:
                            VariableAccess: p
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "
"
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Setting new values...
"
                  RoutineCallStatement:
                    Callee:
                      MemberAccess: set
                        Object:
                          VariableAccess: p
                      Arguments:
                        NumberLiteral: 100
                        NumberLiteral: 200
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "Reading new values: x="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getX
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: ", y="
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITEN
                        Arguments:
                          FunctionCall:
                            Callee:
                              MemberAccess: getY
                                Object:
                                  VariableAccess: p
                        RoutineCallStatement:
                          Callee:
                            VariableAccess: WRITES
                          Arguments:
                            StringLiteral: "

"
                        RoutineCallStatement:
                          Callee:
                            VariableAccess: WRITES
                          Arguments:
                            StringLiteral: "2. Inherited ColorPoint class test:
"
                        AssignmentStatement:
                          LHS:
                            VariableAccess: cp
                          RHS:
                            NewExpression: ColorPoint
                        RoutineCallStatement:
                          Callee:
                            MemberAccess: CREATE
                              Object:
                                VariableAccess: cp
                            Arguments:
                              NumberLiteral: 130
                              NumberLiteral: 140
                              NumberLiteral: 255
                          RoutineCallStatement:
                            Callee:
                              VariableAccess: WRITES
                            Arguments:
                              StringLiteral: "Reading values: x="
                          RoutineCallStatement:
                            Callee:
                              VariableAccess: WRITEN
                            Arguments:
                              FunctionCall:
                                Callee:
                                  MemberAccess: getX
                                    Object:
                                      VariableAccess: cp
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: ", y="
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITEN
                              Arguments:
                                FunctionCall:
                                  Callee:
                                    MemberAccess: getY
                                      Object:
                                        VariableAccess: cp
                              RoutineCallStatement:
                                Callee:
                                  VariableAccess: WRITES
                                Arguments:
                                  StringLiteral: ", color="
                              RoutineCallStatement:
                                Callee:
                                  VariableAccess: WRITEN
                                Arguments:
                                  FunctionCall:
                                    Callee:
                                      MemberAccess: getColor
                                        Object:
                                          VariableAccess: cp
                                RoutineCallStatement:
                                  Callee:
                                    VariableAccess: WRITES
                                  Arguments:
                                    StringLiteral: "
"
                                RoutineCallStatement:
                                  Callee:
                                    VariableAccess: WRITES
                                  Arguments:
                                    StringLiteral: "Setting new values...
"
                                RoutineCallStatement:
                                  Callee:
                                    MemberAccess: set
                                      Object:
                                        VariableAccess: cp
                                    Arguments:
                                      NumberLiteral: 60
                                      NumberLiteral: 80
                                  RoutineCallStatement:
                                    Callee:
                                      MemberAccess: setColor
                                        Object:
                                          VariableAccess: cp
                                      Arguments:
                                        NumberLiteral: 123
                                    RoutineCallStatement:
                                      Callee:
                                        VariableAccess: WRITES
                                      Arguments:
                                        StringLiteral: "Reading new values: x="
                                    RoutineCallStatement:
                                      Callee:
                                        VariableAccess: WRITEN
                                      Arguments:
                                        FunctionCall:
                                          Callee:
                                            MemberAccess: getX
                                              Object:
                                                VariableAccess: cp
                                      RoutineCallStatement:
                                        Callee:
                                          VariableAccess: WRITES
                                        Arguments:
                                          StringLiteral: ", y="
                                      RoutineCallStatement:
                                        Callee:
                                          VariableAccess: WRITEN
                                        Arguments:
                                          FunctionCall:
                                            Callee:
                                              MemberAccess: getY
                                                Object:
                                                  VariableAccess: cp
                                        RoutineCallStatement:
                                          Callee:
                                            VariableAccess: WRITES
                                          Arguments:
                                            StringLiteral: ", color="
                                        RoutineCallStatement:
                                          Callee:
                                            VariableAccess: WRITEN
                                          Arguments:
                                            FunctionCall:
                                              Callee:
                                                MemberAccess: getColor
                                                  Object:
                                                    VariableAccess: cp
                                          RoutineCallStatement:
                                            Callee:
                                              VariableAccess: WRITES
                                            Arguments:
                                              StringLiteral: "
"
                                          RoutineCallStatement:
                                            Callee:
                                              VariableAccess: WRITES
                                            Arguments:
                                              StringLiteral: "
Test completed successfully
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[LiveIntervalPass] Created 2 intervals for function: START
  p: [4-15]
  cp: [18-35]
[LiveIntervalPass] Building intervals for function: ColorPoint::setColor
[LiveIntervalPass] Created 2 intervals for function: ColorPoint::setColor
  _this: [0-0]
  c: [0-0]
[LiveIntervalPass] Building intervals for function: ColorPoint::CREATE
[LiveIntervalPass] Injected _this interval for class method: ColorPoint::CREATE [0-11]
[LiveIntervalPass] Created 4 intervals for function: ColorPoint::CREATE
  _this: [0-11]
  initialColor: [0-0]
  initialX: [0-1]
  initialY: [0-1]
[LiveIntervalPass] Building intervals for function: Point::getY
[LiveIntervalPass] Injected _this interval for class method: Point::getY [0-3]
[LiveIntervalPass] Created 1 intervals for function: Point::getY
  _this: [0-3]
[LiveIntervalPass] Building intervals for function: Point::RELEASE
[LiveIntervalPass] Injected _this interval for class method: Point::RELEASE [0-3]
[LiveIntervalPass] Created 1 intervals for function: Point::RELEASE
  _this: [0-3]
[LiveIntervalPass] Building intervals for function: Point::getX
[LiveIntervalPass] Injected _this interval for class method: Point::getX [0-3]
[LiveIntervalPass] Created 1 intervals for function: Point::getX
  _this: [0-3]
[LiveIntervalPass] Building intervals for function: ColorPoint::getColor
[LiveIntervalPass] Injected _this interval for class method: ColorPoint::getColor [0-3]
[LiveIntervalPass] Created 1 intervals for function: ColorPoint::getColor
  _this: [0-3]
[LiveIntervalPass] Building intervals for function: Point::set
[LiveIntervalPass] Injected _this interval for class method: Point::set [0-4]
[LiveIntervalPass] Created 3 intervals for function: Point::set
  _this: [0-4]
  newX: [0-0]
  newY: [0-1]
[LiveIntervalPass] Building intervals for function: makePoint
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[LiveIntervalPass] Created 1 intervals for function: makePoint
  p: [1-1]
[LiveIntervalPass] Building intervals for function: Point::CREATE
[LiveIntervalPass] Injected _this interval for class method: Point::CREATE [0-9]
[LiveIntervalPass] Created 3 intervals for function: Point::CREATE
  _this: [0-9]
  initialX: [0-0]
  initialY: [0-1]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 44 call sites at: 0 4 8 12 15 19 20 26 30 31 37 41 49 53 54 60 64 65 71 75 84 88 89 95 99 100 106 110 111 117 121 132 136 137 143 147 148 154 158 159 165 169 173 174 
[Allocator] Partitioned: 2 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing p [4-15]
  Assigned callee-saved register X27 to p
[ALLOC] Updated allocations for p: spilled=0, register='X27'
[Allocator] Allocating call-crossing cp [18-35]
  Expiring interval for p, freeing register X27
  Assigned callee-saved register X27 to cp
[ALLOC] Updated allocations for cp: spilled=0, register='X27'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  cp: reg X27 (callee-saved) [call-crossing]
  p: reg X27 (callee-saved) [call-crossing]
[Allocator] Starting partitioned linear scan for function: ColorPoint::setColor
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 2 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-0]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Allocating local-only c [0-0]
  Assigned register X14 to c
[ALLOC] Updated allocations for c: spilled=0, register='X14'
[Allocator] Partitioned allocation complete for ColorPoint::setColor
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 2
  Free integer registers: 11
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
  c: reg X14 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: ColorPoint::CREATE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 7 call sites at: 4 8 12 16 20 24 28 
[Allocator] Partitioned: 1 call-crossing, 3 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-11]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only initialColor [0-0]
  Assigned register X15 to initialColor
[ALLOC] Updated allocations for initialColor: spilled=0, register='X15'
[Allocator] Allocating local-only initialX [0-1]
  Assigned register X14 to initialX
[ALLOC] Updated allocations for initialX: spilled=0, register='X14'
[Allocator] Allocating local-only initialY [0-1]
  Assigned register X13 to initialY
[ALLOC] Updated allocations for initialY: spilled=0, register='X13'
[Allocator] Partitioned allocation complete for ColorPoint::CREATE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 4
  Free integer registers: 9
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
  initialColor: reg X15 (caller-saved) [local-only]
  initialX: reg X14 (caller-saved) [local-only]
  initialY: reg X13 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::getY
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for Point::getY
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::RELEASE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 1 call sites at: 0 
[Allocator] Partitioned: 1 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-3]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for Point::RELEASE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
[Allocator] Starting partitioned linear scan for function: Point::getX
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for Point::getX
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: ColorPoint::getColor
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for ColorPoint::getColor
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::set
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 3 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-4]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Allocating local-only newX [0-0]
  Assigned register X14 to newX
[ALLOC] Updated allocations for newX: spilled=0, register='X14'
[Allocator] Allocating local-only newY [0-1]
  Assigned register X13 to newY
[ALLOC] Updated allocations for newY: spilled=0, register='X13'
[Allocator] Partitioned allocation complete for Point::set
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
  newX: reg X14 (caller-saved) [local-only]
  newY: reg X13 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: makePoint
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 1 call sites at: 0 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only p [1-1]
  Assigned register X15 to p
[ALLOC] Updated allocations for p: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for makePoint
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  p: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::CREATE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 4 8 12 16 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-9]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Allocating call-crossing initialX [0-0]
  Assigned callee-saved register X26 to initialX
[ALLOC] Updated allocations for initialX: spilled=0, register='X26'
[Allocator] Allocating call-crossing initialY [0-1]
  Assigned callee-saved register X25 to initialY
[ALLOC] Updated allocations for initialY: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for Point::CREATE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
  initialX: reg X26 (callee-saved) [call-crossing]
  initialY: reg X25 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: ColorPoint::CREATE
  Type: int
  Parameters: 4
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 7
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 3
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: ColorPoint::getColor
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: ColorPoint::setColor
  Type: int
  Parameters: 2
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 1
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::CREATE
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 2
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::RELEASE
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 1
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getX
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getY
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::set
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 2
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 3
  Float Locals: 0
  Runtime Calls: 31
  Local Function Calls: 1
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: makePoint
  Type: int
  Parameters: 0
  Integer Locals: 2
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4319051776
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 2 unique external functions:
[DEBUG]   - WRITEN
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] CRITICAL: Adding essential HeapManager function: HeapManager_enter_scope
[VeneerManager] CRITICAL: Adding essential HeapManager function: HeapManager_exit_scope
[VeneerManager] Generating 4 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITEN_veneer for function: WRITEN
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 4 veneers, estimated total size: 80 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Visiting ClassDeclaration for 'Point'. Setting class context.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: CREATE).
[DEBUG] Using qualified name for method: Point::CREATE
[DEBUG] Name 'Point::CREATE' is already qualified. Using unqualified part 'CREATE' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::CREATE
[DEBUG] DEBUG: generate_function_like_code called for: Point::CREATE
[DEBUG] Generating function-like code for: Point::CREATE
[DEBUG] Clearing local value tracking for function: Point::CREATE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: CREATE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: CREATE
[DEBUG] Using name as-is for lookup: Point::CREATE
[DEBUG] Generating code for method. Using mangled label from symbol: Point::CREATE
Call Frame Layout for function: Point::CREATE
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::CREATE')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::CREATE'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::CREATE': 3
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['initialX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['initialY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialX' type from metrics: UNKNOWN
Added local variable 'initialX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialY' type from metrics: UNKNOWN
Added local variable 'initialY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::CREATE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::CREATE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::CREATE'.
--- Call Frame Layout for function: Point::CREATE (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X25                        | UNKNOWN
+64      | Saved Reg: X26                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #56] ; Saved Reg: X25 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #64] ; Saved Reg: X26 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG]   Moving 'initialX' from arg reg X1 to home reg X26.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X1    // Move parameter 'initialX' from X1 to X26
[DEBUG]   Moving 'initialY' from arg reg X2 to home reg X25.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X2    // Move parameter 'initialY' from X2 to X25
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::CREATE (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X25                        | UNKNOWN
+64      | Saved Reg: X26                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'ColorPoint::setColor'
[DEBUG]   Available CFG: 'ColorPoint::CREATE'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'ColorPoint::getColor'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'makePoint'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::CREATE
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialX' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'initialX' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialX' lives in register X26
[DEBUG] Variable 'initialX' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Registering canonical address: x = VARIABLE:initialX
[DEBUG] Registered canonical address: x = VARIABLE:initialX
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: x
[DEBUG] Handling assignment for class member: x
[DEBUG] Member variable 'x' found in class 'Point' with offset 8
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X27, #8] ; Store to member x
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialY' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'initialY' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialY' lives in register X25
[DEBUG] Variable 'initialY' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] Registering canonical address: y = VARIABLE:initialY
[DEBUG] Registered canonical address: y = VARIABLE:initialY
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: y
[DEBUG] Handling assignment for class member: y
[DEBUG] Member variable 'y' found in class 'Point' with offset 16
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X27, #16] ; Store to member y
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Point created at ('.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'x' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'y' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ')
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B Point::CREATE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L0
[DEBUG] Performing end-of-function scope cleanup for 'Point::CREATE'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'Point::CREATE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getX).
[DEBUG] Function metrics for getX not found.
[DEBUG] Using qualified name for method: Point::getX
[DEBUG] Name 'Point::getX' is already qualified. Using unqualified part 'getX' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::getX
[DEBUG] DEBUG: generate_function_like_code called for: Point::getX
[DEBUG] Generating function-like code for: Point::getX
[DEBUG] Clearing local value tracking for function: Point::getX
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getX
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getX
[DEBUG] Using name as-is for lookup: Point::getX
[DEBUG] Generating code for method. Using mangled label from symbol: Point::getX
[DEBUG] ✅ Detected TRIVIAL ACCESSOR method: 'Point::getX'. Generating optimized code.
[DEBUG LEVEL 5] Emitting instruction: LDR X0, [X0, #8] ; Optimized accessor load (int/ptr)
[DEBUG LEVEL 5] Emitting instruction: RET
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getY).
[DEBUG] Function metrics for getY not found.
[DEBUG] Using qualified name for method: Point::getY
[DEBUG] Name 'Point::getY' is already qualified. Using unqualified part 'getY' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::getY
[DEBUG] DEBUG: generate_function_like_code called for: Point::getY
[DEBUG] Generating function-like code for: Point::getY
[DEBUG] Clearing local value tracking for function: Point::getY
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getY
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getY
[DEBUG] Using name as-is for lookup: Point::getY
[DEBUG] Generating code for method. Using mangled label from symbol: Point::getY
[DEBUG] ✅ Detected TRIVIAL ACCESSOR method: 'Point::getY'. Generating optimized code.
[DEBUG LEVEL 5] Emitting instruction: LDR X0, [X0, #16] ; Optimized accessor load (int/ptr)
[DEBUG LEVEL 5] Emitting instruction: RET
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: set).
[DEBUG] Using qualified name for method: Point::set
[DEBUG] Name 'Point::set' is already qualified. Using unqualified part 'set' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::set
[DEBUG] DEBUG: generate_function_like_code called for: Point::set
[DEBUG] Generating function-like code for: Point::set
[DEBUG] Clearing local value tracking for function: Point::set
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: set
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: set
[DEBUG] Using name as-is for lookup: Point::set
[DEBUG] Generating code for method. Using mangled label from symbol: Point::set
Call Frame Layout for function: Point::set
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::set')
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::set')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::set'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::set': 3
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['newX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['newY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'newX' type from metrics: UNKNOWN
Added local variable 'newX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'newX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'newY' type from metrics: UNKNOWN
Added local variable 'newY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'newY' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::set'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'newX' to CallFrameManager locals.
[DEBUG] Added parameter 'newY' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::set'.
[DEBUG] No spills needed - all variables fit in registers.
Added X28 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::set'.
--- Call Frame Layout for function: Point::set (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: newX                           | UNKNOWN
+32      | Local: newY                           | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-64]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #56] ; Saved Reg: X28 @ FP+56
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X15.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0    // Move parameter '_this' from X0 to X15
[DEBUG]   Moving 'newX' from arg reg X1 to home reg X14.
[DEBUG LEVEL 5] Emitting instruction: MOV X14, X1    // Move parameter 'newX' from X1 to X14
[DEBUG]   Moving 'newY' from arg reg X2 to home reg X13.
[DEBUG LEVEL 5] Emitting instruction: MOV X13, X2    // Move parameter 'newY' from X2 to X13
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::set (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: newX                           | UNKNOWN
+32      | Local: newY                           | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'ColorPoint::setColor'
[DEBUG]   Available CFG: 'ColorPoint::CREATE'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'ColorPoint::getColor'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'makePoint'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::set
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'newX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'newX' in function 'Point::set'
[DEBUG] get_variable_register for: 'newX' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'newX' lives in register X14
[DEBUG] Variable 'newX' value loaded into X14
[DEBUG]   [DEBUG] get_variable_register returned: 'X14'
[DEBUG] Registering canonical address: x = VARIABLE:newX
[DEBUG] Registered canonical address: x = VARIABLE:newX
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: x
[DEBUG] Handling assignment for class member: x
[DEBUG] Member variable 'x' found in class 'Point' with offset 8
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X15
[DEBUG LEVEL 5] Emitting instruction: STR X14, [X15, #8] ; Store to member x
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'newY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'newY' in function 'Point::set'
[DEBUG] get_variable_register for: 'newY' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'newY' lives in register X13
[DEBUG] Variable 'newY' value loaded into X13
[DEBUG]   [DEBUG] get_variable_register returned: 'X13'
[DEBUG] Registering canonical address: y = VARIABLE:newY
[DEBUG] Registered canonical address: y = VARIABLE:newY
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: y
[DEBUG] Handling assignment for class member: y
[DEBUG] Member variable 'y' found in class 'Point' with offset 16
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X15
[DEBUG LEVEL 5] Emitting instruction: STR X13, [X15, #16] ; Store to member y
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B Point::set_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L3
[DEBUG] Performing end-of-function scope cleanup for 'Point::set'.
[DEBUG] Defining epilogue label: .L3
[DEBUG] Attempting to generate epilogue for 'Point::set'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: RELEASE).
[DEBUG] Using qualified name for method: Point::RELEASE
[DEBUG] Name 'Point::RELEASE' is already qualified. Using unqualified part 'RELEASE' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::RELEASE
[DEBUG] DEBUG: generate_function_like_code called for: Point::RELEASE
[DEBUG] Generating function-like code for: Point::RELEASE
[DEBUG] Clearing local value tracking for function: Point::RELEASE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: RELEASE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: RELEASE
[DEBUG] Using name as-is for lookup: Point::RELEASE
[DEBUG] Generating code for method. Using mangled label from symbol: Point::RELEASE
Call Frame Layout for function: Point::RELEASE
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::RELEASE'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::RELEASE': 1
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::RELEASE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::RELEASE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::RELEASE'.
--- Call Frame Layout for function: Point::RELEASE (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X27                        | UNKNOWN
+40      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #32] ; Saved Reg: X27 @ FP+32
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #40] ; Saved Reg: X28 @ FP+40
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::RELEASE (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X27                        | UNKNOWN
+40      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'ColorPoint::setColor'
[DEBUG]   Available CFG: 'ColorPoint::CREATE'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'ColorPoint::getColor'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'makePoint'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::RELEASE
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Point destroyed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B Point::RELEASE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L4
[DEBUG] Performing end-of-function scope cleanup for 'Point::RELEASE'.
[DEBUG] Defining epilogue label: .L4
[DEBUG] Attempting to generate epilogue for 'Point::RELEASE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Finished with ClassDeclaration for 'Point'. Restoring context.
[DEBUG] Visiting ClassDeclaration for 'ColorPoint'. Setting class context.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: CREATE).
[DEBUG] Using qualified name for method: ColorPoint::CREATE
[DEBUG] Name 'ColorPoint::CREATE' is already qualified. Using unqualified part 'CREATE' for scope.
[DEBUG] Using name as-is for metrics lookup: ColorPoint::CREATE
[DEBUG] DEBUG: generate_function_like_code called for: ColorPoint::CREATE
[DEBUG] Generating function-like code for: ColorPoint::CREATE
[DEBUG] Clearing local value tracking for function: ColorPoint::CREATE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: CREATE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: CREATE
[DEBUG] Using name as-is for lookup: ColorPoint::CREATE
[DEBUG] Generating code for method. Using mangled label from symbol: ColorPoint::CREATE
Call Frame Layout for function: ColorPoint::CREATE
[SYMBOL TABLE TRACE] Warning: Found symbol 'color' in different context 'ColorPoint' (requested context was 'ColorPoint::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'ColorPoint::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'ColorPoint::CREATE')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'ColorPoint::CREATE'.
[DEBUG] DEBUG: metrics.variable_types size for 'ColorPoint::CREATE': 4
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['initialColor'] = UNKNOWN
[DEBUG] DEBUG: variable_types['initialX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['initialY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialX' type from metrics: UNKNOWN
Added local variable 'initialX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialY' type from metrics: UNKNOWN
Added local variable 'initialY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialColor' type from metrics: UNKNOWN
Added local variable 'initialColor' of type 0 at offset 40 (size 8)
[DEBUG] Added parameter 'initialColor' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'ColorPoint::CREATE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] Added parameter 'initialColor' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'ColorPoint::CREATE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'ColorPoint::CREATE'.
--- Call Frame Layout for function: ColorPoint::CREATE (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Local: initialColor                   | UNKNOWN
+48      | Saved Reg: X19                        | UNKNOWN
+56      | Saved Reg: X20                        | UNKNOWN
+64      | Saved Reg: X21                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #48] ; Saved Reg: X19 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #56] ; Saved Reg: X20 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #64] ; Saved Reg: X21 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG]   Moving 'initialX' from arg reg X1 to home reg X14.
[DEBUG LEVEL 5] Emitting instruction: MOV X14, X1    // Move parameter 'initialX' from X1 to X14
[DEBUG]   Moving 'initialY' from arg reg X2 to home reg X13.
[DEBUG LEVEL 5] Emitting instruction: MOV X13, X2    // Move parameter 'initialY' from X2 to X13
[DEBUG]   Moving 'initialColor' from arg reg X3 to home reg X15.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X3    // Move parameter 'initialColor' from X3 to X15
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: ColorPoint::CREATE (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Local: initialColor                   | UNKNOWN
+48      | Saved Reg: X19                        | UNKNOWN
+56      | Saved Reg: X20                        | UNKNOWN
+64      | Saved Reg: X21                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'ColorPoint::setColor'
[DEBUG]   Available CFG: 'ColorPoint::CREATE'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'ColorPoint::getColor'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'makePoint'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: ColorPoint::CREATE
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialColor'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialColor' in function 'ColorPoint::CREATE'
[DEBUG] get_variable_register for: 'initialColor' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialColor' lives in register X15
[DEBUG] Variable 'initialColor' value loaded into X15
[DEBUG]   [DEBUG] get_variable_register returned: 'X15'
[DEBUG] Registering canonical address: color = VARIABLE:initialColor
[DEBUG] Registered canonical address: color = VARIABLE:initialColor
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: color
[DEBUG] Handling assignment for class member: color
[DEBUG] Member variable 'color' found in class 'ColorPoint' with offset 24
[DEBUG] get_variable_register for: '_this' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X15, [X27, #24] ; Store to member color
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a SUPER method call.
[DEBUG] Visiting VariableAccess node for 'initialX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialX' in function 'ColorPoint::CREATE'
[DEBUG] get_variable_register for: 'initialX' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialX' lives in register X14
[DEBUG] Variable 'initialX' value loaded into X14
[DEBUG]   [DEBUG] get_variable_register returned: 'X14'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X14
[DEBUG] Visiting VariableAccess node for 'initialY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialY' in function 'ColorPoint::CREATE'
[DEBUG] get_variable_register for: 'initialY' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialY' lives in register X13
[DEBUG] Variable 'initialY' value loaded into X13
[DEBUG]   [DEBUG] get_variable_register returned: 'X13'
[DEBUG LEVEL 5] Emitting instruction: MOV X21, X13
[DEBUG] get_variable_register for: '_this' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X21
[DEBUG LEVEL 5] Emitting instruction: BL Point::CREATE
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'ColorPoint created at ('.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'ColorPoint::CREATE'
[DEBUG] get_variable_register for: 'x' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'ColorPoint::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'ColorPoint::CREATE'
[DEBUG] get_variable_register for: 'y' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'ColorPoint::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str5
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str5
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ') with color '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'color'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'color' in function 'ColorPoint::CREATE'
[DEBUG] get_variable_register for: 'color' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'color' in different context 'ColorPoint' (requested context was 'ColorPoint::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'color' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'ColorPoint::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 24 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #24] ; color
[DEBUG] Generated LDR for class member color at offset 24
[DEBUG] Variable 'color' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B ColorPoint::CREATE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L5
[DEBUG] Performing end-of-function scope cleanup for 'ColorPoint::CREATE'.
[DEBUG] Defining epilogue label: .L5
[DEBUG] Attempting to generate epilogue for 'ColorPoint::CREATE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: setColor).
[DEBUG] Using qualified name for method: ColorPoint::setColor
[DEBUG] Name 'ColorPoint::setColor' is already qualified. Using unqualified part 'setColor' for scope.
[DEBUG] Using name as-is for metrics lookup: ColorPoint::setColor
[DEBUG] DEBUG: generate_function_like_code called for: ColorPoint::setColor
[DEBUG] Generating function-like code for: ColorPoint::setColor
[DEBUG] Clearing local value tracking for function: ColorPoint::setColor
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: setColor
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: setColor
[DEBUG] Using name as-is for lookup: ColorPoint::setColor
[DEBUG] Generating code for method. Using mangled label from symbol: ColorPoint::setColor
[DEBUG] ✅ Detected TRIVIAL SETTER method: 'ColorPoint::setColor'. Generating optimized code.
[DEBUG LEVEL 5] Emitting instruction: STR X1, [X0, #24] ; Optimized setter store
[DEBUG LEVEL 5] Emitting instruction: RET
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getColor).
[DEBUG] Function metrics for getColor not found.
[DEBUG] Using qualified name for method: ColorPoint::getColor
[DEBUG] Name 'ColorPoint::getColor' is already qualified. Using unqualified part 'getColor' for scope.
[DEBUG] Using name as-is for metrics lookup: ColorPoint::getColor
[DEBUG] DEBUG: generate_function_like_code called for: ColorPoint::getColor
[DEBUG] Generating function-like code for: ColorPoint::getColor
[DEBUG] Clearing local value tracking for function: ColorPoint::getColor
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getColor
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getColor
[DEBUG] Using name as-is for lookup: ColorPoint::getColor
[DEBUG] Generating code for method. Using mangled label from symbol: ColorPoint::getColor
[DEBUG] ✅ Detected TRIVIAL ACCESSOR method: 'ColorPoint::getColor'. Generating optimized code.
[DEBUG LEVEL 5] Emitting instruction: LDR X0, [X0, #24] ; Optimized accessor load (int/ptr)
[DEBUG LEVEL 5] Emitting instruction: RET
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] Finished with ClassDeclaration for 'ColorPoint'. Restoring context.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] Visiting FunctionDeclaration node (Name: makePoint).
[DEBUG] Function metrics for makePoint: runtime_calls=0, local_function_calls=0, local_routine_calls=0
[DEBUG] Using name as-is for metrics lookup: makePoint
[DEBUG] DEBUG: generate_function_like_code called for: makePoint
[DEBUG] Generating function-like code for: makePoint
[DEBUG] Clearing local value tracking for function: makePoint
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: makePoint
[SYNC] Found 1 variable allocations
[SYNC] Reserved register X15 for variable p
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: makePoint
[DEBUG] Using name as-is for lookup: makePoint
Call Frame Layout for function: makePoint
[DEBUG] Registering all parameters as locals in CallFrameManager for 'makePoint'.
[DEBUG] DEBUG: metrics.variable_types size for 'makePoint': 1
[DEBUG] DEBUG: variable_types['p'] = POINTER_TO|OBJECT
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'makePoint'.
Added local variable 'p' of type 1056768 at offset 16 (size 8)
[DEBUG] Registered local 'p' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'makePoint'.
[DEBUG] No spills needed - all variables fit in registers.
[DEBUG] Attempting to generate prologue for 'makePoint'.
--- Call Frame Layout for function: makePoint (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: p                              | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: makePoint (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: p                              | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'ColorPoint::setColor'
[DEBUG]   Available CFG: 'ColorPoint::CREATE'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'ColorPoint::getColor'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'makePoint'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: makePoint
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting NewExpression node for class: Point
[DEBUG]   - Constructor arguments count: 2
[DEBUG]   - Assigned variable name: [empty]
[DEBUG LEVEL 5] Emitting instruction: BL OBJECT_HEAP_ALLOC
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X0
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, Point_vtable
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:Point_vtable
[DEBUG LEVEL 5] Emitting instruction: STR X9, [X20, #0] ; store vtable ptr
[DEBUG] Handling assignment for variable: p
[DEBUG] store_variable_register for 'p' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'p' lives in X15. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X20
[DEBUG]   Updating home register X15 for variable 'p' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B makePoint_Exit_2
[DEBUG LEVEL 5] Emitting instruction: B .L8
[DEBUG] Performing end-of-function scope cleanup for 'makePoint'.
[DEBUG] Defining epilogue label: .L8
[DEBUG] Attempting to generate epilogue for 'makePoint'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: START
[SYNC] Found 2 variable allocations
[SYNC] Reserved register X27 for variable cp
[SYNC] Reserved register X27 for variable p
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[SYMBOL TABLE TRACE] Warning: Found symbol 'makePoint' in different context 'makePoint' (requested context was 'START')
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 2
[DEBUG] DEBUG: variable_types['cp'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['p'] = POINTER_TO|OBJECT
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'cp' of type 1056768 at offset 16 (size 8)
[DEBUG] Registered local 'cp' from analyzer metrics.
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
Added local variable 'p' of type 1056768 at offset 24 (size 8)
[DEBUG] Registered local 'p' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: cp                             | POINTER_TO|OBJECT
+24      | Local: p                              | POINTER_TO|OBJECT
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X27                        | UNKNOWN
+48      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-64]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #40] ; Saved Reg: X27 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #48] ; Saved Reg: X28 @ FP+48
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: cp                             | POINTER_TO|OBJECT
+24      | Local: p                              | POINTER_TO|OBJECT
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X27                        | UNKNOWN
+48      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'ColorPoint::setColor'
[DEBUG]   Available CFG: 'ColorPoint::CREATE'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'ColorPoint::getColor'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'makePoint'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str7
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str7
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Testing class member variable access with correct offsets
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str8
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str8
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '=================================================

'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str9
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str9
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '1. Basic Point class test:
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Found function symbol: makePoint with 0 parameters
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL makePoint
[DEBUG] Handling assignment for variable: p
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG] store_variable_register for 'p' from register 'X0'
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG]   [ALLOCATOR HIT] Variable 'p' lives in X27. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG]   Updating home register X27 for variable 'p' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X27
[DEBUG] Variable 'p' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #16] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X27
[DEBUG] Variable 'p' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #24] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str12
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str12
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Setting new values...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a method call to: set
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #100
[DEBUG] Loaded integer literal 100 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #200
[DEBUG] Loaded integer literal 200 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X21, X9
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X27
[DEBUG] Variable 'p' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X21
[DEBUG LEVEL 5] Emitting instruction: BL Point::set
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str13
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str13
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading new values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X27
[DEBUG] Variable 'p' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #16] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'p' in different context 'makePoint' (requested context was 'START')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X27
[DEBUG] Variable 'p' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #24] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str14
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str14
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '

'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str15
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str15
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '2. Inherited ColorPoint class test:
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting NewExpression node for class: ColorPoint
[DEBUG]   - Constructor arguments count: 0
[DEBUG]   - Assigned variable name: [empty]
[DEBUG LEVEL 5] Emitting instruction: BL OBJECT_HEAP_ALLOC
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X0
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, ColorPoint_vtable
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:ColorPoint_vtable
[DEBUG LEVEL 5] Emitting instruction: STR X9, [X20, #0] ; store vtable ptr
[DEBUG] Handling assignment for variable: cp
[DEBUG] store_variable_register for 'cp' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'cp' lives in X27. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X20
[DEBUG]   Updating home register X27 for variable 'cp' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a method call to: CREATE
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #130
[DEBUG] Loaded integer literal 130 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #140
[DEBUG] Loaded integer literal 140 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X21, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #255
[DEBUG] Loaded integer literal 255 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X22, X9
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X21
[DEBUG LEVEL 5] Emitting instruction: MOV X3, X22
[DEBUG] Detected a direct constructor call. Performing non-virtual call.
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: BL ColorPoint::CREATE
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #16] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'ColorPoint::getX'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #24] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'ColorPoint::getY'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str16
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str16
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', color='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #48] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str12
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str12
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Setting new values...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a method call to: set
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #60
[DEBUG] Loaded integer literal 60 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #80
[DEBUG] Loaded integer literal 80 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X21, X9
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'ColorPoint::set'
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X21
[DEBUG LEVEL 5] Emitting instruction: BL Point::set
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a method call to: setColor
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #123
[DEBUG] Loaded integer literal 123 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: BL ColorPoint::setColor
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str13
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str13
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading new values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #16] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'ColorPoint::getX'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #24] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'ColorPoint::getY'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str16
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str16
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', color='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'cp'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'cp' in function 'START'
[DEBUG] get_variable_register for: 'cp' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'cp' lives in register X27
[DEBUG] Variable 'cp' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Expression is a VariableAccess to: cp
[DEBUG] Found symbol with class_name: ColorPoint
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #48] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X0 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Deferring release of source register: X0
[DEBUG] Emitting 0 queued operations
[DEBUG] Releasing source register: X0
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str17
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str17
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
Test completed successfully
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L9
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L9
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_str5
[InstructionStream TRACE] Adding label definition: L_str6
[InstructionStream TRACE] Adding label definition: L_str7
[InstructionStream TRACE] Adding label definition: L_str8
[InstructionStream TRACE] Adding label definition: L_str9
[InstructionStream TRACE] Adding label definition: L_str10
[InstructionStream TRACE] Adding label definition: L_str11
[InstructionStream TRACE] Adding label definition: L_str12
[InstructionStream TRACE] Adding label definition: L_str13
[InstructionStream TRACE] Adding label definition: L_str14
[InstructionStream TRACE] Adding label definition: L_str15
[InstructionStream TRACE] Adding label definition: L_str16
[InstructionStream TRACE] Adding label definition: L_str17

[DataGenerator VTABLE] ===== Generating vtable in RODATA: ColorPoint_vtable =====
  Class: ColorPoint
  Parent: Point
  Vtable size: 7 method(s)
  Memory layout:
[InstructionStream TRACE] Adding label definition: ColorPoint_vtable
    [+0] Slot 0: ColorPoint::CREATE
    [+8] Slot 1: Point::RELEASE
    [+16] Slot 2: Point::getX
    [+24] Slot 3: Point::getY
    [+32] Slot 4: Point::set
    [+40] Slot 5: ColorPoint::setColor
    [+48] Slot 6: ColorPoint::getColor
  Total vtable size: 56 bytes
[DataGenerator VTABLE] ==========================================


[DataGenerator VTABLE] ===== Generating vtable in RODATA: Point_vtable =====
  Class: Point
  Vtable size: 5 method(s)
  Memory layout:
[InstructionStream TRACE] Adding label definition: Point_vtable
    [+0] Slot 0: Point::CREATE
    [+8] Slot 1: Point::RELEASE
    [+16] Slot 2: Point::getX
    [+24] Slot 3: Point::getY
    [+32] Slot 4: Point::set
  Total vtable size: 40 bytes
[DataGenerator VTABLE] ==========================================

[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'x' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'y' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'Point::CREATE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'Point::getX' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol 'Point::getY' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol 'Point::set' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::set')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'Point::RELEASE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::RELEASE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::RELEASE')
Symbol 'color' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='ColorPoint')
Symbol 'ColorPoint::CREATE' (class: ColorPoint, ROUTINE, INTEGER, scope=0, block=0, class_name='ColorPoint', function_name='ColorPoint::CREATE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'initialColor' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::CREATE')
Symbol 'ColorPoint::setColor' (class: ColorPoint, ROUTINE, INTEGER, scope=0, block=0, class_name='ColorPoint', function_name='ColorPoint::setColor')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='ColorPoint::setColor')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::setColor')
Symbol 'c' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::setColor')
Symbol 'ColorPoint::getColor' (class: ColorPoint, FUNCTION, INTEGER, scope=0, block=0, class_name='ColorPoint', function_name='ColorPoint::getColor')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='ColorPoint::getColor')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='ColorPoint::getColor')
Symbol 'makePoint' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='makePoint')
Symbol 'p' (LOCAL_VAR, INTEGER, scope=3, block=0, class_name='', function_name='makePoint')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p' (class: Point, LOCAL_VAR, POINTER_TO|OBJECT, scope=2, block=0, class_name='Point', function_name='makePoint')
Symbol 'cp' (class: ColorPoint, LOCAL_VAR, POINTER_TO|OBJECT, scope=2, block=0, class_name='ColorPoint', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_this' (class: ColorPoint, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='ColorPoint', function_name='ColorPoint::CREATE')
Symbol '_this' (class: ColorPoint, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='ColorPoint', function_name='ColorPoint::setColor')
Symbol '_this' (class: ColorPoint, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='ColorPoint', function_name='ColorPoint::getColor')

Data sections generated.

=== Peephole Optimization ===
Analyzing 943 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 226
  Before:
    MOV X15, X20  [Opcode=1, Dest=15, Src1=20]
    MOV X15, X20  [Opcode=1, Dest=15, Src1=20]
  After:
    MOV X15, X20  [Opcode=1, Dest=15, Src1=20]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 266
  Before:
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
  After:
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 341
  Before:
    MOV X27, X20  [Opcode=1, Dest=27, Src1=20]
    MOV X27, X20  [Opcode=1, Dest=27, Src1=20]
  After:
    MOV X27, X20  [Opcode=1, Dest=27, Src1=20]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 943
  Instructions after:  940
  Total optimizations: 3
  Patterns matched:
    - Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn): 3
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x1016f8000) ---
Address Hex Code    Assembly
--------------------------------------------------
 1016f8000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 1016f8004 0xd286e210  MOVZ X16, #14096
 1016f8008 0xf2a00fd0  MOVK X16, #126, LSL #16
 1016f800c 0xf2c00030  MOVK X16, #1, LSL #32
 1016f8010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 1016f8014 0xd286e790  MOVZ X16, #14140
 1016f8018 0xf2a00fd0  MOVK X16, #126, LSL #16
 1016f801c 0xf2c00030  MOVK X16, #1, LSL #32
 1016f8020 0xd61f0200  BR X16
WRITEN_veneer:
 1016f8024 0xd2940b10  MOVZ X16, #41048
 1016f8028 0xf2a01230  MOVK X16, #145, LSL #16
 1016f802c 0xf2c00030  MOVK X16, #1, LSL #32
 1016f8030 0xd61f0200  BR X16
WRITES_veneer:
 1016f8034 0xd292a990  MOVZ X16, #38220
 1016f8038 0xf2a01230  MOVK X16, #145, LSL #16
 1016f803c 0xf2c00030  MOVK X16, #1, LSL #32
 1016f8040 0xd61f0200  BR X16
 1016f8044 0x00000000  ; --- End Veneer Section ---

Point::CREATE:
 1016f8048 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 1016f804c 0x910003fd  MOV X29, SP
 1016f8050 0xf90017b3  STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
 1016f8054 0xf9001bb4  STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
 1016f8058 0xf9001fb9  STR X25, [X29, #56] ; Saved Reg: X25 @ FP+56
 1016f805c 0xf90023ba  STR X26, [X29, #64] ; Saved Reg: X26 @ FP+64
 1016f8060 0xf90027bb  STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
 1016f8064 0xf9002bbc  STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
 1016f8068 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 1016f806c 0xaa0103fa  MOV X26, X1    // Move parameter 'initialX' from X1 to X26
 1016f8070 0xaa0203f9  MOV X25, X2    // Move parameter 'initialY' from X2 to X25
 1016f8074 0xd288001c  MOVZ X28, #16384
 1016f8078 0xf2a0261c  MOVK X28, #304, LSL #16
 1016f807c 0xf2c0003c  MOVK X28, #1, LSL #32
 1016f8080 0xf2e0001c  MOVK X28, #0, LSL #48
Point::CREATE_Entry_0:
 1016f8084 0xf900077a  STR X26, [X27, #8] ; Store to member x
 1016f8088 0xf9000b79  STR X25, [X27, #16] ; Store to member y
 1016f808c 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x1016fd000
 1016f8090 0x91000129  ADD X9, X9, #:lo12:L_str0    ; Reloc -> 'L_str0' @ 0x1016fd000
 1016f8094 0x91002129  ADD X9, X9, #8
 1016f8098 0xaa0903e0  MOV X0, X9
 1016f809c 0x97ffffe6  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f80a0 0xf9400769  LDR X9, [X27, #8] ; x
 1016f80a4 0xaa0903e0  MOV X0, X9
 1016f80a8 0x97ffffdf  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f80ac 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x1016fd058
 1016f80b0 0x91016129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x1016fd058
 1016f80b4 0x91002129  ADD X9, X9, #8
 1016f80b8 0xaa0903e0  MOV X0, X9
 1016f80bc 0x97ffffde  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f80c0 0xf9400b69  LDR X9, [X27, #16] ; y
 1016f80c4 0xaa0903e0  MOV X0, X9
 1016f80c8 0x97ffffd7  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f80cc 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x1016fd070
 1016f80d0 0x9101c129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x1016fd070
 1016f80d4 0x91002129  ADD X9, X9, #8
 1016f80d8 0xaa0903e0  MOV X0, X9
 1016f80dc 0x97ffffd6  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f80e0 0x14000001  B Point::CREATE_Exit_1    ; Reloc -> 'Point::CREATE_Exit_1' @ 0x1016f80e4
Point::CREATE_Exit_1:
 1016f80e4 0x14000001  B .L0    ; Reloc -> '.L0' @ 0x1016f80e8
.L0:
 1016f80e8 0xf94017b3  LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40
 1016f80ec 0xf9401bb4  LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48
 1016f80f0 0xf9401fb9  LDR X25, [X29, #56] ; Restored Reg: X25 @ FP+56
 1016f80f4 0xf94023ba  LDR X26, [X29, #64] ; Restored Reg: X26 @ FP+64
 1016f80f8 0xf94027bb  LDR X27, [X29, #72] ; Restored Reg: X27 @ FP+72
 1016f80fc 0xf9402bbc  LDR X28, [X29, #80] ; Restored Reg: X28 @ FP+80
 1016f8100 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1016f8104 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 1016f8108 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 1016f810c 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1016f8110 0xd65f03c0  RET
Point::getX:
 1016f8114 0xf9400400  LDR X0, [X0, #8] ; Optimized accessor load (int/ptr)
 1016f8118 0xd65f03c0  RET
Point::getY:
 1016f811c 0xf9400800  LDR X0, [X0, #16] ; Optimized accessor load (int/ptr)
 1016f8120 0xd65f03c0  RET
Point::set:
 1016f8124 0xa9bc7bfd  STP X29, X30, [SP, #-64]!
 1016f8128 0x910003fd  MOV X29, SP
 1016f812c 0xf90017b3  STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
 1016f8130 0xf9001bb4  STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
 1016f8134 0xf9001fbc  STR X28, [X29, #56] ; Saved Reg: X28 @ FP+56
 1016f8138 0xaa0003ef  MOV X15, X0    // Move parameter '_this' from X0 to X15
 1016f813c 0xaa0103ee  MOV X14, X1    // Move parameter 'newX' from X1 to X14
 1016f8140 0xaa0203ed  MOV X13, X2    // Move parameter 'newY' from X2 to X13
Point::set_Entry_0:
 1016f8144 0xf90005ee  STR X14, [X15, #8] ; Store to member x
 1016f8148 0xf90009ed  STR X13, [X15, #16] ; Store to member y
 1016f814c 0x14000001  B Point::set_Exit_1    ; Reloc -> 'Point::set_Exit_1' @ 0x1016f8150
Point::set_Exit_1:
 1016f8150 0x14000001  B .L3    ; Reloc -> '.L3' @ 0x1016f8154
.L3:
 1016f8154 0xf94017b3  LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40
 1016f8158 0xf9401bb4  LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48
 1016f815c 0xf9401fbc  LDR X28, [X29, #56] ; Restored Reg: X28 @ FP+56
 1016f8160 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1016f8164 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 1016f8168 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 1016f816c 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1016f8170 0xd65f03c0  RET
Point::RELEASE:
 1016f8174 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 1016f8178 0x910003fd  MOV X29, SP
 1016f817c 0xf9000fb3  STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
 1016f8180 0xf90013bb  STR X27, [X29, #32] ; Saved Reg: X27 @ FP+32
 1016f8184 0xf90017bc  STR X28, [X29, #40] ; Saved Reg: X28 @ FP+40
 1016f8188 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 1016f818c 0xd288001c  MOVZ X28, #16384
 1016f8190 0xf2a0261c  MOVK X28, #304, LSL #16
 1016f8194 0xf2c0003c  MOVK X28, #1, LSL #32
 1016f8198 0xf2e0001c  MOVK X28, #0, LSL #48
Point::RELEASE_Entry_0:
 1016f819c 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x1016fd088
 1016f81a0 0x91022129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x1016fd088
 1016f81a4 0x91002129  ADD X9, X9, #8
 1016f81a8 0xaa0903e0  MOV X0, X9
 1016f81ac 0x97ffffa2  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f81b0 0x14000001  B Point::RELEASE_Exit_1    ; Reloc -> 'Point::RELEASE_Exit_1' @ 0x1016f81b4
Point::RELEASE_Exit_1:
 1016f81b4 0x14000001  B .L4    ; Reloc -> '.L4' @ 0x1016f81b8
.L4:
 1016f81b8 0xf9400fb3  LDR X19, [X29, #24] ; Restored Reg: X19 @ FP+24
 1016f81bc 0xf94013bb  LDR X27, [X29, #32] ; Restored Reg: X27 @ FP+32
 1016f81c0 0xf94017bc  LDR X28, [X29, #40] ; Restored Reg: X28 @ FP+40
 1016f81c4 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1016f81c8 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 1016f81cc 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 1016f81d0 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1016f81d4 0xd65f03c0  RET
ColorPoint::CREATE:
 1016f81d8 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 1016f81dc 0x910003fd  MOV X29, SP
 1016f81e0 0xf9001bb3  STR X19, [X29, #48] ; Saved Reg: X19 @ FP+48
 1016f81e4 0xf9001fb4  STR X20, [X29, #56] ; Saved Reg: X20 @ FP+56
 1016f81e8 0xf90023b5  STR X21, [X29, #64] ; Saved Reg: X21 @ FP+64
 1016f81ec 0xf90027bb  STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
 1016f81f0 0xf9002bbc  STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
 1016f81f4 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 1016f81f8 0xaa0103ee  MOV X14, X1    // Move parameter 'initialX' from X1 to X14
 1016f81fc 0xaa0203ed  MOV X13, X2    // Move parameter 'initialY' from X2 to X13
 1016f8200 0xaa0303ef  MOV X15, X3    // Move parameter 'initialColor' from X3 to X15
 1016f8204 0xd288001c  MOVZ X28, #16384
 1016f8208 0xf2a0261c  MOVK X28, #304, LSL #16
 1016f820c 0xf2c0003c  MOVK X28, #1, LSL #32
 1016f8210 0xf2e0001c  MOVK X28, #0, LSL #48
ColorPoint::CREATE_Entry_0:
 1016f8214 0xf9000f6f  STR X15, [X27, #24] ; Store to member color
 1016f8218 0xaa0e03f4  MOV X20, X14
 1016f821c 0xaa0d03f5  MOV X21, X13
 1016f8220 0xaa1b03e0  MOV X0, X27
 1016f8224 0xaa1403e1  MOV X1, X20
 1016f8228 0xaa1503e2  MOV X2, X21
 1016f822c 0x97ffff87  BL Point::CREATE    ; Reloc -> 'Point::CREATE' @ 0x1016f8048
 1016f8230 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x1016fd0d8
 1016f8234 0x91036129  ADD X9, X9, #:lo12:L_str4    ; Reloc -> 'L_str4' @ 0x1016fd0d8
 1016f8238 0x91002129  ADD X9, X9, #8
 1016f823c 0xaa0903e0  MOV X0, X9
 1016f8240 0x97ffff7d  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8244 0xf9400769  LDR X9, [X27, #8] ; x
 1016f8248 0xaa0903e0  MOV X0, X9
 1016f824c 0x97ffff76  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8250 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x1016fd058
 1016f8254 0x91016129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x1016fd058
 1016f8258 0x91002129  ADD X9, X9, #8
 1016f825c 0xaa0903e0  MOV X0, X9
 1016f8260 0x97ffff75  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8264 0xf9400b69  LDR X9, [X27, #16] ; y
 1016f8268 0xaa0903e0  MOV X0, X9
 1016f826c 0x97ffff6e  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8270 0xb0000029  ADRP X9, L_str5    ; Reloc -> 'L_str5' @ 0x1016fd144
 1016f8274 0x91051129  ADD X9, X9, #:lo12:L_str5    ; Reloc -> 'L_str5' @ 0x1016fd144
 1016f8278 0x91002129  ADD X9, X9, #8
 1016f827c 0xaa0903e0  MOV X0, X9
 1016f8280 0x97ffff6d  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8284 0xf9400f69  LDR X9, [X27, #24] ; color
 1016f8288 0xaa0903e0  MOV X0, X9
 1016f828c 0x97ffff66  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8290 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f8294 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f8298 0x91002129  ADD X9, X9, #8
 1016f829c 0xaa0903e0  MOV X0, X9
 1016f82a0 0x97ffff65  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f82a4 0x14000001  B ColorPoint::CREATE_Exit_1    ; Reloc -> 'ColorPoint::CREATE_Exit_1' @ 0x1016f82a8
ColorPoint::CREATE_Exit_1:
 1016f82a8 0x14000001  B .L5    ; Reloc -> '.L5' @ 0x1016f82ac
.L5:
 1016f82ac 0xf9401bb3  LDR X19, [X29, #48] ; Restored Reg: X19 @ FP+48
 1016f82b0 0xf9401fb4  LDR X20, [X29, #56] ; Restored Reg: X20 @ FP+56
 1016f82b4 0xf94023b5  LDR X21, [X29, #64] ; Restored Reg: X21 @ FP+64
 1016f82b8 0xf94027bb  LDR X27, [X29, #72] ; Restored Reg: X27 @ FP+72
 1016f82bc 0xf9402bbc  LDR X28, [X29, #80] ; Restored Reg: X28 @ FP+80
 1016f82c0 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1016f82c4 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 1016f82c8 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 1016f82cc 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1016f82d0 0xd65f03c0  RET
ColorPoint::setColor:
 1016f82d4 0xf9000c01  STR X1, [X0, #24] ; Optimized setter store
 1016f82d8 0xd65f03c0  RET
ColorPoint::getColor:
 1016f82dc 0xf9400c00  LDR X0, [X0, #24] ; Optimized accessor load (int/ptr)
 1016f82e0 0xd65f03c0  RET
makePoint:
 1016f82e4 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 1016f82e8 0x910003fd  MOV X29, SP
 1016f82ec 0xf9000fb3  STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
 1016f82f0 0xf90013bc  STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
 1016f82f4 0xd288001c  MOVZ X28, #16384
 1016f82f8 0xf2a0261c  MOVK X28, #304, LSL #16
 1016f82fc 0xf2c0003c  MOVK X28, #1, LSL #32
 1016f8300 0xf2e0001c  MOVK X28, #0, LSL #48
makePoint_Entry_0:
 1016f8304 0x97ffff40  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x1016f8004
 1016f8308 0xd2800300  MOVZ X0, #24
 1016f830c 0x97c89175  BL OBJECT_HEAP_ALLOC    ; Reloc -> 'OBJECT_HEAP_ALLOC' @ 0x10091c8e0
 1016f8310 0xaa0003f4  MOV X20, X0
 1016f8314 0xb0000029  ADRP X9, Point_vtable    ; Reloc -> 'Point_vtable' @ 0x1016fd6d8
 1016f8318 0x911b6129  ADD X9, X9, #:lo12:Point_vtable    ; Reloc -> 'Point_vtable' @ 0x1016fd6d8
 1016f831c 0xf9000289  STR X9, [X20, #0] ; store vtable ptr
 1016f8320 0xaa1403ef  MOV X15, X20
 1016f8324 0x14000001  B makePoint_Exit_2    ; Reloc -> 'makePoint_Exit_2' @ 0x1016f8328
makePoint_Exit_2:
 1016f8328 0x14000001  B .L8    ; Reloc -> '.L8' @ 0x1016f832c
.L8:
 1016f832c 0xf9400fb3  LDR X19, [X29, #24] ; Restored Reg: X19 @ FP+24
 1016f8330 0xf94013bc  LDR X28, [X29, #32] ; Restored Reg: X28 @ FP+32
 1016f8334 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1016f8338 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 1016f833c 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 1016f8340 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1016f8344 0xd65f03c0  RET
START:
 1016f8348 0xa9bc7bfd  STP X29, X30, [SP, #-64]!
 1016f834c 0x910003fd  MOV X29, SP
 1016f8350 0xf90013b3  STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
 1016f8354 0xf90017bb  STR X27, [X29, #40] ; Saved Reg: X27 @ FP+40
 1016f8358 0xf9001bbc  STR X28, [X29, #48] ; Saved Reg: X28 @ FP+48
 1016f835c 0xd288001c  MOVZ X28, #16384
 1016f8360 0xf2a0261c  MOVK X28, #304, LSL #16
 1016f8364 0xf2c0003c  MOVK X28, #1, LSL #32
 1016f8368 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 1016f836c 0x97ffff26  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x1016f8004
 1016f8370 0xb0000029  ADRP X9, L_str7    ; Reloc -> 'L_str7' @ 0x1016fd19c
 1016f8374 0x91067129  ADD X9, X9, #:lo12:L_str7    ; Reloc -> 'L_str7' @ 0x1016fd19c
 1016f8378 0x91002129  ADD X9, X9, #8
 1016f837c 0xaa0903e0  MOV X0, X9
 1016f8380 0x97ffff2d  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8384 0xb0000029  ADRP X9, L_str8    ; Reloc -> 'L_str8' @ 0x1016fd294
 1016f8388 0x910a5129  ADD X9, X9, #:lo12:L_str8    ; Reloc -> 'L_str8' @ 0x1016fd294
 1016f838c 0x91002129  ADD X9, X9, #8
 1016f8390 0xaa0903e0  MOV X0, X9
 1016f8394 0x97ffff28  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8398 0xb0000029  ADRP X9, L_str9    ; Reloc -> 'L_str9' @ 0x1016fd370
 1016f839c 0x910dc129  ADD X9, X9, #:lo12:L_str9    ; Reloc -> 'L_str9' @ 0x1016fd370
 1016f83a0 0x91002129  ADD X9, X9, #8
 1016f83a4 0xaa0903e0  MOV X0, X9
 1016f83a8 0x97ffff23  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f83ac 0x97ffffce  BL makePoint    ; Reloc -> 'makePoint' @ 0x1016f82e4
 1016f83b0 0xaa0003fb  MOV X27, X0
 1016f83b4 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x1016fd3ec
 1016f83b8 0x910fb129  ADD X9, X9, #:lo12:L_str10    ; Reloc -> 'L_str10' @ 0x1016fd3ec
 1016f83bc 0x91002129  ADD X9, X9, #8
 1016f83c0 0xaa0903e0  MOV X0, X9
 1016f83c4 0x97ffff1c  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f83c8 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f83cc 0xf940092a  LDR X10, [X9, #16] ; Load method address
 1016f83d0 0xaa1b03e0  MOV X0, X27
 1016f83d4 0xd63f0140  BLR X10
 1016f83d8 0x97ffff13  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f83dc 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f83e0 0x91111129  ADD X9, X9, #:lo12:L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f83e4 0x91002129  ADD X9, X9, #8
 1016f83e8 0xaa0903e0  MOV X0, X9
 1016f83ec 0x97ffff12  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f83f0 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f83f4 0xf9400d2a  LDR X10, [X9, #24] ; Load method address
 1016f83f8 0xaa1b03e0  MOV X0, X27
 1016f83fc 0xd63f0140  BLR X10
 1016f8400 0x97ffff09  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8404 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f8408 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f840c 0x91002129  ADD X9, X9, #8
 1016f8410 0xaa0903e0  MOV X0, X9
 1016f8414 0x97ffff08  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8418 0xb0000029  ADRP X9, L_str12    ; Reloc -> 'L_str12' @ 0x1016fd464
 1016f841c 0x91119129  ADD X9, X9, #:lo12:L_str12    ; Reloc -> 'L_str12' @ 0x1016fd464
 1016f8420 0x91002129  ADD X9, X9, #8
 1016f8424 0xaa0903e0  MOV X0, X9
 1016f8428 0x97ffff03  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f842c 0xd2800c89  MOVZ X9, #100
 1016f8430 0xaa0903f4  MOV X20, X9
 1016f8434 0xd2801909  MOVZ X9, #200
 1016f8438 0xaa0903f5  MOV X21, X9
 1016f843c 0xaa1b03e0  MOV X0, X27
 1016f8440 0xaa1403e1  MOV X1, X20
 1016f8444 0xaa1503e2  MOV X2, X21
 1016f8448 0x97ffff37  BL Point::set    ; Reloc -> 'Point::set' @ 0x1016f8124
 1016f844c 0xb0000029  ADRP X9, L_str13    ; Reloc -> 'L_str13' @ 0x1016fd4cc
 1016f8450 0x91133129  ADD X9, X9, #:lo12:L_str13    ; Reloc -> 'L_str13' @ 0x1016fd4cc
 1016f8454 0x91002129  ADD X9, X9, #8
 1016f8458 0xaa0903e0  MOV X0, X9
 1016f845c 0x97fffef6  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8460 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f8464 0xf940092a  LDR X10, [X9, #16] ; Load method address
 1016f8468 0xaa1b03e0  MOV X0, X27
 1016f846c 0xd63f0140  BLR X10
 1016f8470 0x97fffeed  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8474 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f8478 0x91111129  ADD X9, X9, #:lo12:L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f847c 0x91002129  ADD X9, X9, #8
 1016f8480 0xaa0903e0  MOV X0, X9
 1016f8484 0x97fffeec  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8488 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f848c 0xf9400d2a  LDR X10, [X9, #24] ; Load method address
 1016f8490 0xaa1b03e0  MOV X0, X27
 1016f8494 0xd63f0140  BLR X10
 1016f8498 0x97fffee3  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f849c 0xb0000029  ADRP X9, L_str14    ; Reloc -> 'L_str14' @ 0x1016fd534
 1016f84a0 0x9114d129  ADD X9, X9, #:lo12:L_str14    ; Reloc -> 'L_str14' @ 0x1016fd534
 1016f84a4 0x91002129  ADD X9, X9, #8
 1016f84a8 0xaa0903e0  MOV X0, X9
 1016f84ac 0x97fffee2  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f84b0 0xb0000029  ADRP X9, L_str15    ; Reloc -> 'L_str15' @ 0x1016fd54c
 1016f84b4 0x91153129  ADD X9, X9, #:lo12:L_str15    ; Reloc -> 'L_str15' @ 0x1016fd54c
 1016f84b8 0x91002129  ADD X9, X9, #8
 1016f84bc 0xaa0903e0  MOV X0, X9
 1016f84c0 0x97fffedd  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f84c4 0xd2800400  MOVZ X0, #32
 1016f84c8 0x97c89106  BL OBJECT_HEAP_ALLOC    ; Reloc -> 'OBJECT_HEAP_ALLOC' @ 0x10091c8e0
 1016f84cc 0xaa0003f4  MOV X20, X0
 1016f84d0 0xb0000029  ADRP X9, ColorPoint_vtable    ; Reloc -> 'ColorPoint_vtable' @ 0x1016fd6a0
 1016f84d4 0x911a8129  ADD X9, X9, #:lo12:ColorPoint_vtable    ; Reloc -> 'ColorPoint_vtable' @ 0x1016fd6a0
 1016f84d8 0xf9000289  STR X9, [X20, #0] ; store vtable ptr
 1016f84dc 0xaa1403fb  MOV X27, X20
 1016f84e0 0xd2801049  MOVZ X9, #130
 1016f84e4 0xaa0903f4  MOV X20, X9
 1016f84e8 0xd2801189  MOVZ X9, #140
 1016f84ec 0xaa0903f5  MOV X21, X9
 1016f84f0 0xd2801fe9  MOVZ X9, #255
 1016f84f4 0xaa0903f6  MOV X22, X9
 1016f84f8 0xaa1b03e0  MOV X0, X27
 1016f84fc 0xaa1403e1  MOV X1, X20
 1016f8500 0xaa1503e2  MOV X2, X21
 1016f8504 0xaa1603e3  MOV X3, X22
 1016f8508 0x97ffff34  BL ColorPoint::CREATE    ; Reloc -> 'ColorPoint::CREATE' @ 0x1016f81d8
 1016f850c 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x1016fd3ec
 1016f8510 0x910fb129  ADD X9, X9, #:lo12:L_str10    ; Reloc -> 'L_str10' @ 0x1016fd3ec
 1016f8514 0x91002129  ADD X9, X9, #8
 1016f8518 0xaa0903e0  MOV X0, X9
 1016f851c 0x97fffec6  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8520 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f8524 0xf940092a  LDR X10, [X9, #16] ; Load method address
 1016f8528 0xaa1b03e0  MOV X0, X27
 1016f852c 0xd63f0140  BLR X10
 1016f8530 0x97fffebd  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8534 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f8538 0x91111129  ADD X9, X9, #:lo12:L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f853c 0x91002129  ADD X9, X9, #8
 1016f8540 0xaa0903e0  MOV X0, X9
 1016f8544 0x97fffebc  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8548 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f854c 0xf9400d2a  LDR X10, [X9, #24] ; Load method address
 1016f8550 0xaa1b03e0  MOV X0, X27
 1016f8554 0xd63f0140  BLR X10
 1016f8558 0x97fffeb3  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f855c 0xb0000029  ADRP X9, L_str16    ; Reloc -> 'L_str16' @ 0x1016fd5ec
 1016f8560 0x9117b129  ADD X9, X9, #:lo12:L_str16    ; Reloc -> 'L_str16' @ 0x1016fd5ec
 1016f8564 0x91002129  ADD X9, X9, #8
 1016f8568 0xaa0903e0  MOV X0, X9
 1016f856c 0x97fffeb2  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8570 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f8574 0xf940192a  LDR X10, [X9, #48] ; Load method address
 1016f8578 0xaa1b03e0  MOV X0, X27
 1016f857c 0xd63f0140  BLR X10
 1016f8580 0x97fffea9  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8584 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f8588 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f858c 0x91002129  ADD X9, X9, #8
 1016f8590 0xaa0903e0  MOV X0, X9
 1016f8594 0x97fffea8  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8598 0xb0000029  ADRP X9, L_str12    ; Reloc -> 'L_str12' @ 0x1016fd464
 1016f859c 0x91119129  ADD X9, X9, #:lo12:L_str12    ; Reloc -> 'L_str12' @ 0x1016fd464
 1016f85a0 0x91002129  ADD X9, X9, #8
 1016f85a4 0xaa0903e0  MOV X0, X9
 1016f85a8 0x97fffea3  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f85ac 0xd2800789  MOVZ X9, #60
 1016f85b0 0xaa0903f4  MOV X20, X9
 1016f85b4 0xd2800a09  MOVZ X9, #80
 1016f85b8 0xaa0903f5  MOV X21, X9
 1016f85bc 0xaa1b03e0  MOV X0, X27
 1016f85c0 0xaa1403e1  MOV X1, X20
 1016f85c4 0xaa1503e2  MOV X2, X21
 1016f85c8 0x97fffed7  BL Point::set    ; Reloc -> 'Point::set' @ 0x1016f8124
 1016f85cc 0xd2800f69  MOVZ X9, #123
 1016f85d0 0xaa0903f4  MOV X20, X9
 1016f85d4 0xaa1b03e0  MOV X0, X27
 1016f85d8 0xaa1403e1  MOV X1, X20
 1016f85dc 0x97ffff3e  BL ColorPoint::setColor    ; Reloc -> 'ColorPoint::setColor' @ 0x1016f82d4
 1016f85e0 0xb0000029  ADRP X9, L_str13    ; Reloc -> 'L_str13' @ 0x1016fd4cc
 1016f85e4 0x91133129  ADD X9, X9, #:lo12:L_str13    ; Reloc -> 'L_str13' @ 0x1016fd4cc
 1016f85e8 0x91002129  ADD X9, X9, #8
 1016f85ec 0xaa0903e0  MOV X0, X9
 1016f85f0 0x97fffe91  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f85f4 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f85f8 0xf940092a  LDR X10, [X9, #16] ; Load method address
 1016f85fc 0xaa1b03e0  MOV X0, X27
 1016f8600 0xd63f0140  BLR X10
 1016f8604 0x97fffe88  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8608 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f860c 0x91111129  ADD X9, X9, #:lo12:L_str11    ; Reloc -> 'L_str11' @ 0x1016fd444
 1016f8610 0x91002129  ADD X9, X9, #8
 1016f8614 0xaa0903e0  MOV X0, X9
 1016f8618 0x97fffe87  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f861c 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f8620 0xf9400d2a  LDR X10, [X9, #24] ; Load method address
 1016f8624 0xaa1b03e0  MOV X0, X27
 1016f8628 0xd63f0140  BLR X10
 1016f862c 0x97fffe7e  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8630 0xb0000029  ADRP X9, L_str16    ; Reloc -> 'L_str16' @ 0x1016fd5ec
 1016f8634 0x9117b129  ADD X9, X9, #:lo12:L_str16    ; Reloc -> 'L_str16' @ 0x1016fd5ec
 1016f8638 0x91002129  ADD X9, X9, #8
 1016f863c 0xaa0903e0  MOV X0, X9
 1016f8640 0x97fffe7d  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8644 0xf9400369  LDR X9, [X27, #0] ; Load vtable pointer
 1016f8648 0xf940192a  LDR X10, [X9, #48] ; Load method address
 1016f864c 0xaa1b03e0  MOV X0, X27
 1016f8650 0xd63f0140  BLR X10
 1016f8654 0x97fffe74  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x1016f8024
 1016f8658 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f865c 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x1016fd188
 1016f8660 0x91002129  ADD X9, X9, #8
 1016f8664 0xaa0903e0  MOV X0, X9
 1016f8668 0x97fffe73  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f866c 0xb0000029  ADRP X9, L_str17    ; Reloc -> 'L_str17' @ 0x1016fd61c
 1016f8670 0x91187129  ADD X9, X9, #:lo12:L_str17    ; Reloc -> 'L_str17' @ 0x1016fd61c
 1016f8674 0x91002129  ADD X9, X9, #8
 1016f8678 0xaa0903e0  MOV X0, X9
 1016f867c 0x97fffe6e  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1016f8034
 1016f8680 0x97fffe65  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x1016f8014
 1016f8684 0x14000001  B START_Exit_1    ; Reloc -> 'START_Exit_1' @ 0x1016f8688
START_Exit_1:
 1016f8688 0x14000001  B .L9    ; Reloc -> '.L9' @ 0x1016f868c
.L9:
 1016f868c 0xf94013b3  LDR X19, [X29, #32] ; Restored Reg: X19 @ FP+32
 1016f8690 0xf94017bb  LDR X27, [X29, #40] ; Restored Reg: X27 @ FP+40
 1016f8694 0xf9401bbc  LDR X28, [X29, #48] ; Restored Reg: X28 @ FP+48
 1016f8698 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1016f869c 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 1016f86a0 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 1016f86a4 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1016f86a8 0xd65f03c0  RET
L_str0:
 1016fd000 0x12000000  .quad 0x12
 1016fd004 0x00000000  ; (upper half)
 1016fd008 0x50000000  DCD 0x50
 1016fd00c 0x6f000000  DCD 0x6f
 1016fd010 0x69000000  DCD 0x69
 1016fd014 0x6e000000  DCD 0x6e
 1016fd018 0x74000000  DCD 0x74
 1016fd01c 0x20000000  DCD 0x20
 1016fd020 0x63000000  DCD 0x63
 1016fd024 0x72000000  DCD 0x72
 1016fd028 0x65000000  DCD 0x65
 1016fd02c 0x61000000  DCD 0x61
 1016fd030 0x74000000  DCD 0x74
 1016fd034 0x65000000  DCD 0x65
 1016fd038 0x64000000  DCD 0x64
 1016fd03c 0x20000000  DCD 0x20
 1016fd040 0x61000000  DCD 0x61
 1016fd044 0x74000000  DCD 0x74
 1016fd048 0x20000000  DCD 0x20
 1016fd04c 0x28000000  DCD 0x28
 1016fd050 0x00000000  DCD 0x0
 1016fd054 0x00000000  DCD 0x0
L_str1:
 1016fd058 0x20000000  .quad 0x2
 1016fd05c 0x00000000  ; (upper half)
 1016fd060 0x2c000000  DCD 0x2c
 1016fd064 0x20000000  DCD 0x20
 1016fd068 0x00000000  DCD 0x0
 1016fd06c 0x00000000  DCD 0x0
L_str2:
 1016fd070 0x20000000  .quad 0x2
 1016fd074 0x00000000  ; (upper half)
 1016fd078 0x29000000  DCD 0x29
 1016fd07c 0xa0000000  DCD 0xa
 1016fd080 0x00000000  DCD 0x0
 1016fd084 0x00000000  DCD 0x0
L_str3:
 1016fd088 0x10000000  .quad 0x10
 1016fd08c 0x00000000  ; (upper half)
 1016fd090 0x50000000  DCD 0x50
 1016fd094 0x6f000000  DCD 0x6f
 1016fd098 0x69000000  DCD 0x69
 1016fd09c 0x6e000000  DCD 0x6e
 1016fd0a0 0x74000000  DCD 0x74
 1016fd0a4 0x20000000  DCD 0x20
 1016fd0a8 0x64000000  DCD 0x64
 1016fd0ac 0x65000000  DCD 0x65
 1016fd0b0 0x73000000  DCD 0x73
 1016fd0b4 0x74000000  DCD 0x74
 1016fd0b8 0x72000000  DCD 0x72
 1016fd0bc 0x6f000000  DCD 0x6f
 1016fd0c0 0x79000000  DCD 0x79
 1016fd0c4 0x65000000  DCD 0x65
 1016fd0c8 0x64000000  DCD 0x64
 1016fd0cc 0xa0000000  DCD 0xa
 1016fd0d0 0x00000000  DCD 0x0
 1016fd0d4 0x00000000  DCD 0x0
L_str4:
 1016fd0d8 0x17000000  .quad 0x17
 1016fd0dc 0x00000000  ; (upper half)
 1016fd0e0 0x43000000  DCD 0x43
 1016fd0e4 0x6f000000  DCD 0x6f
 1016fd0e8 0x6c000000  DCD 0x6c
 1016fd0ec 0x6f000000  DCD 0x6f
 1016fd0f0 0x72000000  DCD 0x72
 1016fd0f4 0x50000000  DCD 0x50
 1016fd0f8 0x6f000000  DCD 0x6f
 1016fd0fc 0x69000000  DCD 0x69
 1016fd100 0x6e000000  DCD 0x6e
 1016fd104 0x74000000  DCD 0x74
 1016fd108 0x20000000  DCD 0x20
 1016fd10c 0x63000000  DCD 0x63
 1016fd110 0x72000000  DCD 0x72
 1016fd114 0x65000000  DCD 0x65
 1016fd118 0x61000000  DCD 0x61
 1016fd11c 0x74000000  DCD 0x74
 1016fd120 0x65000000  DCD 0x65
 1016fd124 0x64000000  DCD 0x64
 1016fd128 0x20000000  DCD 0x20
 1016fd12c 0x61000000  DCD 0x61
 1016fd130 0x74000000  DCD 0x74
 1016fd134 0x20000000  DCD 0x20
 1016fd138 0x28000000  DCD 0x28
 1016fd13c 0x00000000  DCD 0x0
 1016fd140 0x00000000  DCD 0x0
L_str5:
 1016fd144 0xd0000000  .quad 0xd
 1016fd148 0x00000000  ; (upper half)
 1016fd14c 0x29000000  DCD 0x29
 1016fd150 0x20000000  DCD 0x20
 1016fd154 0x77000000  DCD 0x77
 1016fd158 0x69000000  DCD 0x69
 1016fd15c 0x74000000  DCD 0x74
 1016fd160 0x68000000  DCD 0x68
 1016fd164 0x20000000  DCD 0x20
 1016fd168 0x63000000  DCD 0x63
 1016fd16c 0x6f000000  DCD 0x6f
 1016fd170 0x6c000000  DCD 0x6c
 1016fd174 0x6f000000  DCD 0x6f
 1016fd178 0x72000000  DCD 0x72
 1016fd17c 0x20000000  DCD 0x20
 1016fd180 0x00000000  DCD 0x0
 1016fd184 0x00000000  DCD 0x0
L_str6:
 1016fd188 0x10000000  .quad 0x1
 1016fd18c 0x00000000  ; (upper half)
 1016fd190 0xa0000000  DCD 0xa
 1016fd194 0x00000000  DCD 0x0
 1016fd198 0x00000000  DCD 0x0
L_str7:
 1016fd19c 0x3a000000  .quad 0x3a
 1016fd1a0 0x00000000  ; (upper half)
 1016fd1a4 0x54000000  DCD 0x54
 1016fd1a8 0x65000000  DCD 0x65
 1016fd1ac 0x73000000  DCD 0x73
 1016fd1b0 0x74000000  DCD 0x74
 1016fd1b4 0x69000000  DCD 0x69
 1016fd1b8 0x6e000000  DCD 0x6e
 1016fd1bc 0x67000000  DCD 0x67
 1016fd1c0 0x20000000  DCD 0x20
 1016fd1c4 0x63000000  DCD 0x63
 1016fd1c8 0x6c000000  DCD 0x6c
 1016fd1cc 0x61000000  DCD 0x61
 1016fd1d0 0x73000000  DCD 0x73
 1016fd1d4 0x73000000  DCD 0x73
 1016fd1d8 0x20000000  DCD 0x20
 1016fd1dc 0x6d000000  DCD 0x6d
 1016fd1e0 0x65000000  DCD 0x65
 1016fd1e4 0x6d000000  DCD 0x6d
 1016fd1e8 0x62000000  DCD 0x62
 1016fd1ec 0x65000000  DCD 0x65
 1016fd1f0 0x72000000  DCD 0x72
 1016fd1f4 0x20000000  DCD 0x20
 1016fd1f8 0x76000000  DCD 0x76
 1016fd1fc 0x61000000  DCD 0x61
 1016fd200 0x72000000  DCD 0x72
 1016fd204 0x69000000  DCD 0x69
 1016fd208 0x61000000  DCD 0x61
 1016fd20c 0x62000000  DCD 0x62
 1016fd210 0x6c000000  DCD 0x6c
 1016fd214 0x65000000  DCD 0x65
 1016fd218 0x20000000  DCD 0x20
 1016fd21c 0x61000000  DCD 0x61
 1016fd220 0x63000000  DCD 0x63
 1016fd224 0x63000000  DCD 0x63
 1016fd228 0x65000000  DCD 0x65
 1016fd22c 0x73000000  DCD 0x73
 1016fd230 0x73000000  DCD 0x73
 1016fd234 0x20000000  DCD 0x20
 1016fd238 0x77000000  DCD 0x77
 1016fd23c 0x69000000  DCD 0x69
 1016fd240 0x74000000  DCD 0x74
 1016fd244 0x68000000  DCD 0x68
 1016fd248 0x20000000  DCD 0x20
 1016fd24c 0x63000000  DCD 0x63
 1016fd250 0x6f000000  DCD 0x6f
 1016fd254 0x72000000  DCD 0x72
 1016fd258 0x72000000  DCD 0x72
 1016fd25c 0x65000000  DCD 0x65
 1016fd260 0x63000000  DCD 0x63
 1016fd264 0x74000000  DCD 0x74
 1016fd268 0x20000000  DCD 0x20
 1016fd26c 0x6f000000  DCD 0x6f
 1016fd270 0x66000000  DCD 0x66
 1016fd274 0x66000000  DCD 0x66
 1016fd278 0x73000000  DCD 0x73
 1016fd27c 0x65000000  DCD 0x65
 1016fd280 0x74000000  DCD 0x74
 1016fd284 0x73000000  DCD 0x73
 1016fd288 0xa0000000  DCD 0xa
 1016fd28c 0x00000000  DCD 0x0
 1016fd290 0x00000000  DCD 0x0
L_str8:
 1016fd294 0x33000000  .quad 0x33
 1016fd298 0x00000000  ; (upper half)
 1016fd29c 0x3d000000  DCD 0x3d
 1016fd2a0 0x3d000000  DCD 0x3d
 1016fd2a4 0x3d000000  DCD 0x3d
 1016fd2a8 0x3d000000  DCD 0x3d
 1016fd2ac 0x3d000000  DCD 0x3d
 1016fd2b0 0x3d000000  DCD 0x3d
 1016fd2b4 0x3d000000  DCD 0x3d
 1016fd2b8 0x3d000000  DCD 0x3d
 1016fd2bc 0x3d000000  DCD 0x3d
 1016fd2c0 0x3d000000  DCD 0x3d
 1016fd2c4 0x3d000000  DCD 0x3d
 1016fd2c8 0x3d000000  DCD 0x3d
 1016fd2cc 0x3d000000  DCD 0x3d
 1016fd2d0 0x3d000000  DCD 0x3d
 1016fd2d4 0x3d000000  DCD 0x3d
 1016fd2d8 0x3d000000  DCD 0x3d
 1016fd2dc 0x3d000000  DCD 0x3d
 1016fd2e0 0x3d000000  DCD 0x3d
 1016fd2e4 0x3d000000  DCD 0x3d
 1016fd2e8 0x3d000000  DCD 0x3d
 1016fd2ec 0x3d000000  DCD 0x3d
 1016fd2f0 0x3d000000  DCD 0x3d
 1016fd2f4 0x3d000000  DCD 0x3d
 1016fd2f8 0x3d000000  DCD 0x3d
 1016fd2fc 0x3d000000  DCD 0x3d
 1016fd300 0x3d000000  DCD 0x3d
 1016fd304 0x3d000000  DCD 0x3d
 1016fd308 0x3d000000  DCD 0x3d
 1016fd30c 0x3d000000  DCD 0x3d
 1016fd310 0x3d000000  DCD 0x3d
 1016fd314 0x3d000000  DCD 0x3d
 1016fd318 0x3d000000  DCD 0x3d
 1016fd31c 0x3d000000  DCD 0x3d
 1016fd320 0x3d000000  DCD 0x3d
 1016fd324 0x3d000000  DCD 0x3d
 1016fd328 0x3d000000  DCD 0x3d
 1016fd32c 0x3d000000  DCD 0x3d
 1016fd330 0x3d000000  DCD 0x3d
 1016fd334 0x3d000000  DCD 0x3d
 1016fd338 0x3d000000  DCD 0x3d
 1016fd33c 0x3d000000  DCD 0x3d
 1016fd340 0x3d000000  DCD 0x3d
 1016fd344 0x3d000000  DCD 0x3d
 1016fd348 0x3d000000  DCD 0x3d
 1016fd34c 0x3d000000  DCD 0x3d
 1016fd350 0x3d000000  DCD 0x3d
 1016fd354 0x3d000000  DCD 0x3d
 1016fd358 0x3d000000  DCD 0x3d
 1016fd35c 0x3d000000  DCD 0x3d
 1016fd360 0xa0000000  DCD 0xa
 1016fd364 0xa0000000  DCD 0xa
 1016fd368 0x00000000  DCD 0x0
 1016fd36c 0x00000000  DCD 0x0
L_str9:
 1016fd370 0x1b000000  .quad 0x1b
 1016fd374 0x00000000  ; (upper half)
 1016fd378 0x31000000  DCD 0x31
 1016fd37c 0x2e000000  DCD 0x2e
 1016fd380 0x20000000  DCD 0x20
 1016fd384 0x42000000  DCD 0x42
 1016fd388 0x61000000  DCD 0x61
 1016fd38c 0x73000000  DCD 0x73
 1016fd390 0x69000000  DCD 0x69
 1016fd394 0x63000000  DCD 0x63
 1016fd398 0x20000000  DCD 0x20
 1016fd39c 0x50000000  DCD 0x50
 1016fd3a0 0x6f000000  DCD 0x6f
 1016fd3a4 0x69000000  DCD 0x69
 1016fd3a8 0x6e000000  DCD 0x6e
 1016fd3ac 0x74000000  DCD 0x74
 1016fd3b0 0x20000000  DCD 0x20
 1016fd3b4 0x63000000  DCD 0x63
 1016fd3b8 0x6c000000  DCD 0x6c
 1016fd3bc 0x61000000  DCD 0x61
 1016fd3c0 0x73000000  DCD 0x73
 1016fd3c4 0x73000000  DCD 0x73
 1016fd3c8 0x20000000  DCD 0x20
 1016fd3cc 0x74000000  DCD 0x74
 1016fd3d0 0x65000000  DCD 0x65
 1016fd3d4 0x73000000  DCD 0x73
 1016fd3d8 0x74000000  DCD 0x74
 1016fd3dc 0x3a000000  DCD 0x3a
 1016fd3e0 0xa0000000  DCD 0xa
 1016fd3e4 0x00000000  DCD 0x0
 1016fd3e8 0x00000000  DCD 0x0
L_str10:
 1016fd3ec 0x12000000  .quad 0x12
 1016fd3f0 0x00000000  ; (upper half)
 1016fd3f4 0x52000000  DCD 0x52
 1016fd3f8 0x65000000  DCD 0x65
 1016fd3fc 0x61000000  DCD 0x61
 1016fd400 0x64000000  DCD 0x64
 1016fd404 0x69000000  DCD 0x69
 1016fd408 0x6e000000  DCD 0x6e
 1016fd40c 0x67000000  DCD 0x67
 1016fd410 0x20000000  DCD 0x20
 1016fd414 0x76000000  DCD 0x76
 1016fd418 0x61000000  DCD 0x61
 1016fd41c 0x6c000000  DCD 0x6c
 1016fd420 0x75000000  DCD 0x75
 1016fd424 0x65000000  DCD 0x65
 1016fd428 0x73000000  DCD 0x73
 1016fd42c 0x3a000000  DCD 0x3a
 1016fd430 0x20000000  DCD 0x20
 1016fd434 0x78000000  DCD 0x78
 1016fd438 0x3d000000  DCD 0x3d
 1016fd43c 0x00000000  DCD 0x0
 1016fd440 0x00000000  DCD 0x0
L_str11:
 1016fd444 0x40000000  .quad 0x4
 1016fd448 0x00000000  ; (upper half)
 1016fd44c 0x2c000000  DCD 0x2c
 1016fd450 0x20000000  DCD 0x20
 1016fd454 0x79000000  DCD 0x79
 1016fd458 0x3d000000  DCD 0x3d
 1016fd45c 0x00000000  DCD 0x0
 1016fd460 0x00000000  DCD 0x0
L_str12:
 1016fd464 0x16000000  .quad 0x16
 1016fd468 0x00000000  ; (upper half)
 1016fd46c 0x53000000  DCD 0x53
 1016fd470 0x65000000  DCD 0x65
 1016fd474 0x74000000  DCD 0x74
 1016fd478 0x74000000  DCD 0x74
 1016fd47c 0x69000000  DCD 0x69
 1016fd480 0x6e000000  DCD 0x6e
 1016fd484 0x67000000  DCD 0x67
 1016fd488 0x20000000  DCD 0x20
 1016fd48c 0x6e000000  DCD 0x6e
 1016fd490 0x65000000  DCD 0x65
 1016fd494 0x77000000  DCD 0x77
 1016fd498 0x20000000  DCD 0x20
 1016fd49c 0x76000000  DCD 0x76
 1016fd4a0 0x61000000  DCD 0x61
 1016fd4a4 0x6c000000  DCD 0x6c
 1016fd4a8 0x75000000  DCD 0x75
 1016fd4ac 0x65000000  DCD 0x65
 1016fd4b0 0x73000000  DCD 0x73
 1016fd4b4 0x2e000000  DCD 0x2e
 1016fd4b8 0x2e000000  DCD 0x2e
 1016fd4bc 0x2e000000  DCD 0x2e
 1016fd4c0 0xa0000000  DCD 0xa
 1016fd4c4 0x00000000  DCD 0x0
 1016fd4c8 0x00000000  DCD 0x0
L_str13:
 1016fd4cc 0x16000000  .quad 0x16
 1016fd4d0 0x00000000  ; (upper half)
 1016fd4d4 0x52000000  DCD 0x52
 1016fd4d8 0x65000000  DCD 0x65
 1016fd4dc 0x61000000  DCD 0x61
 1016fd4e0 0x64000000  DCD 0x64
 1016fd4e4 0x69000000  DCD 0x69
 1016fd4e8 0x6e000000  DCD 0x6e
 1016fd4ec 0x67000000  DCD 0x67
 1016fd4f0 0x20000000  DCD 0x20
 1016fd4f4 0x6e000000  DCD 0x6e
 1016fd4f8 0x65000000  DCD 0x65
 1016fd4fc 0x77000000  DCD 0x77
 1016fd500 0x20000000  DCD 0x20
 1016fd504 0x76000000  DCD 0x76
 1016fd508 0x61000000  DCD 0x61
 1016fd50c 0x6c000000  DCD 0x6c
 1016fd510 0x75000000  DCD 0x75
 1016fd514 0x65000000  DCD 0x65
 1016fd518 0x73000000  DCD 0x73
 1016fd51c 0x3a000000  DCD 0x3a
 1016fd520 0x20000000  DCD 0x20
 1016fd524 0x78000000  DCD 0x78
 1016fd528 0x3d000000  DCD 0x3d
 1016fd52c 0x00000000  DCD 0x0
 1016fd530 0x00000000  DCD 0x0
L_str14:
 1016fd534 0x20000000  .quad 0x2
 1016fd538 0x00000000  ; (upper half)
 1016fd53c 0xa0000000  DCD 0xa
 1016fd540 0xa0000000  DCD 0xa
 1016fd544 0x00000000  DCD 0x0
 1016fd548 0x00000000  DCD 0x0
L_str15:
 1016fd54c 0x24000000  .quad 0x24
 1016fd550 0x00000000  ; (upper half)
 1016fd554 0x32000000  DCD 0x32
 1016fd558 0x2e000000  DCD 0x2e
 1016fd55c 0x20000000  DCD 0x20
 1016fd560 0x49000000  DCD 0x49
 1016fd564 0x6e000000  DCD 0x6e
 1016fd568 0x68000000  DCD 0x68
 1016fd56c 0x65000000  DCD 0x65
 1016fd570 0x72000000  DCD 0x72
 1016fd574 0x69000000  DCD 0x69
 1016fd578 0x74000000  DCD 0x74
 1016fd57c 0x65000000  DCD 0x65
 1016fd580 0x64000000  DCD 0x64
 1016fd584 0x20000000  DCD 0x20
 1016fd588 0x43000000  DCD 0x43
 1016fd58c 0x6f000000  DCD 0x6f
 1016fd590 0x6c000000  DCD 0x6c
 1016fd594 0x6f000000  DCD 0x6f
 1016fd598 0x72000000  DCD 0x72
 1016fd59c 0x50000000  DCD 0x50
 1016fd5a0 0x6f000000  DCD 0x6f
 1016fd5a4 0x69000000  DCD 0x69
 1016fd5a8 0x6e000000  DCD 0x6e
 1016fd5ac 0x74000000  DCD 0x74
 1016fd5b0 0x20000000  DCD 0x20
 1016fd5b4 0x63000000  DCD 0x63
 1016fd5b8 0x6c000000  DCD 0x6c
 1016fd5bc 0x61000000  DCD 0x61
 1016fd5c0 0x73000000  DCD 0x73
 1016fd5c4 0x73000000  DCD 0x73
 1016fd5c8 0x20000000  DCD 0x20
 1016fd5cc 0x74000000  DCD 0x74
 1016fd5d0 0x65000000  DCD 0x65
 1016fd5d4 0x73000000  DCD 0x73
 1016fd5d8 0x74000000  DCD 0x74
 1016fd5dc 0x3a000000  DCD 0x3a
 1016fd5e0 0xa0000000  DCD 0xa
 1016fd5e4 0x00000000  DCD 0x0
 1016fd5e8 0x00000000  DCD 0x0
L_str16:
 1016fd5ec 0x80000000  .quad 0x8
 1016fd5f0 0x00000000  ; (upper half)
 1016fd5f4 0x2c000000  DCD 0x2c
 1016fd5f8 0x20000000  DCD 0x20
 1016fd5fc 0x63000000  DCD 0x63
 1016fd600 0x6f000000  DCD 0x6f
 1016fd604 0x6c000000  DCD 0x6c
 1016fd608 0x6f000000  DCD 0x6f
 1016fd60c 0x72000000  DCD 0x72
 1016fd610 0x3d000000  DCD 0x3d
 1016fd614 0x00000000  DCD 0x0
 1016fd618 0x00000000  DCD 0x0
L_str17:
 1016fd61c 0x1d000000  .quad 0x1d
 1016fd620 0x00000000  ; (upper half)
 1016fd624 0xa0000000  DCD 0xa
 1016fd628 0x54000000  DCD 0x54
 1016fd62c 0x65000000  DCD 0x65
 1016fd630 0x73000000  DCD 0x73
 1016fd634 0x74000000  DCD 0x74
 1016fd638 0x20000000  DCD 0x20
 1016fd63c 0x63000000  DCD 0x63
 1016fd640 0x6f000000  DCD 0x6f
 1016fd644 0x6d000000  DCD 0x6d
 1016fd648 0x70000000  DCD 0x70
 1016fd64c 0x6c000000  DCD 0x6c
 1016fd650 0x65000000  DCD 0x65
 1016fd654 0x74000000  DCD 0x74
 1016fd658 0x65000000  DCD 0x65
 1016fd65c 0x64000000  DCD 0x64
 1016fd660 0x20000000  DCD 0x20
 1016fd664 0x73000000  DCD 0x73
 1016fd668 0x75000000  DCD 0x75
 1016fd66c 0x63000000  DCD 0x63
 1016fd670 0x63000000  DCD 0x63
 1016fd674 0x65000000  DCD 0x65
 1016fd678 0x73000000  DCD 0x73
 1016fd67c 0x73000000  DCD 0x73
 1016fd680 0x66000000  DCD 0x66
 1016fd684 0x75000000  DCD 0x75
 1016fd688 0x6c000000  DCD 0x6c
 1016fd68c 0x6c000000  DCD 0x6c
 1016fd690 0x79000000  DCD 0x79
 1016fd694 0xa0000000  DCD 0xa
 1016fd698 0x00000000  DCD 0x0
 1016fd69c 0x00000000  DCD 0x0
ColorPoint_vtable:
 1016fd6a0 0x16f81d80  .quad ColorPoint::CREATE    ; Reloc -> 'ColorPoint::CREATE' @ 0x1016f81d8
 1016fd6a8 0x16f81740  .quad Point::RELEASE    ; Reloc -> 'Point::RELEASE' @ 0x1016f8174
 1016fd6b0 0x16f81140  .quad Point::getX    ; Reloc -> 'Point::getX' @ 0x1016f8114
 1016fd6b8 0x16f811c0  .quad Point::getY    ; Reloc -> 'Point::getY' @ 0x1016f811c
 1016fd6c0 0x16f81240  .quad Point::set    ; Reloc -> 'Point::set' @ 0x1016f8124
 1016fd6c8 0x16f82d40  .quad ColorPoint::setColor    ; Reloc -> 'ColorPoint::setColor' @ 0x1016f82d4
 1016fd6d0 0x16f82dc0  .quad ColorPoint::getColor    ; Reloc -> 'ColorPoint::getColor' @ 0x1016f82dc
Point_vtable:
 1016fd6d8 0x16f80480  .quad Point::CREATE    ; Reloc -> 'Point::CREATE' @ 0x1016f8048
 1016fd6e0 0x16f81740  .quad Point::RELEASE    ; Reloc -> 'Point::RELEASE' @ 0x1016f8174
 1016fd6e8 0x16f81140  .quad Point::getX    ; Reloc -> 'Point::getX' @ 0x1016f8114
 1016fd6f0 0x16f811c0  .quad Point::getY    ; Reloc -> 'Point::getY' @ 0x1016f811c
 1016fd6f8 0x16f81240  .quad Point::set    ; Reloc -> 'Point::set' @ 0x1016f8124

--------------------------

JIT runtime table populated with 123 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x1016f8348
[JITExecutor] Starting execution of JIT-compiled function at address: 0x1016f8348
SAMM: Entered scope (depth: 2)
Testing class member variable access with correct offsets
=================================================

1. Basic Point class test:
SAMM: Entered scope (depth: 3)
SAMM: Tracked allocation 0x6000037388e0 in scope (depth: 3, scope size: 1)
DEBUG: ListAtom allocated at 0x6000037388e0 (total atoms: 1)
Reading values: x=0, y=0
Setting new values...
Reading new values: x=100, y=200

2. Inherited ColorPoint class test:
SAMM: Tracked allocation 0x600003739f00 in scope (depth: 3, scope size: 2)
DEBUG: ListAtom allocated at 0x600003739f00 (total atoms: 2)
Point created at (130, 140)
ColorPoint created at (130, 140) with color 255
Reading values: x=130, y=140, color=255
Setting new values...
Reading new values: x=60, y=80, color=123

Test completed successfully
SAMM: Scope exit - found 2 objects to cleanup (remaining depth: 2)
SAMM: About to queue 2 objects for cleanup
SAMM: Queued objects for background cleanup (queue depth: 1)
SAMM: Notified background worker
JIT Execution completed with result: 4360994480
  Same value as double: 2.15462e-314
[JITExecutor] Execution completed. Result: 4360994480

--- JIT returned with result: 4360994480 ---
SAMM: Worker woke up, queue size: 1, running: YES
SAMM: Processing batch of 2 objects
SAMM: cleanupPointersImmediate called with 2 pointers
SAMM: Cleaning up pointer 0x6000037388e0
DEBUG: HeapManager::free called with payload=0x6000037388e0
DEBUG: Checking payload 0x6000037388e0 in Bloom filter
DEBUG: Checking base address 0x6000037388d8 in Bloom filter
DEBUG: Adding base address 0x6000037388e0 to Bloom filter

--- BCPL Runtime Metrics ---
Memory allocations: 2 (48 bytes)
Memory frees: 1 (24 bytes)
Vector allocations: 0
String allocations: 0
Double-free attempts: 0
Current active allocations: 1 (24 bytes)
Bloom filter statistics:
  Items tracked: 1
  Memory usage: 12000000 bytes
  False positives: 0
DEBUG: Fixed Bloom filter (12MB) now has ~1 items (capacity: 10M, estimated false positive rate: 0.0000%)
SAMM: Successfully cleaned pointer 0x6000037388e0
SAMM: Cleaning up pointer 0x600003739f00
DEBUG: HeapManager::free called with payload=0x600003739f00
DEBUG: Checking payload 0x600003739f00 in Bloom filter
DEBUG: Checking base address 0x600003739ef8 in Bloom filter
DEBUG: Adding base address 0x600003739f00 to Bloom filter
  Est. false positive rate: 0.0000%
File I/O operations:
  Files opened: 0
  Files closed: 0
  Bytes read: 0
  Bytes written: 0
  Open files: 0
--------------------------
SAMM: Processed all pending cleanup operations
DEBUG: Fixed Bloom filter (12MB) now has ~2 items (capacity: 10M, estimated false positive rate: 0.0000%)
SAMM: Successfully cleaned pointer 0x600003739f00
SAMM: cleanupPointersImmediate completed 2 items in 77.201 ms
SAMM: Background worker processed batch of 2 objects
SAMM: Background cleanup worker thread stopped (DEBUG)
SAMM: Background worker stopped
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: Shutdown complete
