Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=tests/bcl_tests/lists8.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.1721
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/tests/bcl_tests/lists8.bcl"
LET START() BE
$(
   LET L = LIST("a", "string", "list")
   FOREACH S IN L DO
   $( 
            WRITEF("String: %s *N", S)
   $)
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x102547818
Registered 91 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x10254654c | args: 0 | table_offset: 712
  FINISH           | address: 0x1025452fc | args: 0 | table_offset: 704
  FABS             | address: 0x1025456ac | args: 1 | table_offset: 672
  FSIN             | address: 0x102545670 | args: 1 | table_offset: 648
  FILE_EOF         | address: 0x102548964 | args: 1 | table_offset: 616
  RAND             | address: 0x1025454fc | args: 1 | table_offset: 624
  FILE_TELL        | address: 0x10254890c | args: 1 | table_offset: 608
  FILE_SEEK        | address: 0x102548848 | args: 3 | table_offset: 600
  FILE_WRITE       | address: 0x102548730 | args: 3 | table_offset: 592
  FIX              | address: 0x1025456ec | args: 1 | table_offset: 696
  FILE_READS       | address: 0x10254817c | args: 1 | table_offset: 576
  FILE_WRITES      | address: 0x102547ea0 | args: 2 | table_offset: 568
  FEXP             | address: 0x1025456d8 | args: 1 | table_offset: 688
  FILE_CLOSE       | address: 0x102547e34 | args: 1 | table_offset: 560
  FILE_OPEN_APPEND | address: 0x102547da4 | args: 1 | table_offset: 552
  SLURP            | address: 0x102545dd4 | args: 1 | table_offset: 520
  PACKSTRING       | address: 0x102545704 | args: 1 | table_offset: 504
  STRLEN           | address: 0x10254530c | args: 1 | table_offset: 496
  FCOS             | address: 0x102545684 | args: 1 | table_offset: 656
  STRCMP           | address: 0x10254536c | args: 2 | table_offset: 488
  STRCOPY          | address: 0x102545450 | args: 2 | table_offset: 480
  FIND             | address: 0x10254be8c | args: 3 | table_offset: 448
  DEEPCOPYLITERALLIST | address: 0x10254bb04 | args: 1 | table_offset: 432
  DEEPCOPYLIST     | address: 0x10254b96c | args: 1 | table_offset: 424
  COPYLIST         | address: 0x10254b86c | args: 1 | table_offset: 416
  CONCAT           | address: 0x10254bca4 | args: 2 | table_offset: 408
  BCPL_CONCAT_LISTS | address: 0x10254bca4 | args: 2 | table_offset: 400
  SPIT             | address: 0x102546300 | args: 2 | table_offset: 528
  JOIN             | address: 0x10254af08 | args: 2 | table_offset: 472
  LPND             | address: 0x10254b418 | args: 2 | table_offset: 392
  SPND             | address: 0x10254b348 | args: 2 | table_offset: 384
  FPND             | address: 0x10254b278 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x10254c35c | args: 1 | table_offset: 720
  BCPL_LIST_APPEND_INT | address: 0x10254b1a8 | args: 2 | table_offset: 344
  GETVEC           | address: 0x1025478dc | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x10250e814 | args: 0 | table_offset: 312
  APND             | address: 0x10254b1a8 | args: 2 | table_offset: 368
  HEAPMANAGER_ENTER_SCOPE | address: 0x10250e74c | args: 0 | table_offset: 280
  HEAPMANAGER_SETSAMMENABLED | address: 0x10250e6f8 | args: 1 | table_offset: 296
  HEAPMANAGER_EXIT_SCOPE | address: 0x10250e778 | args: 0 | table_offset: 288
  PIC_RUNTIME_HELPER | address: 0x102547990 | args: 0 | table_offset: 272
  OBJECT_HEAP_FREE | address: 0x102547954 | args: 1 | table_offset: 256
  OBJECT_HEAP_ALLOC | address: 0x102547930 | args: 1 | table_offset: 248
  BCPL_LIST_GET_REST | address: 0x10254b6d4 | args: 1 | table_offset: 216
  FRND             | address: 0x102545588 | args: 0 | table_offset: 640
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x10254b61c | args: 1 | table_offset: 200
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x10254b5b8 | args: 1 | table_offset: 192
  RUNTIME_METHOD_LOOKUP | address: 0x102547978 | args: 2 | table_offset: 264
  FREEVEC          | address: 0x102547818 | args: 1 | table_offset: 136
  BCPL_BOUNDS_ERROR | address: 0x1025437dc | args: 3 | table_offset: 184
  WRITEF4          | address: 0x102544e30 | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x10254c030 | args: 1 | table_offset: 144
  BCPL_ALLOC_CHARS | address: 0x1025477c0 | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x10254b278 | args: 2 | table_offset: 352
  GET_FREE_LIST_HEAD_ADDR | address: 0x10254c350 | args: 0 | table_offset: 328
  BCPL_GET_ATOM_TYPE | address: 0x10254b738 | args: 1 | table_offset: 224
  FWRITE           | address: 0x10254480c | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x10254b148 | args: 0 | table_offset: 336
  SPLIT            | address: 0x10254ab9c | args: 2 | table_offset: 464
  BCPL_FREE_CELLS  | address: 0x10254c34c | args: 0 | table_offset: 320
  RND              | address: 0x1025455dc | args: 1 | table_offset: 632
  HEAPMANAGER_ISSAMMENABLED | address: 0x10250e728 | args: 0 | table_offset: 304
  WRITEC           | address: 0x1025450ec | args: 1 | table_offset: 88
  MALLOC           | address: 0x102547760 | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x102547760 | args: 3 | table_offset: 104
  FTAN             | address: 0x102545698 | args: 1 | table_offset: 664
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 240
  BCPL_GET_LAST_ERROR | address: 0x10254365c | args: 1 | table_offset: 160
  RDCH             | address: 0x1025452b0 | args: 0 | table_offset: 96
  FILE_READ        | address: 0x10254861c | args: 3 | table_offset: 584
  UNPACKSTRING     | address: 0x102545a3c | args: 1 | table_offset: 512
  WRITEF5          | address: 0x102544ebc | args: 6 | table_offset: 64
  FILTER           | address: 0x10254bf80 | args: 2 | table_offset: 456
  BCPL_FREE_LIST_SAFE | address: 0x10254c138 | args: 1 | table_offset: 152
  FILE_OPEN_WRITE  | address: 0x102547d14 | args: 1 | table_offset: 544
  FILE_OPEN_READ   | address: 0x102547994 | args: 1 | table_offset: 536
  BCPL_LIST_GET_NTH | address: 0x10254b7a0 | args: 2 | table_offset: 232
  WRITEF7          | address: 0x102544ff8 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x102544db0 | args: 4 | table_offset: 48
  WRITEF6          | address: 0x102544f54 | args: 7 | table_offset: 72
  REVERSE          | address: 0x10254bda4 | args: 1 | table_offset: 440
  WRITEF2          | address: 0x102544d3c | args: 3 | table_offset: 40
  WRITEF1          | address: 0x102544cd4 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x10254b684 | args: 1 | table_offset: 208
  BCPL_CLEAR_ERRORS | address: 0x10254370c | args: 0 | table_offset: 168
  WRITEF           | address: 0x102544850 | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x10254b348 | args: 2 | table_offset: 360
  WRITES           | address: 0x10254459c | args: 1 | table_offset: 0
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x10254c3a4 | args: 0 | table_offset: 176
  FLOG             | address: 0x1025456c4 | args: 1 | table_offset: 680
  WRITEN           | address: 0x1025450a8 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                ListExpression:
                  Initializers:
                    StringLiteral: "a"
                    StringLiteral: "string"
                    StringLiteral: "list"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                ListExpression:
                  Initializers:
                    StringLiteral: "a"
                    StringLiteral: "string"
                    StringLiteral: "list"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: L as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing foreach statement, loop variable: S
[SymbolDiscoveryPass] Added foreach loop variable: S
[SymbolDiscoveryPass] Entering block scope

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'S' (LOCAL_VAR, UNKNOWN, scope=2, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 2 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[DEBUG] ListExpression: contains_literals = true, num_initializers = 3
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE] Pushed FOREACH loop context. Context stack size: 1
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 1
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[DEBUG get_variable_type] Looking for 'L' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Found in variable_types: L -> 1050628
[DEBUG FOREACH] Set variable_types[S] = 4 (STRING) in function START
[ANALYZER TRACE] Entering block scope: START_block_0_block_1 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x10349c840
[ANALYZER TRACE] WRITEF format specifiers detected: [%s] (count = 1)
[DEBUG get_variable_type] Looking for 'S' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 2
[DEBUG get_variable_type] Found in variable_types: S -> 4
[ANALYZER TRACE]   Detected call to runtime function: WRITEF, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S
[DEBUG get_effective_variable_name] Called with: 'S'
[DEBUG get_effective_variable_name] Loop context stack size: 1
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S'
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Popped FOREACH loop context. Context stack size: 0
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 0
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 0
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 2
  Float Locals: 0
  Runtime Calls: 1
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 5 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 5 for function 'START'
[CFGBuilderPass] Starting block 1 variable tracking
[CFGBuilderPass] Tracking variable 'L' in current block
[CFGBuilderPass] visit(ForEachStatement) entered.
[DEBUG get_variable_type] Looking for 'L' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 2
[DEBUG get_variable_type] Found in variable_types: L -> 1050628
[CFGBuilderPass] OPTIMIZATION: Using direct variable 'L' for list FOREACH instead of creating a temporary header.
[CFGBuilderPass] Created new basic block: START_ForEachHeader_1
[CFGBuilderPass] Created new basic block: START_ForEachBody_2
[CFGBuilderPass] Created new basic block: START_ForEachExit_3
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 6 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 6 for function 'START'
[CFGBuilderPass] Starting block 2 variable tracking
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 7 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 7 for function 'START'
[CFGBuilderPass] Created new basic block: START_ForEachAdvance_4
[CFGBuilderPass] Correctly built low-level CFG for list-based FOREACH.
[CFGBuilderPass] visit(ForEachStatement) exiting.
[CFGBuilderPass] Generating normal block-end cleanup for 1 variables
[CFGBuilderPass] Generating block-end cleanup for: L
[CFGBuilderPass] Skipping BCPL_FREE_LIST(L) - SAMM is active
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 8 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 8 for function 'START'
[CFGBuilderPass] Created new basic block: START_Exit_5
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 0
  Edges redirected: 0
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 6 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_5) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_5
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_5 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_5
[LivenessAnalysisPass] Analyzing block #2 (id=START_ForEachAdvance_4) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachAdvance_4
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachAdvance_4 with 1 statements
[LivenessAnalysisPass] Statement uses variables: _forEach_cursor_0 
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachAdvance_4
[LivenessAnalysisPass] Analyzing block #3 (id=START_ForEachBody_2) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachBody_2
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachBody_2 with 4 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: S 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Variables used after call: S 
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _forEach_cursor_0 
[LivenessAnalysisPass] Variables used after call: _forEach_cursor_0 
[LivenessAnalysisPass] Intra-block call interval detected in START_ForEachBody_2 - variables live across calls: S _forEach_cursor_0 
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachBody_2
[LivenessAnalysisPass] Analyzing block #4 (id=START_ForEachHeader_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachHeader_1
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachHeader_1 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachHeader_1
[LivenessAnalysisPass] Analyzing block #5 (id=START_ForEachExit_3) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachExit_3
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachExit_3 with 1 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block START_ForEachExit_3 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachExit_3
[LivenessAnalysisPass] Analyzing block #6 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 3 statements
[LivenessAnalysisPass] Statement uses variables: L 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_ForEachAdvance_4 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachBody_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachBody_2 - adding 1 live-out variables and 2 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Exit_5 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachExit_3 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachExit_3 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_ForEachHeader_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_ForEachAdvance_4 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachBody_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachBody_2 - adding 2 live-out variables and 2 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Exit_5 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachExit_3 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachExit_3 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_ForEachHeader_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 3
[LivenessAnalysisPass] Processing block: START_ForEachAdvance_4 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachBody_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachBody_2 - adding 2 live-out variables and 2 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Exit_5 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachExit_3 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachExit_3 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_ForEachHeader_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_5
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_ForEachAdvance_4
  Use: { _forEach_cursor_0 }
  Def: { _forEach_cursor_0 }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }
Block ID: START_ForEachBody_2
  Use: { S _forEach_cursor_0 }
  Def: { S }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }
Block ID: START_ForEachHeader_1
  Use: { _forEach_cursor_0 }
  Def: { }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }
Block ID: START_ForEachExit_3
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { }
  Def: { L _forEach_cursor_0 }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_5 (conceptual)

Block ID: START_Exit_5 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_ForEachExit_3

Block ID: START_ForEachAdvance_4
  Statements:
    - AssignmentStmt
  Successors: START_ForEachHeader_1
  Predecessors: START_ForEachBody_2

Block ID: START_ForEachBody_2
  Statements:
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_ForEachAdvance_4
  Predecessors: START_ForEachHeader_1

Block ID: START_ForEachHeader_1
  Statements:
    - ConditionalBranchStmt
  Successors: START_ForEachBody_2, START_ForEachExit_3
  Predecessors: START_Entry_0, START_ForEachAdvance_4

Block ID: START_ForEachExit_3
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_5
  Predecessors: START_ForEachHeader_1

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - AssignmentStmt
  Successors: START_ForEachHeader_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                ListExpression:
                  Initializers:
                    StringLiteral: "a"
                    StringLiteral: "string"
                    StringLiteral: "list"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[LiveIntervalPass] Created 3 intervals for function: START
  S: [0-15]
  _forEach_cursor_0: [0-15]
  L: [1-2]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 5 6 7 8 
[Allocator] Partitioned: 2 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing S [0-15]
  Assigned callee-saved register X27 to S
[ALLOC] Updated allocations for S: spilled=0, register='X27'
[Allocator] Allocating call-crossing _forEach_cursor_0 [0-15]
  Assigned callee-saved register X26 to _forEach_cursor_0
[ALLOC] Updated allocations for _forEach_cursor_0: spilled=0, register='X26'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only L [1-2]
  Assigned register X15 to L
[ALLOC] Updated allocations for L: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  L: reg X15 (caller-saved) [local-only]
  S: reg X27 (callee-saved) [call-crossing]
  _forEach_cursor_0: reg X26 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 3
  Float Locals: 0
  Runtime Calls: 1
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 2
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4421337088
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 1 unique external functions:
[DEBUG]   - WRITEF
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] WRITEF detected, adding WRITEF1-WRITEF7 variants...
[VeneerManager] Generating 10 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITEF_veneer for function: WRITEF
[VeneerManager] Created veneer: WRITEF1_veneer for function: WRITEF1
[VeneerManager] Created veneer: WRITEF2_veneer for function: WRITEF2
[VeneerManager] Created veneer: WRITEF3_veneer for function: WRITEF3
[VeneerManager] Created veneer: WRITEF4_veneer for function: WRITEF4
[VeneerManager] Created veneer: WRITEF5_veneer for function: WRITEF5
[VeneerManager] Created veneer: WRITEF6_veneer for function: WRITEF6
[VeneerManager] Created veneer: WRITEF7_veneer for function: WRITEF7
[VeneerManager] Generated 10 veneers, estimated total size: 200 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: START
[SYNC] Found 3 variable allocations
[SYNC] Reserved register X15 for variable L
[SYNC] Reserved register X27 for variable S
[SYNC] Reserved register X26 for variable _forEach_cursor_0
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 3
[DEBUG] DEBUG: variable_types['L'] = POINTER_TO|LIST|STRING
[DEBUG] DEBUG: variable_types['S'] = STRING
[DEBUG] DEBUG: variable_types['_forEach_cursor_0'] = POINTER_TO|LIST
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'L' of type 1050628 at offset 16 (size 8)
[DEBUG] Registered local 'L' from analyzer metrics.
Added local variable 'S' of type 4 at offset 24 (size 8)
[DEBUG] Registered local 'S' from analyzer metrics.
Added local variable '_forEach_cursor_0' of type 1050624 at offset 32 (size 8)
[DEBUG] Registered local '_forEach_cursor_0' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 80 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S                              | STRING
+32      | Local: _forEach_cursor_0              | POINTER_TO|LIST
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X26                        | UNKNOWN
+64      | Saved Reg: X27                        | UNKNOWN
+72      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+80 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-80]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #56] ; Saved Reg: X26 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #64] ; Saved Reg: X27 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #72] ; Saved Reg: X28 @ FP+72
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 80 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S                              | STRING
+32      | Local: _forEach_cursor_0              | POINTER_TO|LIST
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X26                        | UNKNOWN
+64      | Saved Reg: X27                        | UNKNOWN
+72      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+80 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting ListExpression node.
[DEBUG] List is constant. Using static template generation.
[DataGenerator TRACE] add_list_literal called. Generated Key: "list[string(a),string(string),string(list)]"
[DataGenerator TRACE] >> Cache MISS. Generating new labels.
[DEBUG LEVEL 5] Emitting instruction: ADRP X0, L_list0_header
[DEBUG LEVEL 5] Emitting instruction: ADD X0, X0, #:lo12:L_list0_header
[DEBUG LEVEL 5] Emitting instruction: BL DEEPCOPYLITERALLIST
[DEBUG] Emitted deep copy logic for LIST.
[DEBUG] Handling assignment for variable: L
[DEBUG] store_variable_register for 'L' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'L' lives in X15. Emitting MOV.
[DEBUG]   [LOOP VAR PROTECTION] Extra protection for loop variable: L
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0
[DEBUG]   Updating home register X15 for variable 'L' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X15, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting UnaryOp node.
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1050628, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X15
[DEBUG] Variable 'L' value loaded into X15
[DEBUG]   [DEBUG] get_variable_register returned: 'X15'
[DEBUG] LEFT side evaluation complete. left_reg = 'X15'
[DEBUG] OPTIMIZATION: Right operand is constant: 16
[DEBUG] Checking type promotion: left_reg=X15, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X15
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #16
[DEBUG] OPTIMIZATION: Generated ADD with immediate: 16
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X9
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #0]
[DEBUG] Handling assignment for variable: _forEach_cursor_0
[DEBUG] store_variable_register for '_forEach_cursor_0' from register 'X10'
[DEBUG]   [ALLOCATOR HIT] Variable '_forEach_cursor_0' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X10
[DEBUG]   Updating home register X26 for variable '_forEach_cursor_0' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X10
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X26, X10
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachHeader_1
[DEBUG LEVEL 5] Emitting instruction: B .L0
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting UnaryOp node.
[DEBUG] Generating INLINE code for hybrid static/runtime REST operation.
[DEBUG] Visiting VariableAccess node for '_forEach_cursor_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_forEach_cursor_0' in function 'START'
[DEBUG] get_variable_register for: '_forEach_cursor_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_forEach_cursor_0' lives in register X26
[DEBUG] Variable '_forEach_cursor_0' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] REST operand is statically known as a List Node. Generating direct next-ptr load.
[DEBUG LEVEL 5] Emitting instruction: CMP X26, #0
[DEBUG LEVEL 5] Emitting instruction: B.EQ .L2
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X26, #16]
[DEBUG LEVEL 5] Emitting instruction: B .L1
[DEBUG LEVEL 5] Emitting instruction: MOV X9, XZR
[DEBUG] Handling assignment for variable: _forEach_cursor_0
[DEBUG] store_variable_register for '_forEach_cursor_0' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable '_forEach_cursor_0' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG]   Updating home register X26 for variable '_forEach_cursor_0' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X26, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachHeader_1
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting UnaryOp node.
[DEBUG] Generating INLINE code for hybrid static/runtime HD operation.
[DEBUG] Visiting VariableAccess node for '_forEach_cursor_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_forEach_cursor_0' in function 'START'
[DEBUG] get_variable_register for: '_forEach_cursor_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_forEach_cursor_0' lives in register X26
[DEBUG] Variable '_forEach_cursor_0' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] HD operand is statically known as a List Node. Generating direct load.
[DEBUG LEVEL 5] Emitting instruction: CMP X26, #0
[DEBUG LEVEL 5] Emitting instruction: B.EQ .L4
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X26, #8]
[DEBUG LEVEL 5] Emitting instruction: B .L3
[DEBUG LEVEL 5] Emitting instruction: MOV X9, XZR
[DEBUG] Handling assignment for variable: S
[DEBUG] store_variable_register for 'S' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable 'S' lives in X27. Emitting MOV.
[DEBUG]   [LOOP VAR PROTECTION] Extra protection for loop variable: S
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X9
[DEBUG]   Updating home register X27 for variable 'S' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X9
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X27, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'String: %s 
'.
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Visiting VariableAccess node for 'S'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S' in function 'START'
[DEBUG] get_variable_register for: 'S' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S' lives in register X27
[DEBUG] Variable 'S' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X27
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF1_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachAdvance_4
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_5
[DEBUG] Visiting ConditionalBranchStatement (codegen is handled by block epilogue).
[DEBUG] Visiting VariableAccess node for '_forEach_cursor_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_forEach_cursor_0' in function 'START'
[DEBUG] get_variable_register for: '_forEach_cursor_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_forEach_cursor_0' lives in register X26
[DEBUG] Variable '_forEach_cursor_0' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: CMP X26, XZR
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_ForEachExit_3
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachBody_2
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str3
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 1
[DataGenerator TRACE] >> Processing header: L_list0_header
[DataGenerator TRACE]   Internal nodes vector size: 3
[DataGenerator TRACE]   --- Dumping Node Labels ---
[DataGenerator TRACE]     -> L_list0_node_0
[DataGenerator TRACE]     -> L_list0_node_1
[DataGenerator TRACE]     -> L_list0_node_2
[DataGenerator TRACE]   --- End Dump ---
[InstructionStream TRACE] Adding label definition: L_list0_header
[InstructionStream TRACE] Adding label definition: L_list0_node_0
[InstructionStream TRACE] Adding label definition: L_list0_node_1
[InstructionStream TRACE] Adding label definition: L_list0_node_2
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, POINTER_TO|LIST|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'S' (LOCAL_VAR, STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol '_forEach_cursor_0' (LOCAL_VAR, POINTER_TO|LIST, scope=1, block=0, class_name='', function_name='START')

Data sections generated.

=== Peephole Optimization ===
Analyzing 201 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 55
  Before:
    STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40  [Opcode=26, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
    STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48  [Opcode=26, Dest=-1, Src1=20, Imm=48, Base=29, Offset=48]
  After:
    STP x19, x20, [x29, #40]  [Opcode=30, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 56
  Before:
    STR X26, [X29, #56] ; Saved Reg: X26 @ FP+56  [Opcode=26, Dest=-1, Src1=26, Imm=56, Base=29, Offset=56]
    STR X27, [X29, #64] ; Saved Reg: X27 @ FP+64  [Opcode=26, Dest=-1, Src1=27, Imm=64, Base=29, Offset=64]
  After:
    STP x26, x27, [x29, #56]  [Opcode=30, Dest=-1, Src1=26, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 111
  Before:
    LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40  [Opcode=27, Dest=19, Src1=-1, Imm=40, Base=29, Offset=40]
    LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48  [Opcode=27, Dest=20, Src1=-1, Imm=48, Base=29, Offset=48]
  After:
    LDP x19, x20, [x29, #40]  [Opcode=31, Dest=19, Src1=20, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 112
  Before:
    LDR X26, [X29, #56] ; Restored Reg: X26 @ FP+56  [Opcode=27, Dest=26, Src1=-1, Imm=56, Base=29, Offset=56]
    LDR X27, [X29, #64] ; Restored Reg: X27 @ FP+64  [Opcode=27, Dest=27, Src1=-1, Imm=64, Base=29, Offset=64]
  After:
    LDP x26, x27, [x29, #56]  [Opcode=31, Dest=26, Src1=27, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 115
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [x31]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 201
  Instructions after:  196
  Total optimizations: 5
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 3
    - Combine adjacent X-register STRs into STP: 2
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x107884000) ---
Address Hex Code    Assembly
--------------------------------------------------
 107884000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 107884004 0xd29ce990  MOVZ X16, #59212
 107884008 0xf2a04a10  MOVK X16, #592, LSL #16
 10788400c 0xf2c00030  MOVK X16, #1, LSL #32
 107884010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 107884014 0xd29cef10  MOVZ X16, #59256
 107884018 0xf2a04a10  MOVK X16, #592, LSL #16
 10788401c 0xf2c00030  MOVK X16, #1, LSL #32
 107884020 0xd61f0200  BR X16
WRITEF_veneer:
 107884024 0xd2890a10  MOVZ X16, #18512
 107884028 0xf2a04a90  MOVK X16, #596, LSL #16
 10788402c 0xf2c00030  MOVK X16, #1, LSL #32
 107884030 0xd61f0200  BR X16
WRITEF1_veneer:
 107884034 0xd2899a90  MOVZ X16, #19668
 107884038 0xf2a04a90  MOVK X16, #596, LSL #16
 10788403c 0xf2c00030  MOVK X16, #1, LSL #32
 107884040 0xd61f0200  BR X16
WRITEF2_veneer:
 107884044 0xd289a790  MOVZ X16, #19772
 107884048 0xf2a04a90  MOVK X16, #596, LSL #16
 10788404c 0xf2c00030  MOVK X16, #1, LSL #32
 107884050 0xd61f0200  BR X16
WRITEF3_veneer:
 107884054 0xd289b610  MOVZ X16, #19888
 107884058 0xf2a04a90  MOVK X16, #596, LSL #16
 10788405c 0xf2c00030  MOVK X16, #1, LSL #32
 107884060 0xd61f0200  BR X16
WRITEF4_veneer:
 107884064 0xd289c610  MOVZ X16, #20016
 107884068 0xf2a04a90  MOVK X16, #596, LSL #16
 10788406c 0xf2c00030  MOVK X16, #1, LSL #32
 107884070 0xd61f0200  BR X16
WRITEF5_veneer:
 107884074 0xd289d790  MOVZ X16, #20156
 107884078 0xf2a04a90  MOVK X16, #596, LSL #16
 10788407c 0xf2c00030  MOVK X16, #1, LSL #32
 107884080 0xd61f0200  BR X16
WRITEF6_veneer:
 107884084 0xd289ea90  MOVZ X16, #20308
 107884088 0xf2a04a90  MOVK X16, #596, LSL #16
 10788408c 0xf2c00030  MOVK X16, #1, LSL #32
 107884090 0xd61f0200  BR X16
WRITEF7_veneer:
 107884094 0xd289ff10  MOVZ X16, #20472
 107884098 0xf2a04a90  MOVK X16, #596, LSL #16
 10788409c 0xf2c00030  MOVK X16, #1, LSL #32
 1078840a0 0xd61f0200  BR X16
 1078840a4 0x00000000  ; --- End Veneer Section ---

START:
 1078840a8 0xa9bb7bfd  STP X29, X30, [SP, #-80]!
 1078840ac 0x910003fd  MOV X29, SP
 1078840b0 0xa902d3b3  STP x19, x20, [x29, #40]
 1078840b4 0xa903efba  STP x26, x27, [x29, #56]
 1078840b8 0xf90027bc  STR X28, [X29, #72] ; Saved Reg: X28 @ FP+72
 1078840bc 0xd290001c  MOVZ X28, #32768
 1078840c0 0xf2a05a3c  MOVK X28, #721, LSL #16
 1078840c4 0xf2c0003c  MOVK X28, #1, LSL #32
 1078840c8 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 1078840cc 0x97ffffce  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x107884004
 1078840d0 0xb0000020  ADRP X0, L_list0_header    ; Reloc -> 'L_list0_header' @ 0x10788909c
 1078840d4 0x91027000  ADD X0, X0, #:lo12:L_list0_header    ; Reloc -> 'L_list0_header' @ 0x10788909c
 1078840d8 0x96b31e8b  BL DEEPCOPYLITERALLIST    ; Reloc -> 'DEEPCOPYLITERALLIST' @ 0x10254bb04
 1078840dc 0xaa0003ef  MOV X15, X0
 1078840e0 0xaa0f03e9  MOV X9, X15
 1078840e4 0x91004129  ADD X9, X9, #16
 1078840e8 0xf940012a  LDR X10, [X9, #0]
 1078840ec 0xaa0a03fa  MOV X26, X10
 1078840f0 0x1400001a  B START_ForEachHeader_1    ; Reloc -> 'START_ForEachHeader_1' @ 0x107884158
START_Exit_5:
 1078840f4 0x1400001c  B .L0    ; Reloc -> '.L0' @ 0x107884164
START_ForEachAdvance_4:
 1078840f8 0xf100035f  CMP X26, #0
 1078840fc 0x54000060  B.EQ .L2    ; Reloc -> '.L2' @ 0x107884108
 107884100 0xf9400b49  LDR X9, [X26, #16]
 107884104 0x14000002  B .L1    ; Reloc -> '.L1' @ 0x10788410c
.L2:
 107884108 0xaa1f03e9  MOV X9, XZR
.L1:
 10788410c 0xaa0903fa  MOV X26, X9
 107884110 0x14000012  B START_ForEachHeader_1    ; Reloc -> 'START_ForEachHeader_1' @ 0x107884158
START_ForEachBody_2:
 107884114 0xf100035f  CMP X26, #0
 107884118 0x54000060  B.EQ .L4    ; Reloc -> '.L4' @ 0x107884124
 10788411c 0xf9400749  LDR X9, [X26, #8]
 107884120 0x14000002  B .L3    ; Reloc -> '.L3' @ 0x107884128
.L4:
 107884124 0xaa1f03e9  MOV X9, XZR
.L3:
 107884128 0xaa0903fb  MOV X27, X9
 10788412c 0x97ffffb6  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x107884004
 107884130 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x10788905c
 107884134 0x91017129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x10788905c
 107884138 0x91002129  ADD X9, X9, #8
 10788413c 0xaa0903e0  MOV X0, X9
 107884140 0xaa1b03e1  MOV X1, X27
 107884144 0x97ffffbc  BL WRITEF1_veneer    ; Reloc -> 'WRITEF1_veneer' @ 0x107884034
 107884148 0x97ffffb3  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x107884014
 10788414c 0x17ffffeb  B START_ForEachAdvance_4    ; Reloc -> 'START_ForEachAdvance_4' @ 0x1078840f8
START_ForEachExit_3:
 107884150 0x97ffffb1  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x107884014
 107884154 0x17ffffe8  B START_Exit_5    ; Reloc -> 'START_Exit_5' @ 0x1078840f4
START_ForEachHeader_1:
 107884158 0xeb1f035f  CMP X26, XZR
 10788415c 0x54ffffa0  B.EQ START_ForEachExit_3    ; Reloc -> 'START_ForEachExit_3' @ 0x107884150
 107884160 0x17ffffed  B START_ForEachBody_2    ; Reloc -> 'START_ForEachBody_2' @ 0x107884114
.L0:
 107884164 0xa942d3b3  LDP x19, x20, [x29, #40]
 107884168 0xa943efba  LDP x26, x27, [x29, #56]
 10788416c 0xf94027bc  LDR X28, [X29, #72] ; Restored Reg: X28 @ FP+72
 107884170 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 107884174 0xa9407bfd  LDP x29, x30, [x31]
 107884178 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10788417c 0xd65f03c0  RET
L_str0:
 107889000 0x10000000  .quad 0x1
 107889004 0x00000000  ; (upper half)
 107889008 0x61000000  DCD 0x61
 10788900c 0x00000000  DCD 0x0
 107889010 0x00000000  DCD 0x0
L_str1:
 107889014 0x60000000  .quad 0x6
 107889018 0x00000000  ; (upper half)
 10788901c 0x73000000  DCD 0x73
 107889020 0x74000000  DCD 0x74
 107889024 0x72000000  DCD 0x72
 107889028 0x69000000  DCD 0x69
 10788902c 0x6e000000  DCD 0x6e
 107889030 0x67000000  DCD 0x67
 107889034 0x00000000  DCD 0x0
 107889038 0x00000000  DCD 0x0
L_str2:
 10788903c 0x40000000  .quad 0x4
 107889040 0x00000000  ; (upper half)
 107889044 0x6c000000  DCD 0x6c
 107889048 0x69000000  DCD 0x69
 10788904c 0x73000000  DCD 0x73
 107889050 0x74000000  DCD 0x74
 107889054 0x00000000  DCD 0x0
 107889058 0x00000000  DCD 0x0
L_str3:
 10788905c 0xc0000000  .quad 0xc
 107889060 0x00000000  ; (upper half)
 107889064 0x53000000  DCD 0x53
 107889068 0x74000000  DCD 0x74
 10788906c 0x72000000  DCD 0x72
 107889070 0x69000000  DCD 0x69
 107889074 0x6e000000  DCD 0x6e
 107889078 0x67000000  DCD 0x67
 10788907c 0x3a000000  DCD 0x3a
 107889080 0x20000000  DCD 0x20
 107889084 0x25000000  DCD 0x25
 107889088 0x73000000  DCD 0x73
 10788908c 0x20000000  DCD 0x20
 107889090 0xa0000000  DCD 0xa
 107889094 0x00000000  DCD 0x0
 107889098 0x00000000  DCD 0x0
L_list0_header:
 10788909c 0x00000000  DCD 0x0
 1078890a0 0x00000000  DCD 0x0
 1078890a4 0x78890ec0  .quad L_list0_node_2    ; Reloc -> 'L_list0_node_2' @ 0x1078890ec
 1078890ac 0x78890bc0  .quad L_list0_node_0    ; Reloc -> 'L_list0_node_0' @ 0x1078890bc
 1078890b4 0x30000000  .quad 0x3
 1078890b8 0x00000000  ; (upper half)
L_list0_node_0:
 1078890bc 0x30000000  DCD 0x3
 1078890c0 0x00000000  DCD 0x0
 1078890c4 0x78890000  .quad L_str0    ; Reloc -> 'L_str0' @ 0x107889000
 1078890cc 0x78890d40  .quad L_list0_node_1    ; Reloc -> 'L_list0_node_1' @ 0x1078890d4
L_list0_node_1:
 1078890d4 0x30000000  DCD 0x3
 1078890d8 0x00000000  DCD 0x0
 1078890dc 0x78890140  .quad L_str1    ; Reloc -> 'L_str1' @ 0x107889014
 1078890e4 0x78890ec0  .quad L_list0_node_2    ; Reloc -> 'L_list0_node_2' @ 0x1078890ec
L_list0_node_2:
 1078890ec 0x30000000  DCD 0x3
 1078890f0 0x00000000  DCD 0x0
 1078890f4 0x788903c0  .quad L_str2    ; Reloc -> 'L_str2' @ 0x10788903c
 1078890fc 0x00000000  .quad 0x0
 107889100 0x00000000  ; (upper half)

--------------------------

JIT runtime table populated with 123 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x1078840a8
[JITExecutor] Starting execution of JIT-compiled function at address: 0x1078840a8
SAMM: Entered scope (depth: 2)
SAMM: Tracked freelist allocation 0x103499e10 in scope (depth: 2, scope size: 1)
SAMM: Tracked list allocation 0x103499e10 in scope (depth: 2, scope size: 2)
BCPL String Optimizations: Initialized (pool + SIMD)
SAMM: Tracked string pool allocation 0xadb0777dc in scope (depth: 2, scope size: 3)
SAMM: Tracked string pool allocation 0xadb0777a0 in scope (depth: 2, scope size: 4)
SAMM: Tracked string pool allocation 0xadb077764 in scope (depth: 2, scope size: 5)
SAMM: Entered scope (depth: 3)
String:  
SAMM: Scope exit - found 0 objects to cleanup (remaining depth: 2)
SAMM: No objects to cleanup in this scope
SAMM: Entered scope (depth: 3)
String:  
SAMM: Scope exit - found 0 objects to cleanup (remaining depth: 2)
SAMM: No objects to cleanup in this scope
SAMM: Entered scope (depth: 3)
String:  
SAMM: Scope exit - found 0 objects to cleanup (remaining depth: 2)
SAMM: No objects to cleanup in this scope
SAMM: Scope exit - found 5 objects to cleanup (remaining depth: 1)
SAMM: About to queue 5 objects for cleanup
SAMM: Queued objects for background cleanup (queue depth: 1)
SAMM: Notified background worker
JIT Execution completed with result: 4463279984
  Same value as double: 2.20515e-314
[JITExecutor] Execution completed. Result: 4463279984

--- JIT returned with result: 4463279984 ---
SAMM: Worker woke up, queue size: 1, running: YES
SAMM: Processing batch of 5 objects
SAMM: cleanupPointersImmediate called with 5 pointers
SAMM: Cleaning up pointer 0x103499e10
SAMM: Freeing list header 0x103499e10 and returning all atoms to freelist
SAMM: Successfully cleaned pointer 0x103499e10
SAMM: Cleaning up pointer 0x103499e10
SAMM: Ignoring free() for 0x103499e10 - already freed by SAMM
SAMM: Successfully cleaned pointer 0x103499e10
SAMM: Cleaning up pointer 0xadb0777dc
SAMM: Returning string pool allocation 0xadb0777dc to pool for reuse
SAMM: Successfully cleaned pointer 0xadb0777dc
SAMM: Cleaning up pointer 0xadb0777a0
SAMM: Returning string pool allocation 0xadb0777a0 to pool for reuse
SAMM: Successfully cleaned pointer 0xadb0777a0
SAMM: Cleaning up pointer 0xadb077764
SAMM: Returning string pool allocation 0xadb077764 to pool for reuse
SAMM: Successfully cleaned pointer 0xadb077764
SAMM: cleanupPointersImmediate completed 5 items in 0.007 ms
SAMM: Background worker processed batch of 5 objects
SAMM: Worker waiting for cleanup queue (queue size: 0)

--- BCPL Runtime Metrics ---
Memory allocations: 0 (0 bytes)
Memory frees: 0 (0 bytes)
Vector allocations: 0
String allocations: 0
Double-free attempts: 0
Current active allocations: 0 (0 bytes)
Bloom filter statistics:
  Items tracked: 0
  Memory usage: 12000000 bytes
  False positives: 0
  Est. false positive rate: 0.0000%
File I/O operations:
  Files opened: 0
  Files closed: 0
  Bytes read: 0
  Bytes written: 0
  Open files: 0
--------------------------
SAMM: Processed all pending cleanup operations
SAMM: Worker woke up, queue size: 0, running: NO
SAMM: Background cleanup worker thread stopped (DEBUG)
SAMM: Background worker stopped
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: Shutdown complete
