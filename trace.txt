NeonReducerRegistry: Registered 13 NEON reduction encoders
Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=test_pairwise_liveness_fix.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.2257
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/test_pairwise_liveness_fix.bcl"
LET START() BE {

    WRITEF("Testing Pairwise Operation Liveness Fix*N")

    LET vec_a = FPAIRS 4  // First vector - should stay live until PAIRWISE_MIN
    LET vec_b = FPAIRS 4  // Second vector - should stay live until PAIRWISE_MIN

    // Initialize vectors with test data
    vec_a!0 := FPAIR(2.0, 3.0)


//    LET result_min = PAIRWISE_MIN(vec_a, vec_b)

//    WRITEF("%Q", vec_a!0)

}

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x102bbf914
Registered 92 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x102bbe648 | args: 0 | table_offset: 720
  FINISH           | address: 0x102bbd3f8 | args: 0 | table_offset: 712
  FABS             | address: 0x102bbd7a8 | args: 1 | table_offset: 680
  FSIN             | address: 0x102bbd76c | args: 1 | table_offset: 656
  FILE_EOF         | address: 0x102bc0b00 | args: 1 | table_offset: 624
  RAND             | address: 0x102bbd5f8 | args: 1 | table_offset: 632
  FILE_TELL        | address: 0x102bc0aa8 | args: 1 | table_offset: 616
  FILE_SEEK        | address: 0x102bc09e4 | args: 3 | table_offset: 608
  FILE_WRITE       | address: 0x102bc08cc | args: 3 | table_offset: 600
  FIX              | address: 0x102bbd7e8 | args: 1 | table_offset: 704
  FILE_READS       | address: 0x102bc0318 | args: 1 | table_offset: 584
  FILE_WRITES      | address: 0x102bc003c | args: 2 | table_offset: 576
  FEXP             | address: 0x102bbd7d4 | args: 1 | table_offset: 696
  FILE_CLOSE       | address: 0x102bbffd0 | args: 1 | table_offset: 568
  FILE_OPEN_APPEND | address: 0x102bbff40 | args: 1 | table_offset: 560
  PACKSTRING       | address: 0x102bbd800 | args: 1 | table_offset: 512
  STRLEN           | address: 0x102bbd408 | args: 1 | table_offset: 504
  FCOS             | address: 0x102bbd780 | args: 1 | table_offset: 664
  STRCMP           | address: 0x102bbd468 | args: 2 | table_offset: 496
  STRCOPY          | address: 0x102bbd54c | args: 2 | table_offset: 488
  FIND             | address: 0x102bc4204 | args: 3 | table_offset: 456
  DEEPCOPYLITERALLIST | address: 0x102bc3e7c | args: 1 | table_offset: 440
  DEEPCOPYLIST     | address: 0x102bc3ce4 | args: 1 | table_offset: 432
  COPYLIST         | address: 0x102bc3be4 | args: 1 | table_offset: 424
  CONCAT           | address: 0x102bc401c | args: 2 | table_offset: 416
  BCPL_CONCAT_LISTS | address: 0x102bc401c | args: 2 | table_offset: 408
  SPIT             | address: 0x102bbe3fc | args: 2 | table_offset: 536
  JOIN             | address: 0x102bc3280 | args: 2 | table_offset: 480
  LPND             | address: 0x102bc3790 | args: 2 | table_offset: 400
  SPND             | address: 0x102bc36c0 | args: 2 | table_offset: 392
  FPND             | address: 0x102bc35f0 | args: 2 | table_offset: 384
  APND             | address: 0x102bc3520 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x102bc46d4 | args: 1 | table_offset: 728
  BCPL_LIST_APPEND_INT | address: 0x102bc3520 | args: 2 | table_offset: 352
  GETVEC           | address: 0x102bbf9d8 | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x102b7c924 | args: 0 | table_offset: 320
  HEAPMANAGER_ENTER_SCOPE | address: 0x102b7c85c | args: 0 | table_offset: 288
  HEAPMANAGER_SETSAMMENABLED | address: 0x102b7c808 | args: 1 | table_offset: 304
  HEAPMANAGER_EXIT_SCOPE | address: 0x102b7c888 | args: 0 | table_offset: 296
  PIC_RUNTIME_HELPER | address: 0x102bbfac0 | args: 0 | table_offset: 280
  OBJECT_HEAP_FREE | address: 0x102bbfa84 | args: 1 | table_offset: 264
  OBJECT_HEAP_ALLOC | address: 0x102bbfa60 | args: 1 | table_offset: 256
  BCPL_LIST_GET_REST | address: 0x102bc3a4c | args: 1 | table_offset: 224
  FRND             | address: 0x102bbd684 | args: 0 | table_offset: 648
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x102bc3994 | args: 1 | table_offset: 208
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x102bc3930 | args: 1 | table_offset: 200
  RUNTIME_METHOD_LOOKUP | address: 0x102bbfaa8 | args: 2 | table_offset: 272
  FREEVEC          | address: 0x102bbf914 | args: 1 | table_offset: 144
  BCPL_BOUNDS_ERROR | address: 0x102bbb550 | args: 3 | table_offset: 192
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x102bc471c | args: 0 | table_offset: 184
  WRITEF4          | address: 0x102bbcf2c | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x102bc43a8 | args: 1 | table_offset: 152
  BCPL_ALLOC_CHARS | address: 0x102bbf8bc | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x102bc35f0 | args: 2 | table_offset: 360
  GET_FREE_LIST_HEAD_ADDR | address: 0x102bc46c8 | args: 0 | table_offset: 336
  BCPL_GET_ATOM_TYPE | address: 0x102bc3ab0 | args: 1 | table_offset: 232
  FWRITE           | address: 0x102bbc86c | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x102bc34c0 | args: 0 | table_offset: 344
  SPLIT            | address: 0x102bc2f14 | args: 2 | table_offset: 472
  BCPL_FREE_CELLS  | address: 0x102bc46c4 | args: 0 | table_offset: 328
  RND              | address: 0x102bbd6d8 | args: 1 | table_offset: 640
  HEAPMANAGER_ISSAMMENABLED | address: 0x102b7c838 | args: 0 | table_offset: 312
  WRITEC           | address: 0x102bbd1e8 | args: 1 | table_offset: 88
  MALLOC           | address: 0x102bbf85c | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x102bbf85c | args: 3 | table_offset: 104
  FTAN             | address: 0x102bbd794 | args: 1 | table_offset: 672
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 248
  BCPL_GET_LAST_ERROR | address: 0x102bbb3d0 | args: 1 | table_offset: 168
  RDCH             | address: 0x102bbd3ac | args: 0 | table_offset: 96
  FILE_READ        | address: 0x102bc07b8 | args: 3 | table_offset: 592
  UNPACKSTRING     | address: 0x102bbdb38 | args: 1 | table_offset: 520
  WRITEF5          | address: 0x102bbcfb8 | args: 6 | table_offset: 64
  FILTER           | address: 0x102bc42f8 | args: 2 | table_offset: 464
  BCPL_FREE_LIST_SAFE | address: 0x102bc44b0 | args: 1 | table_offset: 160
  FILE_OPEN_WRITE  | address: 0x102bbfeb0 | args: 1 | table_offset: 552
  FILE_OPEN_READ   | address: 0x102bbfb30 | args: 1 | table_offset: 544
  BCPL_LIST_GET_NTH | address: 0x102bc3b18 | args: 2 | table_offset: 240
  WRITEF7          | address: 0x102bbd0f4 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x102bbceac | args: 4 | table_offset: 48
  WRITEF6          | address: 0x102bbd050 | args: 7 | table_offset: 72
  REVERSE          | address: 0x102bc411c | args: 1 | table_offset: 448
  WRITEF2          | address: 0x102bbce38 | args: 3 | table_offset: 40
  WRITEF1          | address: 0x102bbcdd0 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x102bc39fc | args: 1 | table_offset: 216
  BCPL_CLEAR_ERRORS | address: 0x102bbb480 | args: 0 | table_offset: 176
  WRITEF           | address: 0x102bbc8b0 | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x102bc36c0 | args: 2 | table_offset: 368
  WRITES           | address: 0x102bbc310 | args: 1 | table_offset: 0
  SLURP            | address: 0x102bbded0 | args: 1 | table_offset: 528
  FGETVEC          | address: 0x102bbfa0c | args: 1 | table_offset: 136
  FLOG             | address: 0x102bbd7c0 | args: 1 | table_offset: 688
  WRITEN           | address: 0x102bbd1a4 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Testing Pairwise Operation Liveness Fix
"
            AssignmentStatement:
              LHS:
                VariableAccess: vec_a
              RHS:
            AssignmentStatement:
              LHS:
                VariableAccess: vec_b
              RHS:
            AssignmentStatement:
              LHS:
                VectorAccess (!):
                  VariableAccess: vec_a
                  NumberLiteral: 0
              RHS:
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Testing Pairwise Operation Liveness Fix
"
            AssignmentStatement:
              LHS:
                VariableAccess: vec_a
              RHS:
            AssignmentStatement:
              LHS:
                VariableAccess: vec_b
              RHS:
            AssignmentStatement:
              LHS:
                VectorAccess (!):
                  VariableAccess: vec_a
                  NumberLiteral: 0
              RHS:
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: vec_a as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: vec_b as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Set variable name for FPairsAllocationExpression: vec_a
[SymbolDiscoveryPass] Processing FPairsAllocationExpression
[SymbolDiscoveryPass] Updated FPAIRS variable: vec_a with size 4
[SymbolDiscoveryPass] Set variable name for FPairsAllocationExpression: vec_b
[SymbolDiscoveryPass] Processing FPairsAllocationExpression
[SymbolDiscoveryPass] Updated FPAIRS variable: vec_b with size 4

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'vec_a' (LOCAL_VAR, POINTER_TO|FPAIRS, scope=2, block=0, size=4, class_name='', function_name='START')
Symbol 'vec_b' (LOCAL_VAR, POINTER_TO|FPAIRS, scope=2, block=0, size=4, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 4 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103e94290
[ANALYZER TRACE] WRITEF format specifiers detected: [] (count = 0)
[ANALYZER TRACE]   Detected call to runtime function: WRITEF, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE] Visiting VariableAccess: vec_a
[DEBUG get_effective_variable_name] Called with: 'vec_a'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'vec_a'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 52
[ANALYZER TRACE] Visiting VariableAccess: vec_b
[DEBUG get_effective_variable_name] Called with: 'vec_b'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'vec_b'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 52
[ANALYZER TRACE] Visiting FPairExpression
[ANALYZER TRACE] FPairExpression analysis complete
[ANALYZER TRACE] Visiting VariableAccess: vec_a
[DEBUG get_effective_variable_name] Called with: 'vec_a'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'vec_a'
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 1
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 1
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 4
  Float Locals: 0
  Runtime Calls: 1
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Tracking variable 'vec_a' in current block
[CFGBuilderPass] Tracking variable 'vec_b' in current block
[CFGBuilderPass] Created new basic block: START_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 0
  Edges redirected: 0
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 4 statements
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 15FPairExpression
[LivenessAnalysisPass] Collecting uses from node type: 13NumberLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13NumberLiteral
[LivenessAnalysisPass] Collecting uses from node type: 13NumberLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13NumberLiteral
[LivenessAnalysisPass] Reverse scan - Statement 3 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 26FPairsAllocationExpression
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 26FPairsAllocationExpression
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 26FPairsAllocationExpression
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 26FPairsAllocationExpression
[LivenessAnalysisPass] Reverse scan - Statement 1 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { }
  Def: { vec_a vec_b }
  In : { }
  Out: { }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_1 (conceptual)

Block ID: START_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - AssignmentStmt
    - AssignmentStmt
  Successors: START_Exit_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Testing Pairwise Operation Liveness Fix
"
            AssignmentStatement:
              LHS:
                VariableAccess: vec_a
              RHS:
            AssignmentStatement:
              LHS:
                VariableAccess: vec_b
              RHS:
            AssignmentStatement:
              LHS:
                VectorAccess (!):
                  VariableAccess: vec_a
                  NumberLiteral: 0
              RHS:
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[LiveIntervalPass] Created 2 intervals for function: START
  vec_a: [1-3]
  vec_b: [2-2]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 1 call sites at: 0 
[Allocator] Partitioned: 0 call-crossing, 2 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only vec_a [1-3]
  Assigned register X15 to vec_a
[ALLOC] Updated allocations for vec_a: spilled=0, register='X15'
[Allocator] Allocating local-only vec_b [2-2]
  Assigned register X14 to vec_b
[ALLOC] Updated allocations for vec_b: spilled=0, register='X14'
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 2
  Free integer registers: 11
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  vec_a: reg X15 (caller-saved) [local-only]
  vec_b: reg X14 (caller-saved) [local-only]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 4
  Float Locals: 0
  Runtime Calls: 1
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4431773696
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 1 unique external functions:
[DEBUG]   - WRITEF
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] WRITEF detected, adding WRITEF1-WRITEF7 variants...
[VeneerManager] Generating 10 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITEF_veneer for function: WRITEF
[VeneerManager] Created veneer: WRITEF1_veneer for function: WRITEF1
[VeneerManager] Created veneer: WRITEF2_veneer for function: WRITEF2
[VeneerManager] Created veneer: WRITEF3_veneer for function: WRITEF3
[VeneerManager] Created veneer: WRITEF4_veneer for function: WRITEF4
[VeneerManager] Created veneer: WRITEF5_veneer for function: WRITEF5
[VeneerManager] Created veneer: WRITEF6_veneer for function: WRITEF6
[VeneerManager] Created veneer: WRITEF7_veneer for function: WRITEF7
[VeneerManager] Generated 10 veneers, estimated total size: 200 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Caching live intervals for function: START
[SYNC] Found 2 variable allocations
[LIVE] Updating live intervals at instruction point 0
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 2
[DEBUG] DEBUG: variable_types['vec_a'] = POINTER_TO|FPAIRS
[DEBUG] DEBUG: variable_types['vec_b'] = POINTER_TO|FPAIRS
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'vec_a' of type 1050624 at offset 16 (size 8)
[DEBUG] Registered local 'vec_a' from analyzer metrics.
Added local variable 'vec_b' of type 1050624 at offset 24 (size 8)
[DEBUG] Registered local 'vec_b' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: vec_a                          | POINTER_TO
+24      | Local: vec_b                          | POINTER_TO
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #40] ; Saved Reg: X28 @ FP+40
[LIVE] Updating live intervals at instruction point -1
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: vec_a                          | POINTER_TO
+24      | Local: vec_b                          | POINTER_TO
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[LIVE] Updating live intervals at instruction point 0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0
[LIVE] Updating live intervals at instruction point 0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[LIVE] Updating live intervals at instruction point 0
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Testing Pairwise Operation Liveness Fix
'.
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 0
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF_veneer
[LIVE] Updating live intervals at instruction point 0
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FPairsAllocationExpression node.
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #4
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[DEBUG] Loaded integer literal 4 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Freed register X20 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: LSL X20, X9, #1
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Freed register X20 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[DEBUG LEVEL 5] Emitting instruction: BL FGETVEC
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X0
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Freed register X20 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: SUB X9, X20, #8
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X9, #0]
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[DEBUG] Finished visiting FPairsAllocationExpression node. Result in X20
[DEBUG] Handling assignment for variable: vec_a
[DEBUG] store_variable_register for 'vec_a' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'vec_a' lives in X15. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X20
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X15 active for variable vec_a [1-3]
[DEBUG]   Updating home register X15 for variable 'vec_a' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X20
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X15, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FPairsAllocationExpression node.
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #4
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[DEBUG] Loaded integer literal 4 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[LIVE] Freed register X20 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: LSL X20, X9, #1
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[LIVE] Freed register X20 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[DEBUG LEVEL 5] Emitting instruction: BL FGETVEC
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X0
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[LIVE] Freed register X20 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: SUB X9, X20, #8
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X9, #0]
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[DEBUG] Finished visiting FPairsAllocationExpression node. Result in X20
[DEBUG] Handling assignment for variable: vec_b
[DEBUG] store_variable_register for 'vec_b' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'vec_b' lives in X14. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X14, X20
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Register X14 active for variable vec_b [2-2]
[DEBUG]   Updating home register X14 for variable 'vec_b' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X14, X20
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X14, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Generating code for FPairExpression using ARM64 bit manipulation
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #0
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[LIVE] Freed register X14 (no active variables)
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: ADRP X11, L_float0
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: ADD X11, X11, #:lo12:L_float0
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: LDR D0, [X11, #0]
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Loaded float literal 2.000000 into D0.
[DEBUG] FCVT registers: s_reg=S1, first_reg=D0
[DEBUG LEVEL 5] Emitting instruction: FCVT S1, D0 ;encoder.
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: FMOV W11, S1
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: BFXIL X9, X11, #0, #32
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Converted double to float and inserted into bits 0-31 using BFXIL
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: ADRP X12, L_float1
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: ADD X12, X12, #:lo12:L_float1
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: LDR D0, [X12, #0]
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Loaded float literal 3.000000 into D0.
[DEBUG LEVEL 5] Emitting instruction: FCVT S1, D0 ;encoder.
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: FMOV W12, S1
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: BFI X9, X12, #32, #32
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Converted double to float and inserted into bits 32-63 using BFI
[DEBUG] FPairExpression code generation complete - used ARM64 bit manipulation
[DEBUG] Visiting VariableAccess node for 'vec_a'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'vec_a' in function 'START'
[DEBUG] get_variable_register for: 'vec_a' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'vec_a' lives in register X15
[DEBUG] Variable 'vec_a' value loaded into X15
[DEBUG]   [DEBUG] get_variable_register returned: 'X15'
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X12, #0
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Loaded integer literal 0 into X12 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: LSL X13, X12, #3
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Calculated byte offset for vector assignment.
[DEBUG LEVEL 5] Emitting instruction: ADD X14, X15, X13
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Calculated effective address for vector assignment.
[DEBUG LEVEL 5] Emitting instruction: STR X9, [X14, #0]
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Stored value to vector element.
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_1
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG LEVEL 5] Emitting instruction: B .L0
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X15 active for variable vec_a [1-3]
[LIVE] Variable vec_b expired from register X14
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_float0
[InstructionStream TRACE] Adding label definition: L_float1
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'vec_a' (LOCAL_VAR, POINTER_TO|FPAIRS, scope=2, block=0, size=4, class_name='', function_name='START')
Symbol 'vec_b' (LOCAL_VAR, POINTER_TO|FPAIRS, scope=2, block=0, size=4, class_name='', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SPLIT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='', parameters=[STRING, STRING])
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')

Data sections generated.

=== Peephole Optimization ===
Analyzing 165 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 55
  Before:
    STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32  [Opcode=26, Dest=-1, Src1=19, Imm=32, Base=29, Offset=32]
    STR X28, [X29, #40] ; Saved Reg: X28 @ FP+40  [Opcode=26, Dest=-1, Src1=28, Imm=40, Base=29, Offset=40]
  After:
    STP x19, x28, [x29, #32]  [Opcode=30, Dest=-1, Src1=19, Imm=32, Base=29, Offset=32]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 105
  Before:
    LDR X19, [X29, #32] ; Restored Reg: X19 @ FP+32  [Opcode=27, Dest=19, Src1=-1, Imm=32, Base=29, Offset=32]
    LDR X28, [X29, #40] ; Restored Reg: X28 @ FP+40  [Opcode=27, Dest=28, Src1=-1, Imm=40, Base=29, Offset=40]
  After:
    LDP x19, x28, [x29, #32]  [Opcode=31, Dest=19, Src1=28, Imm=32, Base=29, Offset=32]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 107
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [SP, #0]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 165
  Instructions after:  162
  Total optimizations: 3
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 2
    - Combine adjacent X-register STRs into STP: 1
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x108278000) ---
Address Hex Code    Assembly
--------------------------------------------------
 108278000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 108278004 0xd2990b90  MOVZ X16, #51292
 108278008 0xf2a056f0  MOVK X16, #695, LSL #16
 10827800c 0xf2c00030  MOVK X16, #1, LSL #32
 108278010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 108278014 0xd2991110  MOVZ X16, #51336
 108278018 0xf2a056f0  MOVK X16, #695, LSL #16
 10827801c 0xf2c00030  MOVK X16, #1, LSL #32
 108278020 0xd61f0200  BR X16
WRITEF_veneer:
 108278024 0xd2991610  MOVZ X16, #51376
 108278028 0xf2a05770  MOVK X16, #699, LSL #16
 10827802c 0xf2c00030  MOVK X16, #1, LSL #32
 108278030 0xd61f0200  BR X16
WRITEF1_veneer:
 108278034 0xd299ba10  MOVZ X16, #52688
 108278038 0xf2a05770  MOVK X16, #699, LSL #16
 10827803c 0xf2c00030  MOVK X16, #1, LSL #32
 108278040 0xd61f0200  BR X16
WRITEF2_veneer:
 108278044 0xd299c710  MOVZ X16, #52792
 108278048 0xf2a05770  MOVK X16, #699, LSL #16
 10827804c 0xf2c00030  MOVK X16, #1, LSL #32
 108278050 0xd61f0200  BR X16
WRITEF3_veneer:
 108278054 0xd299d590  MOVZ X16, #52908
 108278058 0xf2a05770  MOVK X16, #699, LSL #16
 10827805c 0xf2c00030  MOVK X16, #1, LSL #32
 108278060 0xd61f0200  BR X16
WRITEF4_veneer:
 108278064 0xd299e590  MOVZ X16, #53036
 108278068 0xf2a05770  MOVK X16, #699, LSL #16
 10827806c 0xf2c00030  MOVK X16, #1, LSL #32
 108278070 0xd61f0200  BR X16
WRITEF5_veneer:
 108278074 0xd299f710  MOVZ X16, #53176
 108278078 0xf2a05770  MOVK X16, #699, LSL #16
 10827807c 0xf2c00030  MOVK X16, #1, LSL #32
 108278080 0xd61f0200  BR X16
WRITEF6_veneer:
 108278084 0xd29a0a10  MOVZ X16, #53328
 108278088 0xf2a05770  MOVK X16, #699, LSL #16
 10827808c 0xf2c00030  MOVK X16, #1, LSL #32
 108278090 0xd61f0200  BR X16
WRITEF7_veneer:
 108278094 0xd29a1e90  MOVZ X16, #53492
 108278098 0xf2a05770  MOVK X16, #699, LSL #16
 10827809c 0xf2c00030  MOVK X16, #1, LSL #32
 1082780a0 0xd61f0200  BR X16
 1082780a4 0x00000000  ; --- End Veneer Section ---

START:
 1082780a8 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 1082780ac 0x910003fd  MOV X29, SP
 1082780b0 0xa90273b3  STP x19, x28, [x29, #32]
 1082780b4 0xd288001c  MOVZ X28, #16384
 1082780b8 0xf2a06adc  MOVK X28, #854, LSL #16
 1082780bc 0xf2c0003c  MOVK X28, #1, LSL #32
 1082780c0 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 1082780c4 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x10827d000
 1082780c8 0x91000129  ADD X9, X9, #:lo12:L_str0    ; Reloc -> 'L_str0' @ 0x10827d000
 1082780cc 0x91002129  ADD X9, X9, #8
 1082780d0 0xaa0903e0  MOV X0, X9
 1082780d4 0x97ffffd4  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x108278024
 1082780d8 0xd2800089  MOVZ X9, #4
 1082780dc 0xaa0903f4  MOV X20, X9
 1082780e0 0xd37ff934  LSL X20, X9, #1
 1082780e4 0xaa1403e0  MOV X0, X20
 1082780e8 0x96a51e49  BL FGETVEC    ; Reloc -> 'FGETVEC' @ 0x102bbfa0c
 1082780ec 0xaa0003f4  MOV X20, X0
 1082780f0 0xd1002289  SUB X9, X20, #8
 1082780f4 0xf9000134  STR X20, [X9, #0]
 1082780f8 0xaa1403ef  MOV X15, X20
 1082780fc 0xd2800089  MOVZ X9, #4
 108278100 0xaa0903f4  MOV X20, X9
 108278104 0xd37ff934  LSL X20, X9, #1
 108278108 0xaa1403e0  MOV X0, X20
 10827810c 0x96a51e40  BL FGETVEC    ; Reloc -> 'FGETVEC' @ 0x102bbfa0c
 108278110 0xaa0003f4  MOV X20, X0
 108278114 0xd1002289  SUB X9, X20, #8
 108278118 0xf9000134  STR X20, [X9, #0]
 10827811c 0xaa1403ee  MOV X14, X20
 108278120 0xd2800009  MOVZ X9, #0
 108278124 0xb000002b  ADRP X11, L_float0    ; Reloc -> 'L_float0' @ 0x10827d0b0
 108278128 0x9102c16b  ADD X11, X11, #:lo12:L_float0    ; Reloc -> 'L_float0' @ 0x10827d0b0
 10827812c 0xfd400160  LDR D0, [X11, #0]
 108278130 0x1e624001  FCVT S1, D0 ;encoder.
 108278134 0x1e26002b  FMOV W11, S1
 108278138 0xb3407d69  BFXIL X9, X11, #0, #32
 10827813c 0xb000002c  ADRP X12, L_float1    ; Reloc -> 'L_float1' @ 0x10827d0b8
 108278140 0x9102e18c  ADD X12, X12, #:lo12:L_float1    ; Reloc -> 'L_float1' @ 0x10827d0b8
 108278144 0xfd400180  LDR D0, [X12, #0]
 108278148 0x1e624001  FCVT S1, D0 ;encoder.
 10827814c 0x1e26002c  FMOV W12, S1
 108278150 0xb3607d89  BFI X9, X12, #32, #32
 108278154 0xd280000c  MOVZ X12, #0
 108278158 0xd37df18d  LSL X13, X12, #3
 10827815c 0x8b0d01ee  ADD X14, X15, X13
 108278160 0xf90001c9  STR X9, [X14, #0]
 108278164 0x14000001  B START_Exit_1    ; Reloc -> 'START_Exit_1' @ 0x108278168
START_Exit_1:
 108278168 0x14000001  B .L0    ; Reloc -> '.L0' @ 0x10827816c
.L0:
 10827816c 0xa94273b3  LDP x19, x28, [x29, #32]
 108278170 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 108278174 0xa9407bfd  LDP x29, x30, [SP, #0]
 108278178 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10827817c 0xd65f03c0  RET
L_str0:
 10827d000 0x28000000  .quad 0x28
 10827d004 0x00000000  ; (upper half)
 10827d008 0x54000000  DCD 0x54
 10827d00c 0x65000000  DCD 0x65
 10827d010 0x73000000  DCD 0x73
 10827d014 0x74000000  DCD 0x74
 10827d018 0x69000000  DCD 0x69
 10827d01c 0x6e000000  DCD 0x6e
 10827d020 0x67000000  DCD 0x67
 10827d024 0x20000000  DCD 0x20
 10827d028 0x50000000  DCD 0x50
 10827d02c 0x61000000  DCD 0x61
 10827d030 0x69000000  DCD 0x69
 10827d034 0x72000000  DCD 0x72
 10827d038 0x77000000  DCD 0x77
 10827d03c 0x69000000  DCD 0x69
 10827d040 0x73000000  DCD 0x73
 10827d044 0x65000000  DCD 0x65
 10827d048 0x20000000  DCD 0x20
 10827d04c 0x4f000000  DCD 0x4f
 10827d050 0x70000000  DCD 0x70
 10827d054 0x65000000  DCD 0x65
 10827d058 0x72000000  DCD 0x72
 10827d05c 0x61000000  DCD 0x61
 10827d060 0x74000000  DCD 0x74
 10827d064 0x69000000  DCD 0x69
 10827d068 0x6f000000  DCD 0x6f
 10827d06c 0x6e000000  DCD 0x6e
 10827d070 0x20000000  DCD 0x20
 10827d074 0x4c000000  DCD 0x4c
 10827d078 0x69000000  DCD 0x69
 10827d07c 0x76000000  DCD 0x76
 10827d080 0x65000000  DCD 0x65
 10827d084 0x6e000000  DCD 0x6e
 10827d088 0x65000000  DCD 0x65
 10827d08c 0x73000000  DCD 0x73
 10827d090 0x73000000  DCD 0x73
 10827d094 0x20000000  DCD 0x20
 10827d098 0x46000000  DCD 0x46
 10827d09c 0x69000000  DCD 0x69
 10827d0a0 0x78000000  DCD 0x78
 10827d0a4 0xa0000000  DCD 0xa
 10827d0a8 0x00000000  DCD 0x0
 10827d0ac 0x00000000  DCD 0x0
L_float0:
 10827d0b0 0x00000000  .quad 0x4000000000000000
 10827d0b4 0x40000000  ; (upper half)
L_float1:
 10827d0b8 0x00000000  .quad 0x4008000000000000
 10827d0bc 0x40080000  ; (upper half)

--------------------------

JIT runtime table populated with 124 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x1082780a8
[JITExecutor] Starting execution of JIT-compiled function at address: 0x1082780a8
Testing Pairwise Operation Liveness Fix
