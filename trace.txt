Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=test_pair_lanes_basic.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.1847
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/test_pair_lanes_basic.bcl"
LET START() BE $(
    WRITEF("Testing basic PAIR lane access*N")

    LET p1 = PAIR(10, 20)
    WRITEF1("p1 = %P*N", p1)

    // Test reading lanes
    LET first = p1.|0|
    LET second = p1.|1|
    WRITEF2("p1.|0| = %N, p1.|1| = %N*N", first, second)

    WRITEF("Expected: p1.|0| = 10, p1.|1| = 20*N")
    WRITEF("Test complete*N")
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x10080f24c
Registered 96 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x10080df80 | args: 0 | table_offset: 752
  FINISH           | address: 0x10080cd30 | args: 0 | table_offset: 744
  FABS             | address: 0x10080d0e0 | args: 1 | table_offset: 712
  FSIN             | address: 0x10080d0a4 | args: 1 | table_offset: 688
  FILE_EOF         | address: 0x1008103cc | args: 1 | table_offset: 656
  RAND             | address: 0x10080cf30 | args: 1 | table_offset: 664
  FILE_TELL        | address: 0x100810374 | args: 1 | table_offset: 648
  FILE_SEEK        | address: 0x1008102b0 | args: 3 | table_offset: 640
  FILE_WRITE       | address: 0x100810198 | args: 3 | table_offset: 632
  FIX              | address: 0x10080d120 | args: 1 | table_offset: 736
  FILE_READS       | address: 0x10080fbe4 | args: 1 | table_offset: 616
  FILE_WRITES      | address: 0x10080f908 | args: 2 | table_offset: 608
  FEXP             | address: 0x10080d10c | args: 1 | table_offset: 728
  FILE_CLOSE       | address: 0x10080f89c | args: 1 | table_offset: 600
  FILE_OPEN_APPEND | address: 0x10080f80c | args: 1 | table_offset: 592
  PACKSTRING       | address: 0x10080d138 | args: 1 | table_offset: 544
  STRLEN           | address: 0x10080cd40 | args: 1 | table_offset: 536
  STRCOPY          | address: 0x10080ce84 | args: 2 | table_offset: 520
  FIND             | address: 0x100813c28 | args: 3 | table_offset: 488
  DEEPCOPYLITERALLIST | address: 0x1008138a0 | args: 1 | table_offset: 472
  DEEPCOPYLIST     | address: 0x100813708 | args: 1 | table_offset: 464
  COPYLIST         | address: 0x100813608 | args: 1 | table_offset: 456
  CONCAT           | address: 0x100813a40 | args: 2 | table_offset: 448
  BCPL_CONCAT_LISTS | address: 0x100813a40 | args: 2 | table_offset: 440
  SPIT             | address: 0x10080dd34 | args: 2 | table_offset: 568
  JOIN             | address: 0x100812ca4 | args: 2 | table_offset: 512
  LPND             | address: 0x1008131b4 | args: 2 | table_offset: 432
  SPND             | address: 0x1008130e4 | args: 2 | table_offset: 424
  FPND             | address: 0x100813014 | args: 2 | table_offset: 416
  APND             | address: 0x100812f44 | args: 2 | table_offset: 408
  RETURNNODETOFREELIST | address: 0x1008140f8 | args: 1 | table_offset: 760
  BCPL_LIST_APPEND_INT | address: 0x100812f44 | args: 2 | table_offset: 384
  BCPL_LIST_CREATE_EMPTY | address: 0x100812ee4 | args: 0 | table_offset: 376
  GETVEC           | address: 0x10080f310 | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x1007d45b4 | args: 0 | table_offset: 352
  HEAPMANAGER_SETSAMMENABLED | address: 0x1007d4498 | args: 1 | table_offset: 336
  HEAPMANAGER_ENTER_SCOPE | address: 0x1007d44ec | args: 0 | table_offset: 320
  HEAPMANAGER_EXIT_SCOPE | address: 0x1007d4518 | args: 0 | table_offset: 328
  PIC_RUNTIME_HELPER | address: 0x10080f3f8 | args: 0 | table_offset: 312
  OBJECT_HEAP_ALLOC | address: 0x10080f398 | args: 1 | table_offset: 288
  BCPL_LIST_GET_REST | address: 0x100813470 | args: 1 | table_offset: 256
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x100813354 | args: 1 | table_offset: 232
  RUNTIME_METHOD_LOOKUP | address: 0x10080f3e0 | args: 2 | table_offset: 304
  FREEVEC          | address: 0x10080f24c | args: 1 | table_offset: 176
  BCPL_BOUNDS_ERROR | address: 0x10080ae88 | args: 3 | table_offset: 224
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x100814140 | args: 0 | table_offset: 216
  BCPL_LIST_GET_TAIL | address: 0x100813420 | args: 1 | table_offset: 248
  BCPL_CLEAR_ERRORS | address: 0x10080adb8 | args: 0 | table_offset: 208
  FTAN             | address: 0x10080d0cc | args: 1 | table_offset: 704
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 280
  BCPL_GET_LAST_ERROR | address: 0x10080ad08 | args: 1 | table_offset: 200
  FILTER           | address: 0x100813d1c | args: 2 | table_offset: 496
  BCPL_FREE_LIST_SAFE | address: 0x100813ed4 | args: 1 | table_offset: 192
  OBJECT_HEAP_FREE | address: 0x10080f3bc | args: 1 | table_offset: 296
  FCOS             | address: 0x10080d0b8 | args: 1 | table_offset: 696
  STRCMP           | address: 0x10080cda0 | args: 2 | table_offset: 528
  PGETVEC          | address: 0x10080f310 | args: 1 | table_offset: 160
  FRND             | address: 0x10080cfbc | args: 0 | table_offset: 680
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x1008133b8 | args: 1 | table_offset: 240
  GET_FREE_LIST_HEAD_ADDR | address: 0x1008140ec | args: 0 | table_offset: 368
  SGETVEC          | address: 0x10080f310 | args: 1 | table_offset: 152
  BCPL_GET_ATOM_TYPE | address: 0x1008134d4 | args: 1 | table_offset: 264
  FWRITE           | address: 0x10080c1a4 | args: 1 | table_offset: 16
  SPLIT            | address: 0x100812938 | args: 2 | table_offset: 504
  BCPL_FREE_CELLS  | address: 0x1008140e8 | args: 0 | table_offset: 360
  RND              | address: 0x10080d010 | args: 1 | table_offset: 672
  QGETVEC          | address: 0x10080f310 | args: 1 | table_offset: 168
  HEAPMANAGER_ISSAMMENABLED | address: 0x1007d44c8 | args: 0 | table_offset: 344
  WRITEC           | address: 0x10080cb20 | args: 1 | table_offset: 88
  MALLOC           | address: 0x10080f194 | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x10080f194 | args: 3 | table_offset: 104
  RDCH             | address: 0x10080cce4 | args: 0 | table_offset: 96
  FILE_READ        | address: 0x100810084 | args: 3 | table_offset: 624
  UNPACKSTRING     | address: 0x10080d470 | args: 1 | table_offset: 552
  WRITEF5          | address: 0x10080c8f0 | args: 6 | table_offset: 64
  IGETVEC          | address: 0x10080f310 | args: 1 | table_offset: 144
  FILE_OPEN_WRITE  | address: 0x10080f77c | args: 1 | table_offset: 584
  FILE_OPEN_READ   | address: 0x10080f3fc | args: 1 | table_offset: 576
  BCPL_LIST_GET_NTH | address: 0x10081353c | args: 2 | table_offset: 272
  WRITEF7          | address: 0x10080ca2c | args: 8 | table_offset: 80
  WRITEF3          | address: 0x10080c7e4 | args: 4 | table_offset: 48
  BCPL_LIST_APPEND_FLOAT | address: 0x100813014 | args: 2 | table_offset: 392
  BCPL_ALLOC_CHARS | address: 0x10080f1f4 | args: 1 | table_offset: 112
  WRITEF6          | address: 0x10080c988 | args: 7 | table_offset: 72
  BCPL_FREE_LIST   | address: 0x100813dcc | args: 1 | table_offset: 184
  WRITEF4          | address: 0x10080c864 | args: 5 | table_offset: 56
  REVERSE          | address: 0x100813b40 | args: 1 | table_offset: 480
  WRITEF2          | address: 0x10080c770 | args: 3 | table_offset: 40
  WRITEF1          | address: 0x10080c708 | args: 2 | table_offset: 32
  BCPL_LIST_APPEND_STRING | address: 0x1008130e4 | args: 2 | table_offset: 400
  WRITEF           | address: 0x10080c1e8 | args: 1 | table_offset: 24
  WRITES           | address: 0x10080bc48 | args: 1 | table_offset: 0
  SLURP            | address: 0x10080d808 | args: 1 | table_offset: 560
  FGETVEC          | address: 0x10080f344 | args: 1 | table_offset: 136
  FLOG             | address: 0x10080d0f8 | args: 1 | table_offset: 720
  WRITEN           | address: 0x10080cadc | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Testing basic PAIR lane access
"
            AssignmentStatement:
              LHS:
                VariableAccess: p1
              RHS:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF1
              Arguments:
                StringLiteral: "p1 = %P
"
                VariableAccess: p1
            AssignmentStatement:
              LHS:
                VariableAccess: first
              RHS:
            AssignmentStatement:
              LHS:
                VariableAccess: second
              RHS:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF2
              Arguments:
                StringLiteral: "p1.|0| = %N, p1.|1| = %N
"
                VariableAccess: first
                VariableAccess: second
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Expected: p1.|0| = 10, p1.|1| = 20
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Test complete
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Testing basic PAIR lane access
"
            AssignmentStatement:
              LHS:
                VariableAccess: p1
              RHS:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF1
              Arguments:
                StringLiteral: "p1 = %P
"
                VariableAccess: p1
            AssignmentStatement:
              LHS:
                VariableAccess: first
              RHS:
            AssignmentStatement:
              LHS:
                VariableAccess: second
              RHS:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF2
              Arguments:
                StringLiteral: "p1.|0| = %N, p1.|1| = %N
"
                VariableAccess: first
                VariableAccess: second
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Expected: p1.|0| = 10, p1.|1| = 20
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Test complete
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: p1 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: first as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: second as INTEGER (default INTEGER)

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p1' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'first' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'second' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 8 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 49
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x70ac19230
[ANALYZER TRACE] WRITEF format specifiers detected: [] (count = 0)
[ANALYZER TRACE]   Detected call to runtime function: WRITEF, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 48
[ANALYZER TRACE] Visiting PairExpression
[ANALYZER TRACE] PairExpression analysis complete
[ANALYZER TRACE] Visiting VariableAccess: p1
[DEBUG get_effective_variable_name] Called with: 'p1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 49
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x70ac19260
[ANALYZER TRACE]   Detected call to runtime function: WRITEF1, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: p1
[DEBUG get_effective_variable_name] Called with: 'p1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 48
[ANALYZER TRACE] Visiting LaneAccessExpression
[ANALYZER TRACE] Visiting VariableAccess: p1
[DEBUG get_effective_variable_name] Called with: 'p1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p1'
[DEBUG get_variable_type] Looking for 'p1' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 3
[DEBUG get_variable_type] Found in variable_types: p1 -> 16
[ANALYZER TRACE] LaneAccessExpression analysis complete - element type: INTEGER
[DEBUG get_variable_type] Looking for 'p1' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 3
[DEBUG get_variable_type] Found in variable_types: p1 -> 16
[ANALYZER TRACE] Visiting VariableAccess: first
[DEBUG get_effective_variable_name] Called with: 'first'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'first'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 48
[ANALYZER TRACE] Visiting LaneAccessExpression
[ANALYZER TRACE] Visiting VariableAccess: p1
[DEBUG get_effective_variable_name] Called with: 'p1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p1'
[DEBUG get_variable_type] Looking for 'p1' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 3
[DEBUG get_variable_type] Found in variable_types: p1 -> 16
[ANALYZER TRACE] LaneAccessExpression analysis complete - element type: INTEGER
[DEBUG get_variable_type] Looking for 'p1' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 3
[DEBUG get_variable_type] Found in variable_types: p1 -> 16
[ANALYZER TRACE] Visiting VariableAccess: second
[DEBUG get_effective_variable_name] Called with: 'second'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'second'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 49
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x70ac19290
[ANALYZER TRACE]   Detected call to runtime function: WRITEF2, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: first
[DEBUG get_effective_variable_name] Called with: 'first'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'first'
[ANALYZER TRACE] Visiting VariableAccess: second
[DEBUG get_effective_variable_name] Called with: 'second'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'second'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 49
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x70ac192c0
[ANALYZER TRACE] WRITEF format specifiers detected: [] (count = 0)
[ANALYZER TRACE]   Detected call to runtime function: WRITEF, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 49
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x70ac192f0
[ANALYZER TRACE] WRITEF format specifiers detected: [] (count = 0)
[ANALYZER TRACE]   Detected call to runtime function: WRITEF, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 1
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 1
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Tracking variable 'p1' in current block
[CFGBuilderPass] Tracking variable 'first' in current block
[CFGBuilderPass] Tracking variable 'second' in current block
[CFGBuilderPass] Created new basic block: START_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 0
  Edges redirected: 0
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 8 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: first second 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Variables used after call: first second 
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: p1 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Variables used after call: p1 
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Intra-block call interval detected in START_Entry_0 - variables live across calls: first p1 second 
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'WRITEF1'
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'WRITEF2'
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables and 3 intra-statement call variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables and 3 intra-statement call variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { first p1 second }
  Def: { first p1 second }
  In : { first p1 second }
  Out: { }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_1 (conceptual)

Block ID: START_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - AssignmentStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Testing basic PAIR lane access
"
            AssignmentStatement:
              LHS:
                VariableAccess: p1
              RHS:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF1
              Arguments:
                StringLiteral: "p1 = %P
"
                VariableAccess: p1
            AssignmentStatement:
              LHS:
                VariableAccess: first
              RHS:
            AssignmentStatement:
              LHS:
                VariableAccess: second
              RHS:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF2
              Arguments:
                StringLiteral: "p1.|0| = %N, p1.|1| = %N
"
                VariableAccess: first
                VariableAccess: second
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Expected: p1.|0| = 10, p1.|1| = 20
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEF
              Arguments:
                StringLiteral: "Test complete
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'WRITEF1'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'WRITEF2'
[LiveIntervalPass] Created 3 intervals for function: START
  first: [0-5]
  p1: [0-2]
  second: [0-5]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 4 13 19 23 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing first [0-5]
  Assigned callee-saved register X27 to first
[ALLOC] Updated allocations for first: spilled=0, register='X27'
[Allocator] Allocating call-crossing p1 [0-2]
  Assigned callee-saved register X26 to p1
[ALLOC] Updated allocations for p1: spilled=0, register='X26'
[Allocator] Allocating call-crossing second [0-5]
  Assigned callee-saved register X25 to second
[ALLOC] Updated allocations for second: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  first: reg X27 (callee-saved) [call-crossing]
  p1: reg X26 (callee-saved) [call-crossing]
  second: reg X25 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 3
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4390174720
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 3 unique external functions:
[DEBUG]   - WRITEF
[DEBUG]   - WRITEF1
[DEBUG]   - WRITEF2
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] WRITEF detected, adding WRITEF1-WRITEF7 variants...
[VeneerManager] Generating 10 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITEF_veneer for function: WRITEF
[VeneerManager] Created veneer: WRITEF1_veneer for function: WRITEF1
[VeneerManager] Created veneer: WRITEF2_veneer for function: WRITEF2
[VeneerManager] Created veneer: WRITEF3_veneer for function: WRITEF3
[VeneerManager] Created veneer: WRITEF4_veneer for function: WRITEF4
[VeneerManager] Created veneer: WRITEF5_veneer for function: WRITEF5
[VeneerManager] Created veneer: WRITEF6_veneer for function: WRITEF6
[VeneerManager] Created veneer: WRITEF7_veneer for function: WRITEF7
[VeneerManager] Generated 10 veneers, estimated total size: 200 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: START
[SYNC] Found 3 variable allocations
[SYNC] Reserved register X27 for variable first
[SYNC] Reserved register X26 for variable p1
[SYNC] Reserved register X25 for variable second
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 3
[DEBUG] DEBUG: variable_types['first'] = INTEGER
[DEBUG] DEBUG: variable_types['p1'] = PAIR
[DEBUG] DEBUG: variable_types['second'] = INTEGER
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'first' of type 1 at offset 16 (size 8)
[DEBUG] Registered local 'first' from analyzer metrics.
Added local variable 'p1' of type 16 at offset 24 (size 8)
[DEBUG] Registered local 'p1' from analyzer metrics.
Added local variable 'second' of type 1 at offset 32 (size 8)
[DEBUG] Registered local 'second' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: first                          | INTEGER
+24      | Local: p1                             | 
+32      | Local: second                         | INTEGER
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: first                          | INTEGER
+24      | Local: p1                             | 
+32      | Local: second                         | INTEGER
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Testing basic PAIR lane access
'.
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Generating code for PairExpression using ARM64 bit field instructions
[DEBUG] PairExpression is literal - loading from rodata
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_pair0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_pair0
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X9, #0]
[DEBUG] Loaded literal PAIR from rodata label: L_pair0
[DEBUG] Handling assignment for variable: p1
[DEBUG] store_variable_register for 'p1' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable 'p1' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG]   Updating home register X26 for variable 'p1' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X26, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'p1 = %P
'.
[DEBUG] Visiting VariableAccess node for 'p1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p1' in function 'START'
[DEBUG] get_variable_register for: 'p1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p1' lives in register X26
[DEBUG] Variable 'p1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'WRITEF1'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Arg 1: src=X26 expr_type=PAIR expected=UNKNOWN target=PAIR
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X26
[DEBUG] Deferring release of source register: X26
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X26
[DEBUG] Executed MOV X1, X26
[DEBUG] Releasing source register: X9
[DEBUG] Releasing source register: X26
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF1_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[CODE GEN] Generating code for LaneAccessExpression
[VectorCodeGen] VectorCodeGen::generateLaneRead - use_neon: 1
[VectorCodeGen] Generating NEON lane read operation
[DEBUG] Visiting VariableAccess node for 'p1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p1' in function 'START'
[DEBUG] get_variable_register for: 'p1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p1' lives in register X26
[DEBUG] Variable 'p1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: fmov D0, X26
[DEBUG LEVEL 5] Emitting instruction: mov.s w20, v0[0]
[VectorCodeGen] Extracted lane 0 from vector
[CODE GEN] Lane access expression result in register: X20 (element type: INTEGER)
[DEBUG] Handling assignment for variable: first
[DEBUG] store_variable_register for 'first' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'first' lives in X27. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X20
[DEBUG]   Updating home register X27 for variable 'first' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X20
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X27, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[CODE GEN] Generating code for LaneAccessExpression
[VectorCodeGen] VectorCodeGen::generateLaneRead - use_neon: 1
[VectorCodeGen] Generating NEON lane read operation
[DEBUG] Visiting VariableAccess node for 'p1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p1' in function 'START'
[DEBUG] get_variable_register for: 'p1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p1' lives in register X26
[DEBUG] Variable 'p1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: fmov D0, X26
[DEBUG LEVEL 5] Emitting instruction: mov.s w20, v0[1]
[VectorCodeGen] Extracted lane 1 from vector
[CODE GEN] Lane access expression result in register: X20 (element type: INTEGER)
[DEBUG] Handling assignment for variable: second
[DEBUG] store_variable_register for 'second' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'second' lives in X25. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X20
[DEBUG]   Updating home register X25 for variable 'second' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X20
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X25, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'p1.|0| = %N, p1.|1| = %N
'.
[DEBUG] Visiting VariableAccess node for 'first'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'first' in function 'START'
[DEBUG] get_variable_register for: 'first' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'first' lives in register X27
[DEBUG] Variable 'first' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] Visiting VariableAccess node for 'second'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'second' in function 'START'
[DEBUG] get_variable_register for: 'second' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'second' lives in register X25
[DEBUG] Variable 'second' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'WRITEF2'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 3
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Arg 1: src=X27 expr_type=INTEGER expected=UNKNOWN target=INTEGER
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Arg 2: src=X25 expr_type=INTEGER expected=UNKNOWN target=INTEGER
[DEBUG] Integer arg 2 -> X2 (NGRN=2)
[DEBUG] Queued MOV X2, X25
[DEBUG] Deferring release of source register: X25
[DEBUG] Emitting 3 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X27
[DEBUG] Executed MOV X1, X27
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X25
[DEBUG] Executed MOV X2, X25
[DEBUG] Releasing source register: X9
[DEBUG] Releasing source register: X27
[DEBUG] Releasing source register: X25
[DEBUG] Final register usage: NGRN=3, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF2_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Expected: p1.|0| = 10, p1.|1| = 20
'.
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Test complete
'.
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: BL WRITEF_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L0
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_pair0
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p1' (LOCAL_VAR, PAIR, scope=2, block=0, class_name='', function_name='START')
Symbol 'first' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'second' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SPLIT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='', parameters=[STRING, STRING])
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')

Data sections generated.

=== Peephole Optimization ===
Analyzing 266 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 55
  Before:
    STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40  [Opcode=26, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
    STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48  [Opcode=26, Dest=-1, Src1=20, Imm=48, Base=29, Offset=48]
  After:
    STP x19, x20, [x29, #40]  [Opcode=30, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 56
  Before:
    STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56  [Opcode=26, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
    STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64  [Opcode=26, Dest=-1, Src1=25, Imm=64, Base=29, Offset=64]
  After:
    STP x21, x25, [x29, #56]  [Opcode=30, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 57
  Before:
    STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72  [Opcode=26, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
    STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80  [Opcode=26, Dest=-1, Src1=27, Imm=80, Base=29, Offset=80]
  After:
    STP x26, x27, [x29, #72]  [Opcode=30, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 106
  Before:
    LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40  [Opcode=27, Dest=19, Src1=-1, Imm=40, Base=29, Offset=40]
    LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48  [Opcode=27, Dest=20, Src1=-1, Imm=48, Base=29, Offset=48]
  After:
    LDP x19, x20, [x29, #40]  [Opcode=31, Dest=19, Src1=20, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 107
  Before:
    LDR X21, [X29, #56] ; Restored Reg: X21 @ FP+56  [Opcode=27, Dest=21, Src1=-1, Imm=56, Base=29, Offset=56]
    LDR X25, [X29, #64] ; Restored Reg: X25 @ FP+64  [Opcode=27, Dest=25, Src1=-1, Imm=64, Base=29, Offset=64]
  After:
    LDP x21, x25, [x29, #56]  [Opcode=31, Dest=21, Src1=25, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 108
  Before:
    LDR X26, [X29, #72] ; Restored Reg: X26 @ FP+72  [Opcode=27, Dest=26, Src1=-1, Imm=72, Base=29, Offset=72]
    LDR X27, [X29, #80] ; Restored Reg: X27 @ FP+80  [Opcode=27, Dest=27, Src1=-1, Imm=80, Base=29, Offset=80]
  After:
    LDP x26, x27, [x29, #72]  [Opcode=31, Dest=26, Src1=27, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 111
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [SP, #0]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 266
  Instructions after:  259
  Total optimizations: 7
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 4
    - Combine adjacent X-register STRs into STP: 3
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x105acc000) ---
Address Hex Code    Assembly
--------------------------------------------------
 105acc000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 105ACC004 0xD2889D90  MOVZ X16, #17644
 105ACC008 0xF2A00FB0  MOVK X16, #125, LSL #16
 105ACC00C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC010 0xD61F0200  BR X16
HeapManager_exit_scope_veneer:
 105ACC014 0xD288A310  MOVZ X16, #17688
 105ACC018 0xF2A00FB0  MOVK X16, #125, LSL #16
 105ACC01C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC020 0xD61F0200  BR X16
WRITEF_veneer:
 105ACC024 0xD2983D10  MOVZ X16, #49640
 105ACC028 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC02C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC030 0xD61F0200  BR X16
WRITEF1_veneer:
 105ACC034 0xD298E110  MOVZ X16, #50952
 105ACC038 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC03C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC040 0xD61F0200  BR X16
WRITEF2_veneer:
 105ACC044 0xD298EE10  MOVZ X16, #51056
 105ACC048 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC04C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC050 0xD61F0200  BR X16
WRITEF3_veneer:
 105ACC054 0xD298FC90  MOVZ X16, #51172
 105ACC058 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC05C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC060 0xD61F0200  BR X16
WRITEF4_veneer:
 105ACC064 0xD2990C90  MOVZ X16, #51300
 105ACC068 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC06C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC070 0xD61F0200  BR X16
WRITEF5_veneer:
 105ACC074 0xD2991E10  MOVZ X16, #51440
 105ACC078 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC07C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC080 0xD61F0200  BR X16
WRITEF6_veneer:
 105ACC084 0xD2993110  MOVZ X16, #51592
 105ACC088 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC08C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC090 0xD61F0200  BR X16
WRITEF7_veneer:
 105ACC094 0xD2994590  MOVZ X16, #51756
 105ACC098 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC09C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC0A0 0xD61F0200  BR X16
 105ACC0A4 0x00000000  ; --- End Veneer Section ---

START:
 105ACC0A8 0xA9BA7BFD  STP X29, X30, [SP, #-96]!
 105ACC0AC 0x910003FD  MOV X29, SP
 105ACC0B0 0xA902D3B3  STP x19, x20, [x29, #40]
 105ACC0B4 0xA903E7B5  STP x21, x25, [x29, #56]
 105ACC0B8 0xA904EFBA  STP x26, x27, [x29, #72]
 105ACC0BC 0xF9002FBC  STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
 105ACC0C0 0xD298001C  MOVZ X28, #49152
 105ACC0C4 0xF2A0B39C  MOVK X28, #1436, LSL #16
 105ACC0C8 0xF2C0003C  MOVK X28, #1, LSL #32
 105ACC0CC 0xF2E0001C  MOVK X28, #0, LSL #48
START_Entry_0:
 105ACC0D0 0xB0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x105AD1000
 105ACC0D4 0x91000129  ADD X9, X9, #:lo12:L_str0    ; Reloc -> 'L_str0' @ 0x105AD1000
 105ACC0D8 0x91002129  ADD X9, X9, #8
 105ACC0DC 0xAA0903E0  MOV X0, X9
 105ACC0E0 0x97FFFFD1  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x105ACC024
 105ACC0E4 0xB0000029  ADRP X9, L_pair0    ; Reloc -> 'L_pair0' @ 0x105AD1214
 105ACC0E8 0x91085129  ADD X9, X9, #:lo12:L_pair0    ; Reloc -> 'L_pair0' @ 0x105AD1214
 105ACC0EC 0xF9400129  LDR X9, [X9, #0]
 105ACC0F0 0xAA0903FA  MOV X26, X9
 105ACC0F4 0xB0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x105AD108C
 105ACC0F8 0x91023129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x105AD108C
 105ACC0FC 0x91002129  ADD X9, X9, #8
 105ACC100 0xAA0903E0  MOV X0, X9
 105ACC104 0xAA1A03E1  MOV X1, X26
 105ACC108 0x97FFFFCB  BL WRITEF1_veneer    ; Reloc -> 'WRITEF1_veneer' @ 0x105ACC034
 105ACC10C 0x9E660340  fmov D0, X26
 105ACC110 0xE043C140  mov.s w20, v0[0]
 105ACC114 0xAA1403FB  MOV X27, X20
 105ACC118 0x9E660340  fmov D0, X26
 105ACC11C 0xE0C3C140  mov.s w20, v0[1]
 105ACC120 0xAA1403F9  MOV X25, X20
 105ACC124 0xB0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x105AD10BC
 105ACC128 0x9102F129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x105AD10BC
 105ACC12C 0x91002129  ADD X9, X9, #8
 105ACC130 0xAA0903E0  MOV X0, X9
 105ACC134 0xAA1B03E1  MOV X1, X27
 105ACC138 0xAA1903E2  MOV X2, X25
 105ACC13C 0x97FFFFC2  BL WRITEF2_veneer    ; Reloc -> 'WRITEF2_veneer' @ 0x105ACC044
 105ACC140 0xB0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x105AD1130
 105ACC144 0x9104C129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x105AD1130
 105ACC148 0x91002129  ADD X9, X9, #8
 105ACC14C 0xAA0903E0  MOV X0, X9
 105ACC150 0x97FFFFB5  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x105ACC024
 105ACC154 0xB0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x105AD11CC
 105ACC158 0x91073129  ADD X9, X9, #:lo12:L_str4    ; Reloc -> 'L_str4' @ 0x105AD11CC
 105ACC15C 0x91002129  ADD X9, X9, #8
 105ACC160 0xAA0903E0  MOV X0, X9
 105ACC164 0x97FFFFB0  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x105ACC024
 105ACC168 0x14000001  B START_Exit_1    ; Reloc -> 'START_Exit_1' @ 0x105ACC16C
START_Exit_1:
 105ACC16C 0x14000001  B .L0    ; Reloc -> '.L0' @ 0x105ACC170
.L0:
 105ACC170 0xA942D3B3  LDP x19, x20, [x29, #40]
 105ACC174 0xA943E7B5  LDP x21, x25, [x29, #56]
 105ACC178 0xA944EFBA  LDP x26, x27, [x29, #72]
 105ACC17C 0xF9402FBC  LDR X28, [X29, #88] ; Restored Reg: X28 @ FP+88
 105ACC180 0x910003BF  MOV SP, X29 ; Deallocate frame by moving FP to SP
 105ACC184 0xA9407BFD  LDP x29, x30, [SP, #0]
 105ACC188 0x910043FF  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 105ACC18C 0xD65F03C0  RET
L_str0:
 105AD1000 0x1F000000  .quad 0x1f
 105AD1004 0x00000000  ; (upper half)
 105AD1008 0x54000000  DCD 0x54
 105AD100C 0x65000000  DCD 0x65
 105AD1010 0x73000000  DCD 0x73
 105AD1014 0x74000000  DCD 0x74
 105AD1018 0x69000000  DCD 0x69
 105AD101C 0x6E000000  DCD 0x6e
 105AD1020 0x67000000  DCD 0x67
 105AD1024 0x20000000  DCD 0x20
 105AD1028 0x62000000  DCD 0x62
 105AD102C 0x61000000  DCD 0x61
 105AD1030 0x73000000  DCD 0x73
 105AD1034 0x69000000  DCD 0x69
 105AD1038 0x63000000  DCD 0x63
 105AD103C 0x20000000  DCD 0x20
 105AD1040 0x50000000  DCD 0x50
 105AD1044 0x41000000  DCD 0x41
 105AD1048 0x49000000  DCD 0x49
 105AD104C 0x52000000  DCD 0x52
 105AD1050 0x20000000  DCD 0x20
 105AD1054 0x6C000000  DCD 0x6c
 105AD1058 0x61000000  DCD 0x61
 105AD105C 0x6E000000  DCD 0x6e
 105AD1060 0x65000000  DCD 0x65
 105AD1064 0x20000000  DCD 0x20
 105AD1068 0x61000000  DCD 0x61
 105AD106C 0x63000000  DCD 0x63
 105AD1070 0x63000000  DCD 0x63
 105AD1074 0x65000000  DCD 0x65
 105AD1078 0x73000000  DCD 0x73
 105AD107C 0x73000000  DCD 0x73
 105AD1080 0xA0000000  DCD 0xa
 105AD1084 0x00000000  DCD 0x0
 105AD1088 0x00000000  DCD 0x0
L_str1:
 105AD108C 0x80000000  .quad 0x8
 105AD1090 0x00000000  ; (upper half)
 105AD1094 0x70000000  DCD 0x70
 105AD1098 0x31000000  DCD 0x31
 105AD109C 0x20000000  DCD 0x20
 105AD10A0 0x3D000000  DCD 0x3d
 105AD10A4 0x20000000  DCD 0x20
 105AD10A8 0x25000000  DCD 0x25
 105AD10AC 0x50000000  DCD 0x50
 105AD10B0 0xA0000000  DCD 0xa
 105AD10B4 0x00000000  DCD 0x0
 105AD10B8 0x00000000  DCD 0x0
L_str2:
 105AD10BC 0x19000000  .quad 0x19
 105AD10C0 0x00000000  ; (upper half)
 105AD10C4 0x70000000  DCD 0x70
 105AD10C8 0x31000000  DCD 0x31
 105AD10CC 0x2E000000  DCD 0x2e
 105AD10D0 0x7C000000  DCD 0x7c
 105AD10D4 0x30000000  DCD 0x30
 105AD10D8 0x7C000000  DCD 0x7c
 105AD10DC 0x20000000  DCD 0x20
 105AD10E0 0x3D000000  DCD 0x3d
 105AD10E4 0x20000000  DCD 0x20
 105AD10E8 0x25000000  DCD 0x25
 105AD10EC 0x4E000000  DCD 0x4e
 105AD10F0 0x2C000000  DCD 0x2c
 105AD10F4 0x20000000  DCD 0x20
 105AD10F8 0x70000000  DCD 0x70
 105AD10FC 0x31000000  DCD 0x31
 105AD1100 0x2E000000  DCD 0x2e
 105AD1104 0x7C000000  DCD 0x7c
 105AD1108 0x31000000  DCD 0x31
 105AD110C 0x7C000000  DCD 0x7c
 105AD1110 0x20000000  DCD 0x20
 105AD1114 0x3D000000  DCD 0x3d
 105AD1118 0x20000000  DCD 0x20
 105AD111C 0x25000000  DCD 0x25
 105AD1120 0x4E000000  DCD 0x4e
 105AD1124 0xA0000000  DCD 0xa
 105AD1128 0x00000000  DCD 0x0
 105AD112C 0x00000000  DCD 0x0
L_str3:
 105AD1130 0x23000000  .quad 0x23
 105AD1134 0x00000000  ; (upper half)
 105AD1138 0x45000000  DCD 0x45
 105AD113C 0x78000000  DCD 0x78
 105AD1140 0x70000000  DCD 0x70
 105AD1144 0x65000000  DCD 0x65
 105AD1148 0x63000000  DCD 0x63
 105AD114C 0x74000000  DCD 0x74
 105AD1150 0x65000000  DCD 0x65
 105AD1154 0x64000000  DCD 0x64
 105AD1158 0x3A000000  DCD 0x3a
 105AD115C 0x20000000  DCD 0x20
 105AD1160 0x70000000  DCD 0x70
 105AD1164 0x31000000  DCD 0x31
 105AD1168 0x2E000000  DCD 0x2e
 105AD116C 0x7C000000  DCD 0x7c
 105AD1170 0x30000000  DCD 0x30
 105AD1174 0x7C000000  DCD 0x7c
 105AD1178 0x20000000  DCD 0x20
 105AD117C 0x3D000000  DCD 0x3d
 105AD1180 0x20000000  DCD 0x20
 105AD1184 0x31000000  DCD 0x31
 105AD1188 0x30000000  DCD 0x30
 105AD118C 0x2C000000  DCD 0x2c
 105AD1190 0x20000000  DCD 0x20
 105AD1194 0x70000000  DCD 0x70
 105AD1198 0x31000000  DCD 0x31
 105AD119C 0x2E000000  DCD 0x2e
 105AD11A0 0x7C000000  DCD 0x7c
 105AD11A4 0x31000000  DCD 0x31
 105AD11A8 0x7C000000  DCD 0x7c
 105AD11AC 0x20000000  DCD 0x20
 105AD11B0 0x3D000000  DCD 0x3d
 105AD11B4 0x20000000  DCD 0x20
 105AD11B8 0x32000000  DCD 0x32
 105AD11BC 0x30000000  DCD 0x30
 105AD11C0 0xA0000000  DCD 0xa
 105AD11C4 0x00000000  DCD 0x0
 105AD11C8 0x00000000  DCD 0x0
L_str4:
 105AD11CC 0xE0000000  .quad 0xe
 105AD11D0 0x00000000  ; (upper half)
 105AD11D4 0x54000000  DCD 0x54
 105AD11D8 0x65000000  DCD 0x65
 105AD11DC 0x73000000  DCD 0x73
 105AD11E0 0x74000000  DCD 0x74
 105AD11E4 0x20000000  DCD 0x20
 105AD11E8 0x63000000  DCD 0x63
 105AD11EC 0x6F000000  DCD 0x6f
 105AD11F0 0x6D000000  DCD 0x6d
 105AD11F4 0x70000000  DCD 0x70
 105AD11F8 0x6C000000  DCD 0x6c
 105AD11FC 0x65000000  DCD 0x65
 105AD1200 0x74000000  DCD 0x74
 105AD1204 0x65000000  DCD 0x65
 105AD1208 0xA0000000  DCD 0xa
 105AD120C 0x00000000  DCD 0x0
 105AD1210 0x00000000  DCD 0x0
L_pair0:
 105AD1214 0xA0000000  .quad 0x140000000a
 105AD1218 0x14000000  ; (upper half)

--------------------------

JIT runtime table populated with 128 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x105acc0a8
[JITExecutor] Starting execution of JIT-compiled function at address: 0x105acc0a8
Testing basic PAIR lane access
p1 = (10, 20)
p1.|0| = 0, p1.|1| = 0
Expected: p1.|0| = 10, p1.|1| = 20
Test complete
JIT Execution completed with result: 0
  Same value as double: 0
[JITExecutor] Execution completed. Result: 0

--- JIT returned with result: 0 ---

--- Generated Assembly Code (After Linking) ---
--- Code Section Listing (Base Address: 0x105acc000) ---
Address Hex Code    Assembly
--------------------------------------------------
 105acc000 0x00000000  
; --- Veneer Section ---
 0000000 0x00000000  DCD 0
HeapManager_enter_scope_veneer:
 105ACC004 0xD2889D90  MOVZ X16, #17644
 105ACC008 0xF2A00FB0  MOVK X16, #125, LSL #16
 105ACC00C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC010 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
HeapManager_exit_scope_veneer:
 105ACC014 0xD288A310  MOVZ X16, #17688
 105ACC018 0xF2A00FB0  MOVK X16, #125, LSL #16
 105ACC01C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC020 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF_veneer:
 105ACC024 0xD2983D10  MOVZ X16, #49640
 105ACC028 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC02C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC030 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF1_veneer:
 105ACC034 0xD298E110  MOVZ X16, #50952
 105ACC038 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC03C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC040 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF2_veneer:
 105ACC044 0xD298EE10  MOVZ X16, #51056
 105ACC048 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC04C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC050 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF3_veneer:
 105ACC054 0xD298FC90  MOVZ X16, #51172
 105ACC058 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC05C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC060 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF4_veneer:
 105ACC064 0xD2990C90  MOVZ X16, #51300
 105ACC068 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC06C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC070 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF5_veneer:
 105ACC074 0xD2991E10  MOVZ X16, #51440
 105ACC078 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC07C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC080 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF6_veneer:
 105ACC084 0xD2993110  MOVZ X16, #51592
 105ACC088 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC08C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC090 0xD61F0200  BR X16
 0000000 0x00000000  DCD 0
WRITEF7_veneer:
 105ACC094 0xD2994590  MOVZ X16, #51756
 105ACC098 0xF2A01010  MOVK X16, #128, LSL #16
 105ACC09C 0xF2C00030  MOVK X16, #1, LSL #32
 105ACC0A0 0xD61F0200  BR X16
 105ACC0A4 0x00000000  ; --- End Veneer Section ---

 0000000 0x00000000  DCD 0
START:
 105ACC0A8 0xA9BA7BFD  STP X29, X30, [SP, #-96]!
 105ACC0AC 0x910003FD  MOV X29, SP
 105ACC0B0 0xA902D3B3  STP x19, x20, [x29, #40]
 105ACC0B4 0xA903E7B5  STP x21, x25, [x29, #56]
 105ACC0B8 0xA904EFBA  STP x26, x27, [x29, #72]
 105ACC0BC 0xF9002FBC  STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
 105ACC0C0 0xD298001C  MOVZ X28, #49152
 105ACC0C4 0xF2A0B39C  MOVK X28, #1436, LSL #16
 105ACC0C8 0xF2C0003C  MOVK X28, #1, LSL #32
 105ACC0CC 0xF2E0001C  MOVK X28, #0, LSL #48
 0000000 0x00000000  DCD 0
START_Entry_0:
 105ACC0D0 0xB0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x105AD1000
 105ACC0D4 0x91000129  ADD X9, X9, #:lo12:L_str0    ; Reloc -> 'L_str0' @ 0x105AD1000
 105ACC0D8 0x91002129  ADD X9, X9, #8
 105ACC0DC 0xAA0903E0  MOV X0, X9
 105ACC0E0 0x97FFFFD1  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x105ACC024
 105ACC0E4 0xB0000029  ADRP X9, L_pair0    ; Reloc -> 'L_pair0' @ 0x105AD1214
 105ACC0E8 0x91085129  ADD X9, X9, #:lo12:L_pair0    ; Reloc -> 'L_pair0' @ 0x105AD1214
 105ACC0EC 0xF9400129  LDR X9, [X9, #0]
 105ACC0F0 0xAA0903FA  MOV X26, X9
 105ACC0F4 0xB0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x105AD108C
 105ACC0F8 0x91023129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x105AD108C
 105ACC0FC 0x91002129  ADD X9, X9, #8
 105ACC100 0xAA0903E0  MOV X0, X9
 105ACC104 0xAA1A03E1  MOV X1, X26
 105ACC108 0x97FFFFCB  BL WRITEF1_veneer    ; Reloc -> 'WRITEF1_veneer' @ 0x105ACC034
 105ACC10C 0x9E660340  fmov D0, X26
 105ACC110 0xE043C140  mov.s w20, v0[0]
 105ACC114 0xAA1403FB  MOV X27, X20
 105ACC118 0x9E660340  fmov D0, X26
 105ACC11C 0xE0C3C140  mov.s w20, v0[1]
 105ACC120 0xAA1403F9  MOV X25, X20
 105ACC124 0xB0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x105AD10BC
 105ACC128 0x9102F129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x105AD10BC
 105ACC12C 0x91002129  ADD X9, X9, #8
 105ACC130 0xAA0903E0  MOV X0, X9
 105ACC134 0xAA1B03E1  MOV X1, X27
 105ACC138 0xAA1903E2  MOV X2, X25
 105ACC13C 0x97FFFFC2  BL WRITEF2_veneer    ; Reloc -> 'WRITEF2_veneer' @ 0x105ACC044
 105ACC140 0xB0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x105AD1130
 105ACC144 0x9104C129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x105AD1130
 105ACC148 0x91002129  ADD X9, X9, #8
 105ACC14C 0xAA0903E0  MOV X0, X9
 105ACC150 0x97FFFFB5  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x105ACC024
 105ACC154 0xB0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x105AD11CC
 105ACC158 0x91073129  ADD X9, X9, #:lo12:L_str4    ; Reloc -> 'L_str4' @ 0x105AD11CC
 105ACC15C 0x91002129  ADD X9, X9, #8
 105ACC160 0xAA0903E0  MOV X0, X9
 105ACC164 0x97FFFFB0  BL WRITEF_veneer    ; Reloc -> 'WRITEF_veneer' @ 0x105ACC024
 105ACC168 0x14000001  B START_Exit_1    ; Reloc -> 'START_Exit_1' @ 0x105ACC16C
 0000000 0x00000000  DCD 0
START_Exit_1:
 105ACC16C 0x14000001  B .L0    ; Reloc -> '.L0' @ 0x105ACC170
 0000000 0x00000000  DCD 0
.L0:
 105ACC170 0xA942D3B3  LDP x19, x20, [x29, #40]
 105ACC174 0xA943E7B5  LDP x21, x25, [x29, #56]
 105ACC178 0xA944EFBA  LDP x26, x27, [x29, #72]
 105ACC17C 0xF9402FBC  LDR X28, [X29, #88] ; Restored Reg: X28 @ FP+88
 105ACC180 0x910003BF  MOV SP, X29 ; Deallocate frame by moving FP to SP
 105ACC184 0xA9407BFD  LDP x29, x30, [SP, #0]
 105ACC188 0x910043FF  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 105ACC18C 0xD65F03C0  RET
 0000000 0x00000000  DCD 0
L_str0:
 105AD1000 0x1F000000  .quad 0x1f
 105AD1004 0x00000000  ; (upper half)
 105AD1008 0x54000000  DCD 0x54
 105AD100C 0x65000000  DCD 0x65
 105AD1010 0x73000000  DCD 0x73
 105AD1014 0x74000000  DCD 0x74
 105AD1018 0x69000000  DCD 0x69
 105AD101C 0x6E000000  DCD 0x6e
 105AD1020 0x67000000  DCD 0x67
 105AD1024 0x20000000  DCD 0x20
 105AD1028 0x62000000  DCD 0x62
 105AD102C 0x61000000  DCD 0x61
 105AD1030 0x73000000  DCD 0x73
 105AD1034 0x69000000  DCD 0x69
 105AD1038 0x63000000  DCD 0x63
 105AD103C 0x20000000  DCD 0x20
 105AD1040 0x50000000  DCD 0x50
 105AD1044 0x41000000  DCD 0x41
 105AD1048 0x49000000  DCD 0x49
 105AD104C 0x52000000  DCD 0x52
 105AD1050 0x20000000  DCD 0x20
 105AD1054 0x6C000000  DCD 0x6c
 105AD1058 0x61000000  DCD 0x61
 105AD105C 0x6E000000  DCD 0x6e
 105AD1060 0x65000000  DCD 0x65
 105AD1064 0x20000000  DCD 0x20
 105AD1068 0x61000000  DCD 0x61
 105AD106C 0x63000000  DCD 0x63
 105AD1070 0x63000000  DCD 0x63
 105AD1074 0x65000000  DCD 0x65
 105AD1078 0x73000000  DCD 0x73
 105AD107C 0x73000000  DCD 0x73
 105AD1080 0xA0000000  DCD 0xa
 105AD1084 0x00000000  DCD 0x0
 105AD1088 0x00000000  DCD 0x0
 1059CC000 0x00000000  DCD 0x0
 0000000 0x00000000  DCD 0
L_str1:
 105AD108C 0x80000000  .quad 0x8
 105AD1090 0x00000000  ; (upper half)
 105AD1094 0x70000000  DCD 0x70
 105AD1098 0x31000000  DCD 0x31
 105AD109C 0x20000000  DCD 0x20
 105AD10A0 0x3D000000  DCD 0x3d
 105AD10A4 0x20000000  DCD 0x20
 105AD10A8 0x25000000  DCD 0x25
 105AD10AC 0x50000000  DCD 0x50
 105AD10B0 0xA0000000  DCD 0xa
 105AD10B4 0x00000000  DCD 0x0
 105AD10B8 0x00000000  DCD 0x0
 1059CC004 0x00000000  DCD 0x0
 0000000 0x00000000  DCD 0
L_str2:
 105AD10BC 0x19000000  .quad 0x19
 105AD10C0 0x00000000  ; (upper half)
 105AD10C4 0x70000000  DCD 0x70
 105AD10C8 0x31000000  DCD 0x31
 105AD10CC 0x2E000000  DCD 0x2e
 105AD10D0 0x7C000000  DCD 0x7c
 105AD10D4 0x30000000  DCD 0x30
 105AD10D8 0x7C000000  DCD 0x7c
 105AD10DC 0x20000000  DCD 0x20
 105AD10E0 0x3D000000  DCD 0x3d
 105AD10E4 0x20000000  DCD 0x20
 105AD10E8 0x25000000  DCD 0x25
 105AD10EC 0x4E000000  DCD 0x4e
 105AD10F0 0x2C000000  DCD 0x2c
 105AD10F4 0x20000000  DCD 0x20
 105AD10F8 0x70000000  DCD 0x70
 105AD10FC 0x31000000  DCD 0x31
 105AD1100 0x2E000000  DCD 0x2e
 105AD1104 0x7C000000  DCD 0x7c
 105AD1108 0x31000000  DCD 0x31
 105AD110C 0x7C000000  DCD 0x7c
 105AD1110 0x20000000  DCD 0x20
 105AD1114 0x3D000000  DCD 0x3d
 105AD1118 0x20000000  DCD 0x20
 105AD111C 0x25000000  DCD 0x25
 105AD1120 0x4E000000  DCD 0x4e
 105AD1124 0xA0000000  DCD 0xa
 105AD1128 0x00000000  DCD 0x0
 105AD112C 0x00000000  DCD 0x0
 0000000 0x00000000  DCD 0
L_str3:
 105AD1130 0x23000000  .quad 0x23
 105AD1134 0x00000000  ; (upper half)
 105AD1138 0x45000000  DCD 0x45
 105AD113C 0x78000000  DCD 0x78
 105AD1140 0x70000000  DCD 0x70
 105AD1144 0x65000000  DCD 0x65
 105AD1148 0x63000000  DCD 0x63
 105AD114C 0x74000000  DCD 0x74
 105AD1150 0x65000000  DCD 0x65
 105AD1154 0x64000000  DCD 0x64
 105AD1158 0x3A000000  DCD 0x3a
 105AD115C 0x20000000  DCD 0x20
 105AD1160 0x70000000  DCD 0x70
 105AD1164 0x31000000  DCD 0x31
 105AD1168 0x2E000000  DCD 0x2e
 105AD116C 0x7C000000  DCD 0x7c
 105AD1170 0x30000000  DCD 0x30
 105AD1174 0x7C000000  DCD 0x7c
 105AD1178 0x20000000  DCD 0x20
 105AD117C 0x3D000000  DCD 0x3d
 105AD1180 0x20000000  DCD 0x20
 105AD1184 0x31000000  DCD 0x31
 105AD1188 0x30000000  DCD 0x30
 105AD118C 0x2C000000  DCD 0x2c
 105AD1190 0x20000000  DCD 0x20
 105AD1194 0x70000000  DCD 0x70
 105AD1198 0x31000000  DCD 0x31
 105AD119C 0x2E000000  DCD 0x2e
 105AD11A0 0x7C000000  DCD 0x7c
 105AD11A4 0x31000000  DCD 0x31
 105AD11A8 0x7C000000  DCD 0x7c
 105AD11AC 0x20000000  DCD 0x20
 105AD11B0 0x3D000000  DCD 0x3d
 105AD11B4 0x20000000  DCD 0x20
 105AD11B8 0x32000000  DCD 0x32
 105AD11BC 0x30000000  DCD 0x30
 105AD11C0 0xA0000000  DCD 0xa
 105AD11C4 0x00000000  DCD 0x0
 105AD11C8 0x00000000  DCD 0x0
 0000000 0x00000000  DCD 0
L_str4:
 105AD11CC 0xE0000000  .quad 0xe
 105AD11D0 0x00000000  ; (upper half)
 105AD11D4 0x54000000  DCD 0x54
 105AD11D8 0x65000000  DCD 0x65
 105AD11DC 0x73000000  DCD 0x73
 105AD11E0 0x74000000  DCD 0x74
 105AD11E4 0x20000000  DCD 0x20
 105AD11E8 0x63000000  DCD 0x63
 105AD11EC 0x6F000000  DCD 0x6f
 105AD11F0 0x6D000000  DCD 0x6d
 105AD11F4 0x70000000  DCD 0x70
 105AD11F8 0x6C000000  DCD 0x6c
 105AD11FC 0x65000000  DCD 0x65
 105AD1200 0x74000000  DCD 0x74
 105AD1204 0x65000000  DCD 0x65
 105AD1208 0xA0000000  DCD 0xa
 105AD120C 0x00000000  DCD 0x0
 105AD1210 0x00000000  DCD 0x0
 1059CC008 0x00000000  DCD 0x0
 0000000 0x00000000  DCD 0
L_pair0:
 105AD1214 0xA0000000  .quad 0x140000000a
 105AD1218 0x14000000  ; (upper half)
 0000000 0x00000000  DCD 0

-----------------------------------------------


--- BCPL Runtime Metrics ---
Memory allocations: 0 (0 bytes)
Memory frees: 0 (0 bytes)
Vector allocations: 0
String allocations: 0
Double-free attempts: 0
Current active allocations: 0 (0 bytes)
Bloom filter statistics:
  Items tracked: 0
  Memory usage: 12000000 bytes
  False positives: 0
  Est. false positive rate: 0.0000%
File I/O operations:
  Files opened: 0
  Files closed: 0
  Bytes read: 0
  Bytes written: 0
  Open files: 0
--------------------------
SAMM: Processed all pending cleanup operations
SAMM: Worker woke up, queue size: 0, running: NO
SAMM: Background cleanup worker thread stopped (DEBUG)
SAMM: Background worker stopped
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: Shutdown complete
