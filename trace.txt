NeonReducerRegistry: Registered 13 NEON reduction encoders
Found source file: test_split_join_simple.bcl
Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=test_split_join_simple.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.2421
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/test_split_join_simple.bcl"
LET START() BE
$(
   WRITES("Testing SPLIT->JOIN round-trip...*N")

   LET S1 = "hello world test"
   WRITES("Original string: ")
   WRITES(S1)
   WRITES("*N")

   WRITES("Calling SPLIT...*N")
   LET L = SPLIT(S1, " ")
   WRITES("SPLIT completed*N")

   TEST L = 0 THEN
   $(
       WRITES("ERROR: SPLIT returned null*N")
   $)
   ELSE
   $(
       WRITES("SPLIT returned a list, now calling JOIN...*N")
       LET S2 = JOIN(L, "-")
       WRITES("JOIN completed*N")

       TEST S2 = 0 THEN
       $(
           WRITES("ERROR: JOIN returned null*N")
       $)
       ELSE
       $(
           WRITES("JOIN result: ")
           WRITES(S2)
           WRITES("*N")
       $)
   $)
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x100e33d68
Registered 92 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x100e32a9c | args: 0 | table_offset: 720
  FINISH           | address: 0x100e3184c | args: 0 | table_offset: 712
  FABS             | address: 0x100e31bfc | args: 1 | table_offset: 680
  FSIN             | address: 0x100e31bc0 | args: 1 | table_offset: 656
  FILE_EOF         | address: 0x100e34fac | args: 1 | table_offset: 624
  RAND             | address: 0x100e31a4c | args: 1 | table_offset: 632
  FILE_TELL        | address: 0x100e34f54 | args: 1 | table_offset: 616
  FILE_SEEK        | address: 0x100e34e90 | args: 3 | table_offset: 608
  FILE_WRITE       | address: 0x100e34d78 | args: 3 | table_offset: 600
  FIX              | address: 0x100e31c3c | args: 1 | table_offset: 704
  FILE_READS       | address: 0x100e347c4 | args: 1 | table_offset: 584
  FILE_WRITES      | address: 0x100e344e8 | args: 2 | table_offset: 576
  FEXP             | address: 0x100e31c28 | args: 1 | table_offset: 696
  FILE_CLOSE       | address: 0x100e3447c | args: 1 | table_offset: 568
  FILE_OPEN_APPEND | address: 0x100e343ec | args: 1 | table_offset: 560
  PACKSTRING       | address: 0x100e31c54 | args: 1 | table_offset: 512
  STRLEN           | address: 0x100e3185c | args: 1 | table_offset: 504
  FCOS             | address: 0x100e31bd4 | args: 1 | table_offset: 664
  STRCMP           | address: 0x100e318bc | args: 2 | table_offset: 496
  STRCOPY          | address: 0x100e319a0 | args: 2 | table_offset: 488
  FIND             | address: 0x100e386b0 | args: 3 | table_offset: 456
  DEEPCOPYLITERALLIST | address: 0x100e38328 | args: 1 | table_offset: 440
  DEEPCOPYLIST     | address: 0x100e38190 | args: 1 | table_offset: 432
  COPYLIST         | address: 0x100e38090 | args: 1 | table_offset: 424
  CONCAT           | address: 0x100e384c8 | args: 2 | table_offset: 416
  BCPL_CONCAT_LISTS | address: 0x100e384c8 | args: 2 | table_offset: 408
  SPIT             | address: 0x100e32850 | args: 2 | table_offset: 536
  JOIN             | address: 0x100e33f84 | args: 2 | table_offset: 480
  LPND             | address: 0x100e37c3c | args: 2 | table_offset: 400
  SPND             | address: 0x100e37b6c | args: 2 | table_offset: 392
  FPND             | address: 0x100e37a9c | args: 2 | table_offset: 384
  APND             | address: 0x100e379cc | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x100e38b80 | args: 1 | table_offset: 728
  BCPL_LIST_APPEND_INT | address: 0x100e379cc | args: 2 | table_offset: 352
  GETVEC           | address: 0x100e33e2c | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x100df48b0 | args: 0 | table_offset: 320
  HEAPMANAGER_ENTER_SCOPE | address: 0x100df47e8 | args: 0 | table_offset: 288
  HEAPMANAGER_SETSAMMENABLED | address: 0x100df4794 | args: 1 | table_offset: 304
  HEAPMANAGER_EXIT_SCOPE | address: 0x100df4814 | args: 0 | table_offset: 296
  PIC_RUNTIME_HELPER | address: 0x100e33f14 | args: 0 | table_offset: 280
  OBJECT_HEAP_FREE | address: 0x100e33ed8 | args: 1 | table_offset: 264
  OBJECT_HEAP_ALLOC | address: 0x100e33eb4 | args: 1 | table_offset: 256
  BCPL_LIST_GET_REST | address: 0x100e37ef8 | args: 1 | table_offset: 224
  FRND             | address: 0x100e31ad8 | args: 0 | table_offset: 648
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x100e37e40 | args: 1 | table_offset: 208
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x100e37ddc | args: 1 | table_offset: 200
  RUNTIME_METHOD_LOOKUP | address: 0x100e33efc | args: 2 | table_offset: 272
  FREEVEC          | address: 0x100e33d68 | args: 1 | table_offset: 144
  BCPL_BOUNDS_ERROR | address: 0x100e2f9a4 | args: 3 | table_offset: 192
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x100e38bc8 | args: 0 | table_offset: 184
  WRITEF4          | address: 0x100e31380 | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x100e38854 | args: 1 | table_offset: 152
  BCPL_ALLOC_CHARS | address: 0x100e33d10 | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x100e37a9c | args: 2 | table_offset: 360
  GET_FREE_LIST_HEAD_ADDR | address: 0x100e38b74 | args: 0 | table_offset: 336
  BCPL_GET_ATOM_TYPE | address: 0x100e37f5c | args: 1 | table_offset: 232
  FWRITE           | address: 0x100e30cc0 | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x100e3796c | args: 0 | table_offset: 344
  SPLIT            | address: 0x100e33fb0 | args: 2 | table_offset: 472
  BCPL_FREE_CELLS  | address: 0x100e38b70 | args: 0 | table_offset: 328
  RND              | address: 0x100e31b2c | args: 1 | table_offset: 640
  HEAPMANAGER_ISSAMMENABLED | address: 0x100df47c4 | args: 0 | table_offset: 312
  WRITEC           | address: 0x100e3163c | args: 1 | table_offset: 88
  MALLOC           | address: 0x100e33cb0 | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x100e33cb0 | args: 3 | table_offset: 104
  FTAN             | address: 0x100e31be8 | args: 1 | table_offset: 672
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 248
  BCPL_GET_LAST_ERROR | address: 0x100e2f824 | args: 1 | table_offset: 168
  RDCH             | address: 0x100e31800 | args: 0 | table_offset: 96
  FILE_READ        | address: 0x100e34c64 | args: 3 | table_offset: 592
  UNPACKSTRING     | address: 0x100e31f8c | args: 1 | table_offset: 520
  WRITEF5          | address: 0x100e3140c | args: 6 | table_offset: 64
  FILTER           | address: 0x100e387a4 | args: 2 | table_offset: 464
  BCPL_FREE_LIST_SAFE | address: 0x100e3895c | args: 1 | table_offset: 160
  FILE_OPEN_WRITE  | address: 0x100e3435c | args: 1 | table_offset: 552
  FILE_OPEN_READ   | address: 0x100e33fdc | args: 1 | table_offset: 544
  BCPL_LIST_GET_NTH | address: 0x100e37fc4 | args: 2 | table_offset: 240
  WRITEF7          | address: 0x100e31548 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x100e31300 | args: 4 | table_offset: 48
  WRITEF6          | address: 0x100e314a4 | args: 7 | table_offset: 72
  REVERSE          | address: 0x100e385c8 | args: 1 | table_offset: 448
  WRITEF2          | address: 0x100e3128c | args: 3 | table_offset: 40
  WRITEF1          | address: 0x100e31224 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x100e37ea8 | args: 1 | table_offset: 216
  BCPL_CLEAR_ERRORS | address: 0x100e2f8d4 | args: 0 | table_offset: 176
  WRITEF           | address: 0x100e30d04 | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x100e37b6c | args: 2 | table_offset: 368
  WRITES           | address: 0x100e30764 | args: 1 | table_offset: 0
  SLURP            | address: 0x100e32324 | args: 1 | table_offset: 528
  FGETVEC          | address: 0x100e33e60 | args: 1 | table_offset: 136
  FLOG             | address: 0x100e31c14 | args: 1 | table_offset: 688
  WRITEN           | address: 0x100e315f8 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: S1 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: L as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing FunctionCall
[SymbolDiscoveryPass] Processing test statement
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: S2 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing FunctionCall
[SymbolDiscoveryPass] Processing test statement
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Entering block scope

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'S1' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'S2' (LOCAL_VAR, INTEGER, scope=3, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 9 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11140
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11170
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c111a0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c111d0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11200
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 52
[ANALYZER TRACE]   Detected call to runtime function: SPLIT, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11230
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 56
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Entering block scope: START_block_0_block_2 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11260
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Entering block scope: START_block_0_block_2 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 4 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11290
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE]   Detected call to runtime function: JOIN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c112c0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 56
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] Entering block scope: START_block_0_block_2_block_3 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c112f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0_block_2
[ANALYZER TRACE] Entering block scope: START_block_0_block_2_block_3 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 3 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11320
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11350
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x9f6c11380
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0_block_2
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 1
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 1
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 15
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Tracking variable 'S1' in current block
[CFGBuilderPass] Tracking variable 'L' in current block
[CFGBuilderPass] visit(TestStatement) entered.
[CFGBuilderPass] Created new basic block: START_Then_1
[CFGBuilderPass] Created new basic block: START_Else_2
[CFGBuilderPass] Created new basic block: START_Join_3
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 2 variable tracking
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 3 variable tracking
[CFGBuilderPass] Tracking variable 'S2' in current block
[CFGBuilderPass] visit(TestStatement) entered.
[CFGBuilderPass] Created new basic block: START_Then_4
[CFGBuilderPass] Created new basic block: START_Else_5
[CFGBuilderPass] Created new basic block: START_Join_6
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 4 variable tracking
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 5 variable tracking
[CFGBuilderPass] visit(TestStatement) exiting.
[CFGBuilderPass] visit(TestStatement) exiting.
[CFGBuilderPass] Created new basic block: START_Exit_7
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]     Found jump-only block: START_Join_3 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Then_1 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Join_6 -> START_Exit_7
[CFGSimplificationPass]     Eliminated block: START_Join_3
[CFGSimplificationPass]     Found jump-only block: START_Join_6 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Then_4 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Else_5 -> START_Exit_7
[CFGSimplificationPass]     Eliminated block: START_Join_6
[CFGSimplificationPass]     Removing unreachable block: START_Join_3
[CFGSimplificationPass]     Removing unreachable block: START_Join_6
[CFGSimplificationPass]   Iteration 2
[CFGSimplificationPass]   Simplification completed after 2 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 2
  Edges redirected: 4
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 6 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_7) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_7
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_7 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_7
[LivenessAnalysisPass] Analyzing block #2 (id=START_Else_5) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Else_5
[LivenessAnalysisPass] Starting intra-block analysis for START_Else_5 with 3 statements
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S2
[LivenessAnalysisPass] Reverse scan - Statement 1 uses variables: S2 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S2 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 1
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Else_5 - variables live across calls: S2 
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Else_5
[LivenessAnalysisPass] Analyzing block #3 (id=START_Then_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Then_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Then_1 with 1 statements
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Then_1 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Then_1
[LivenessAnalysisPass] Analyzing block #4 (id=START_Then_4) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Then_4
[LivenessAnalysisPass] Starting intra-block analysis for START_Then_4 with 1 statements
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Then_4 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Then_4
[LivenessAnalysisPass] Analyzing block #5 (id=START_Else_2) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Else_2
[LivenessAnalysisPass] Starting intra-block analysis for START_Else_2 with 4 statements
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 13TestStatement
[LivenessAnalysisPass] Reverse scan - Statement 3 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 12FunctionCall
[LivenessAnalysisPass] Found FunctionCall with 2 arguments
[LivenessAnalysisPass] Function name: JOIN
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: L
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 1 uses variables: L 
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: L 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 1
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Else_2 - variables live across calls: L 
[LivenessAnalysisPass] Block START_Else_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_2 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Else_2
[LivenessAnalysisPass] Analyzing block #6 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 9 statements
[LivenessAnalysisPass] Reverse scan - processing statement 8 type: 13TestStatement
[LivenessAnalysisPass] Reverse scan - Statement 8 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 8 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 7 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 7 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 7 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 7
[LivenessAnalysisPass] Reverse scan - processing statement 6 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 12FunctionCall
[LivenessAnalysisPass] Found FunctionCall with 2 arguments
[LivenessAnalysisPass] Function name: SPLIT
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S1
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 6 uses variables: S1 
[LivenessAnalysisPass] Reverse scan - Statement 6 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S1 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 6
[LivenessAnalysisPass] Reverse scan - processing statement 5 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 5 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 5 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 5
[LivenessAnalysisPass] Reverse scan - processing statement 4 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 4 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 4 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 4
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S1
[LivenessAnalysisPass] Reverse scan - Statement 3 uses variables: S1 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S1 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 3
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 1 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: NO
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Entry_0 - variables live across calls: S1 
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_7 in function: START
[LivenessAnalysisPass] Processing block: START_Then_1 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_1 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Then_4 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_4 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Else_5 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_5 - adding 0 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Else_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_2 - adding 1 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_7 in function: START
[LivenessAnalysisPass] Processing block: START_Then_1 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_1 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Then_4 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_4 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Else_5 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_5 - adding 0 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Else_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_2 - adding 1 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_7
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Else_5
  Use: { S2 }
  Def: { }
  In : { S2 }
  Out: { }
Block ID: START_Then_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Then_4
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Else_2
  Use: { L }
  Def: { S2 }
  In : { L S2 }
  Out: { S2 }
Block ID: START_Entry_0
  Use: { S1 }
  Def: { L S1 }
  In : { L S1 S2 }
  Out: { L S2 }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_7 (conceptual)

Block ID: START_Exit_7 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Then_1, START_Then_4, START_Else_5

Block ID: START_Else_5
  Statements:
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Else_2

Block ID: START_Then_1
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Entry_0

Block ID: START_Then_4
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Else_2

Block ID: START_Else_2
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - TestStmt
  Successors: START_Then_4, START_Else_5
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - TestStmt
  Successors: START_Then_1, START_Else_2
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[LiveIntervalPass] Created 3 intervals for function: START
  L: [0-11]
  S1: [0-6]
  S2: [0-16]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 9, float registers: 8
[Allocator] Function has 15 call sites at: 0 4 8 12 16 20 25 29 33 37 42 46 50 54 58 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 0, Reserved scratch INT: 0
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 0
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing L [0-11]
  Assigned callee-saved register X27 to L
[ALLOC] Updated allocations for L: spilled=0, register='X27'
[Allocator] Allocating call-crossing S1 [0-6]
  Assigned callee-saved register X26 to S1
[ALLOC] Updated allocations for S1: spilled=0, register='X26'
[Allocator] Allocating call-crossing S2 [0-16]
  Assigned callee-saved register X25 to S2
[ALLOC] Updated allocations for S2: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 0 scratch registers for code generation: 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 6
  Free float registers: 8
  ✓ No register conflicts detected
[Allocator] Results:
  L: reg X27 (callee-saved) [call-crossing]
  S1: reg X26 (callee-saved) [call-crossing]
  S2: reg X25 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 15
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 3
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4399169536
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 3 unique external functions:
[DEBUG]   - JOIN
[DEBUG]   - SPLIT
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] Generating 5 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: JOIN_veneer for function: JOIN
[VeneerManager] Created veneer: SPLIT_veneer for function: SPLIT
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 5 veneers, estimated total size: 100 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Caching live intervals for function: START
[SYNC] Found 3 variable allocations
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 3
[DEBUG] DEBUG: variable_types['L'] = POINTER_TO|LIST|STRING
[DEBUG] DEBUG: variable_types['S1'] = POINTER_TO|STRING
[DEBUG] DEBUG: variable_types['S2'] = POINTER_TO|STRING
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'L' of type 1081348 at offset 16 (size 8)
[DEBUG] Registered local 'L' from analyzer metrics.
Added local variable 'S1' of type 1048580 at offset 24 (size 8)
[DEBUG] Registered local 'S1' from analyzer metrics.
Added local variable 'S2' of type 1048580 at offset 32 (size 8)
[DEBUG] Registered local 'S2' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S1                             | POINTER_TO|STRING
+32      | Local: S2                             | POINTER_TO|STRING
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[LIVE] Updating live intervals at instruction point -1
[LIVE] Freed register X25 (no active variables)
[LIVE] Freed register X27 (no active variables)
[LIVE] Freed register X26 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
[LIVE] Updating live intervals at instruction point -1
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S1                             | POINTER_TO|STRING
+32      | Local: S2                             | POINTER_TO|STRING
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0_plus_8
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Testing SPLIT->JOIN round-trip...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1_plus_8
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'hello world test'.
[DEBUG] Registering canonical address: S1 = STRING_LITERAL:"hello world test"
[DEBUG] Registered canonical address: S1 = STRING_LITERAL:"hello world test"
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: S1
[DEBUG] store_variable_register for 'S1' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable 'S1' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X26 for variable 'S1' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X26, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2_plus_8
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Original string: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S1' in function 'START'
[DEBUG] get_variable_register for: 'S1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S1' lives in register X26
[DEBUG] Variable 'S1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X26 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X26
[DEBUG] Deferring release of source register: X26
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X26
[DEBUG] Releasing source register: X26
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3_plus_8
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4_plus_8
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Calling SPLIT...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'S1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S1' in function 'START'
[DEBUG] get_variable_register for: 'S1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S1' lives in register X26
[DEBUG] Variable 'S1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X26
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str5
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str5_plus_8
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal ' '.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Found function symbol: SPLIT with 2 parameters
[DEBUG]   Parameter 0 type: STRING
[DEBUG]   Parameter 1 type: STRING
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X20 expr_type=POINTER_TO|STRING expected=STRING target=STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Arg 1: src=X20 expr_type=POINTER_TO|STRING expected=STRING target=STRING
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X1, X20
[DEBUG] Releasing source register: X20
[DEBUG] Releasing source register: X20
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL SPLIT_veneer
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Handling assignment for variable: L
[DEBUG] store_variable_register for 'L' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'L' lives in X27. Emitting MOV.
[DEBUG]   [LOOP VAR PROTECTION] Extra protection for loop variable: L
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X27 for variable 'L' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X27, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X10 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X10, L_str6
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X26 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: ADD X10, X10, #:lo12:L_str6_plus_8
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'SPLIT completed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X10 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X10
[DEBUG] Deferring release of source register: X10
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X10
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X10
[DEBUG] Releasing source register: X10
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting TestStatement node (NOTE: branching is handled by block epilogue).
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1081348, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X27
[DEBUG] Variable 'L' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] LEFT side evaluation complete. left_reg = 'X27'
[DEBUG] OPTIMIZATION: Right operand is constant: 0
[DEBUG] Checking type promotion: left_reg=X27, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X27
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: CMP X9, #0
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: CSET X10, EQ
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X10
[DEBUG LEVEL 5] Emitting instruction: CMP X10, XZR
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_Else_2
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B START_Then_1
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str7
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str7_plus_8
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'SPLIT returned a list, now calling JOIN...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X27
[DEBUG] Variable 'L' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X27
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str8
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str8_plus_8
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '-'.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Found function symbol: JOIN with 2 parameters
[DEBUG]   Parameter 0 type: POINTER_TO|LIST|STRING
[DEBUG]   Parameter 1 type: STRING
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X20 expr_type=POINTER_TO|LIST|STRING expected=POINTER_TO|LIST|STRING target=POINTER_TO|LIST|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Arg 1: src=X20 expr_type=POINTER_TO|STRING expected=STRING target=STRING
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X1, X20
[DEBUG] Releasing source register: X20
[DEBUG] Releasing source register: X20
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL JOIN_veneer
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Handling assignment for variable: S2
[DEBUG] store_variable_register for 'S2' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'S2' lives in X25. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X0
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X25 for variable 'S2' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X25, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X10 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X10, L_str9
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X10, X10, #:lo12:L_str9_plus_8
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'JOIN completed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X10 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X10
[DEBUG] Deferring release of source register: X10
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X10
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X10
[DEBUG] Releasing source register: X10
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting TestStatement node (NOTE: branching is handled by block epilogue).
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1048580, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'S2'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S2' in function 'START'
[DEBUG] get_variable_register for: 'S2' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S2' lives in register X25
[DEBUG] Variable 'S2' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] LEFT side evaluation complete. left_reg = 'X25'
[DEBUG] OPTIMIZATION: Right operand is constant: 0
[DEBUG] Checking type promotion: left_reg=X25, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X25
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X27 (no active variables)
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: CMP X9, #0
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: CSET X10, EQ
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X10
[DEBUG LEVEL 5] Emitting instruction: CMP X10, XZR
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_Else_5
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B START_Then_4
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10_plus_8
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'JOIN result: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S2'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S2' in function 'START'
[DEBUG] get_variable_register for: 'S2' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S2' lives in register X25
[DEBUG] Variable 'S2' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X25 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X25
[DEBUG] Deferring release of source register: X25
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X25
[LIVE] Updating live intervals at instruction point 14
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X25
[DEBUG] Releasing source register: X25
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 14
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3_plus_8
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B .L0
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11_plus_8
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'ERROR: SPLIT returned null
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str12
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[LIVE] Freed register X25 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str12_plus_8
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'ERROR: JOIN returned null
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str0_plus_8
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str1_plus_8
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str2_plus_8
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str3_plus_8
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_str4_plus_8
[InstructionStream TRACE] Adding label definition: L_str5
[InstructionStream TRACE] Adding label definition: L_str5_plus_8
[InstructionStream TRACE] Adding label definition: L_str6
[InstructionStream TRACE] Adding label definition: L_str6_plus_8
[InstructionStream TRACE] Adding label definition: L_str7
[InstructionStream TRACE] Adding label definition: L_str7_plus_8
[InstructionStream TRACE] Adding label definition: L_str8
[InstructionStream TRACE] Adding label definition: L_str8_plus_8
[InstructionStream TRACE] Adding label definition: L_str9
[InstructionStream TRACE] Adding label definition: L_str9_plus_8
[InstructionStream TRACE] Adding label definition: L_str10
[InstructionStream TRACE] Adding label definition: L_str10_plus_8
[InstructionStream TRACE] Adding label definition: L_str11
[InstructionStream TRACE] Adding label definition: L_str11_plus_8
[InstructionStream TRACE] Adding label definition: L_str12
[InstructionStream TRACE] Adding label definition: L_str12_plus_8
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'S1' (LOCAL_VAR, POINTER_TO|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, POINTER_TO|LIST|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'S2' (LOCAL_VAR, POINTER_TO|STRING, scope=3, block=0, class_name='', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='Global', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPLIT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING, STRING])
Symbol 'JOIN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[POINTER_TO|LIST|STRING, STRING])
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')

Data sections generated.

=== Peephole Optimization ===
Analyzing 459 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 30
  Before:
    STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40  [Opcode=26, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
    STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48  [Opcode=26, Dest=-1, Src1=20, Imm=48, Base=29, Offset=48]
  After:
    STP x19, x20, [x29, #40]  [Opcode=30, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 31
  Before:
    STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56  [Opcode=26, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
    STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64  [Opcode=26, Dest=-1, Src1=25, Imm=64, Base=29, Offset=64]
  After:
    STP x21, x25, [x29, #56]  [Opcode=30, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 32
  Before:
    STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72  [Opcode=26, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
    STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80  [Opcode=26, Dest=-1, Src1=27, Imm=80, Base=29, Offset=80]
  After:
    STP x26, x27, [x29, #72]  [Opcode=30, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: In-place comparison optimization (MOV-CMP -> CMP)
  Position: 72
  Before:
    MOV X9, X27  [Opcode=1, Dest=9, Src1=27]
    CMP X9, #0  [Opcode=24, Dest=-1, Src1=9, Imm=0]
  After:
    CMP x27, #0  [Opcode=24, Dest=-1, Src1=27, Imm=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: In-place comparison optimization (MOV-CMP -> CMP)
  Position: 94
  Before:
    MOV X9, X25  [Opcode=1, Dest=9, Src1=25]
    CMP X9, #0  [Opcode=24, Dest=-1, Src1=9, Imm=0]
  After:
    CMP x25, #0  [Opcode=24, Dest=-1, Src1=25, Imm=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 126
  Before:
    LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40  [Opcode=27, Dest=19, Src1=-1, Imm=40, Base=29, Offset=40]
    LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48  [Opcode=27, Dest=20, Src1=-1, Imm=48, Base=29, Offset=48]
  After:
    LDP x19, x20, [x29, #40]  [Opcode=31, Dest=19, Src1=20, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 127
  Before:
    LDR X21, [X29, #56] ; Restored Reg: X21 @ FP+56  [Opcode=27, Dest=21, Src1=-1, Imm=56, Base=29, Offset=56]
    LDR X25, [X29, #64] ; Restored Reg: X25 @ FP+64  [Opcode=27, Dest=25, Src1=-1, Imm=64, Base=29, Offset=64]
  After:
    LDP x21, x25, [x29, #56]  [Opcode=31, Dest=21, Src1=25, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 128
  Before:
    LDR X26, [X29, #72] ; Restored Reg: X26 @ FP+72  [Opcode=27, Dest=26, Src1=-1, Imm=72, Base=29, Offset=72]
    LDR X27, [X29, #80] ; Restored Reg: X27 @ FP+80  [Opcode=27, Dest=27, Src1=-1, Imm=80, Base=29, Offset=80]
  After:
    LDP x26, x27, [x29, #72]  [Opcode=31, Dest=26, Src1=27, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 131
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [SP, #0]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 459
  Instructions after:  450
  Total optimizations: 9
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 4
    - In-place comparison optimization (MOV-CMP -> CMP): 2
    - Combine adjacent X-register STRs into STP: 3
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x106360000) ---
Address Hex Code    Assembly
--------------------------------------------------
 106360000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 106360004 0xd288fd10  MOVZ X16, #18408
 106360008 0xf2a01bf0  MOVK X16, #223, LSL #16
 10636000c 0xf2c00030  MOVK X16, #1, LSL #32
 106360010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 106360014 0xd2890290  MOVZ X16, #18452
 106360018 0xf2a01bf0  MOVK X16, #223, LSL #16
 10636001c 0xf2c00030  MOVK X16, #1, LSL #32
 106360020 0xd61f0200  BR X16
JOIN_veneer:
 106360024 0xd287f090  MOVZ X16, #16260
 106360028 0xf2a01c70  MOVK X16, #227, LSL #16
 10636002c 0xf2c00030  MOVK X16, #1, LSL #32
 106360030 0xd61f0200  BR X16
SPLIT_veneer:
 106360034 0xd287f610  MOVZ X16, #16304
 106360038 0xf2a01c70  MOVK X16, #227, LSL #16
 10636003c 0xf2c00030  MOVK X16, #1, LSL #32
 106360040 0xd61f0200  BR X16
WRITES_veneer:
 106360044 0xd280ec90  MOVZ X16, #1892
 106360048 0xf2a01c70  MOVK X16, #227, LSL #16
 10636004c 0xf2c00030  MOVK X16, #1, LSL #32
 106360050 0xd61f0200  BR X16
 106360054 0x00000000  ; --- End Veneer Section ---

START:
 106360058 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 10636005c 0x910003fd  MOV X29, SP
 106360060 0xa902d3b3  STP x19, x20, [x29, #40]
 106360064 0xa903e7b5  STP x21, x25, [x29, #56]
 106360068 0xa904efba  STP x26, x27, [x29, #72]
 10636006c 0xf9002fbc  STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
 106360070 0xd290001c  MOVZ X28, #32768
 106360074 0xf2a0329c  MOVK X28, #404, LSL #16
 106360078 0xf2c0003c  MOVK X28, #1, LSL #32
 10636007c 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 106360080 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x106365000
 106360084 0x91002129  ADD X9, X9, #:lo12:L_str0_plus_8    ; Reloc -> 'L_str0' @ 0x106365000
 106360088 0xaa0903e0  MOV X0, X9
 10636008c 0x97ffffee  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 106360090 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x106365098
 106360094 0x91028129  ADD X9, X9, #:lo12:L_str1_plus_8    ; Reloc -> 'L_str1' @ 0x106365098
 106360098 0xaa0903fa  MOV X26, X9
 10636009c 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x1063650e8
 1063600a0 0x9103c129  ADD X9, X9, #:lo12:L_str2_plus_8    ; Reloc -> 'L_str2' @ 0x1063650e8
 1063600a4 0xaa0903e0  MOV X0, X9
 1063600a8 0x97ffffe7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 1063600ac 0xaa1a03e0  MOV X0, X26
 1063600b0 0x97ffffe5  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 1063600b4 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x10636513c
 1063600b8 0x91051129  ADD X9, X9, #:lo12:L_str3_plus_8    ; Reloc -> 'L_str3' @ 0x10636513c
 1063600bc 0xaa0903e0  MOV X0, X9
 1063600c0 0x97ffffe1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 1063600c4 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x106365150
 1063600c8 0x91056129  ADD X9, X9, #:lo12:L_str4_plus_8    ; Reloc -> 'L_str4' @ 0x106365150
 1063600cc 0xaa0903e0  MOV X0, X9
 1063600d0 0x97ffffdd  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 1063600d4 0xaa1a03f4  MOV X20, X26
 1063600d8 0xb0000029  ADRP X9, L_str5    ; Reloc -> 'L_str5' @ 0x1063651a4
 1063600dc 0x9106b129  ADD X9, X9, #:lo12:L_str5_plus_8    ; Reloc -> 'L_str5' @ 0x1063651a4
 1063600e0 0xaa0903f4  MOV X20, X9
 1063600e4 0xaa1403e0  MOV X0, X20
 1063600e8 0xaa1403e1  MOV X1, X20
 1063600ec 0x97ffffd2  BL SPLIT_veneer    ; Reloc -> 'SPLIT_veneer' @ 0x106360034
 1063600f0 0xaa0003fb  MOV X27, X0
 1063600f4 0xb000002a  ADRP X10, L_str6    ; Reloc -> 'L_str6' @ 0x1063651b8
 1063600f8 0x9107014a  ADD X10, X10, #:lo12:L_str6_plus_8    ; Reloc -> 'L_str6' @ 0x1063651b8
 1063600fc 0xaa0a03e0  MOV X0, X10
 106360100 0x97ffffd1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 106360104 0xf100037f  CMP x27, #0
 106360108 0x9a9f17ea  CSET X10, EQ
 10636010c 0xeb1f015f  CMP X10, XZR
 106360110 0x54000040  B.EQ START_Else_2    ; Reloc -> 'START_Else_2' @ 0x106360118
 106360114 0x14000022  B START_Then_1    ; Reloc -> 'START_Then_1' @ 0x10636019c
START_Else_2:
 106360118 0xb0000029  ADRP X9, L_str7    ; Reloc -> 'L_str7' @ 0x106365208
 10636011c 0x91084129  ADD X9, X9, #:lo12:L_str7_plus_8    ; Reloc -> 'L_str7' @ 0x106365208
 106360120 0xaa0903e0  MOV X0, X9
 106360124 0x97ffffc8  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 106360128 0xaa1b03f4  MOV X20, X27
 10636012c 0xb0000029  ADRP X9, L_str8    ; Reloc -> 'L_str8' @ 0x1063652c4
 106360130 0x910b3129  ADD X9, X9, #:lo12:L_str8_plus_8    ; Reloc -> 'L_str8' @ 0x1063652c4
 106360134 0xaa0903f4  MOV X20, X9
 106360138 0xaa1403e0  MOV X0, X20
 10636013c 0xaa1403e1  MOV X1, X20
 106360140 0x97ffffb9  BL JOIN_veneer    ; Reloc -> 'JOIN_veneer' @ 0x106360024
 106360144 0xaa0003f9  MOV X25, X0
 106360148 0xb000002a  ADRP X10, L_str9    ; Reloc -> 'L_str9' @ 0x1063652d8
 10636014c 0x910b814a  ADD X10, X10, #:lo12:L_str9_plus_8    ; Reloc -> 'L_str9' @ 0x1063652d8
 106360150 0xaa0a03e0  MOV X0, X10
 106360154 0x97ffffbc  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 106360158 0xf100033f  CMP x25, #0
 10636015c 0x9a9f17ea  CSET X10, EQ
 106360160 0xeb1f015f  CMP X10, XZR
 106360164 0x54000040  B.EQ START_Else_5    ; Reloc -> 'START_Else_5' @ 0x10636016c
 106360168 0x14000012  B START_Then_4    ; Reloc -> 'START_Then_4' @ 0x1063601b0
START_Else_5:
 10636016c 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x106365324
 106360170 0x910cb129  ADD X9, X9, #:lo12:L_str10_plus_8    ; Reloc -> 'L_str10' @ 0x106365324
 106360174 0xaa0903e0  MOV X0, X9
 106360178 0x97ffffb3  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 10636017c 0xaa1903e0  MOV X0, X25
 106360180 0x97ffffb1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 106360184 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x10636513c
 106360188 0x91051129  ADD X9, X9, #:lo12:L_str3_plus_8    ; Reloc -> 'L_str3' @ 0x10636513c
 10636018c 0xaa0903e0  MOV X0, X9
 106360190 0x97ffffad  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 106360194 0x14000001  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x106360198
START_Exit_7:
 106360198 0x1400000b  B .L0    ; Reloc -> '.L0' @ 0x1063601c4
START_Then_1:
 10636019c 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x106365368
 1063601a0 0x910dc129  ADD X9, X9, #:lo12:L_str11_plus_8    ; Reloc -> 'L_str11' @ 0x106365368
 1063601a4 0xaa0903e0  MOV X0, X9
 1063601a8 0x97ffffa7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 1063601ac 0x17fffffb  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x106360198
START_Then_4:
 1063601b0 0xb0000029  ADRP X9, L_str12    ; Reloc -> 'L_str12' @ 0x1063653e4
 1063601b4 0x910fb129  ADD X9, X9, #:lo12:L_str12_plus_8    ; Reloc -> 'L_str12' @ 0x1063653e4
 1063601b8 0xaa0903e0  MOV X0, X9
 1063601bc 0x97ffffa2  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x106360044
 1063601c0 0x17fffff6  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x106360198
.L0:
 1063601c4 0xa942d3b3  LDP x19, x20, [x29, #40]
 1063601c8 0xa943e7b5  LDP x21, x25, [x29, #56]
 1063601cc 0xa944efba  LDP x26, x27, [x29, #72]
 1063601d0 0xf9402fbc  LDR X28, [X29, #88] ; Restored Reg: X28 @ FP+88
 1063601d4 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1063601d8 0xa9407bfd  LDP x29, x30, [SP, #0]
 1063601dc 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1063601e0 0xd65f03c0  RET
L_str0:
 106365000 0x22000000  .quad 0x22
 106365004 0x00000000  ; (upper half)
L_str0_plus_8:
 106365008 0x54000000  DCD 0x54
 10636500c 0x65000000  DCD 0x65
 106365010 0x73000000  DCD 0x73
 106365014 0x74000000  DCD 0x74
 106365018 0x69000000  DCD 0x69
 10636501c 0x6e000000  DCD 0x6e
 106365020 0x67000000  DCD 0x67
 106365024 0x20000000  DCD 0x20
 106365028 0x53000000  DCD 0x53
 10636502c 0x50000000  DCD 0x50
 106365030 0x4c000000  DCD 0x4c
 106365034 0x49000000  DCD 0x49
 106365038 0x54000000  DCD 0x54
 10636503c 0x2d000000  DCD 0x2d
 106365040 0x3e000000  DCD 0x3e
 106365044 0x4a000000  DCD 0x4a
 106365048 0x4f000000  DCD 0x4f
 10636504c 0x49000000  DCD 0x49
 106365050 0x4e000000  DCD 0x4e
 106365054 0x20000000  DCD 0x20
 106365058 0x72000000  DCD 0x72
 10636505c 0x6f000000  DCD 0x6f
 106365060 0x75000000  DCD 0x75
 106365064 0x6e000000  DCD 0x6e
 106365068 0x64000000  DCD 0x64
 10636506c 0x2d000000  DCD 0x2d
 106365070 0x74000000  DCD 0x74
 106365074 0x72000000  DCD 0x72
 106365078 0x69000000  DCD 0x69
 10636507c 0x70000000  DCD 0x70
 106365080 0x2e000000  DCD 0x2e
 106365084 0x2e000000  DCD 0x2e
 106365088 0x2e000000  DCD 0x2e
 10636508c 0xa0000000  DCD 0xa
 106365090 0x00000000  DCD 0x0
 106365094 0x00000000  DCD 0x0
L_str1:
 106365098 0x10000000  .quad 0x10
 10636509c 0x00000000  ; (upper half)
L_str1_plus_8:
 1063650a0 0x68000000  DCD 0x68
 1063650a4 0x65000000  DCD 0x65
 1063650a8 0x6c000000  DCD 0x6c
 1063650ac 0x6c000000  DCD 0x6c
 1063650b0 0x6f000000  DCD 0x6f
 1063650b4 0x20000000  DCD 0x20
 1063650b8 0x77000000  DCD 0x77
 1063650bc 0x6f000000  DCD 0x6f
 1063650c0 0x72000000  DCD 0x72
 1063650c4 0x6c000000  DCD 0x6c
 1063650c8 0x64000000  DCD 0x64
 1063650cc 0x20000000  DCD 0x20
 1063650d0 0x74000000  DCD 0x74
 1063650d4 0x65000000  DCD 0x65
 1063650d8 0x73000000  DCD 0x73
 1063650dc 0x74000000  DCD 0x74
 1063650e0 0x00000000  DCD 0x0
 1063650e4 0x00000000  DCD 0x0
L_str2:
 1063650e8 0x11000000  .quad 0x11
 1063650ec 0x00000000  ; (upper half)
L_str2_plus_8:
 1063650f0 0x4f000000  DCD 0x4f
 1063650f4 0x72000000  DCD 0x72
 1063650f8 0x69000000  DCD 0x69
 1063650fc 0x67000000  DCD 0x67
 106365100 0x69000000  DCD 0x69
 106365104 0x6e000000  DCD 0x6e
 106365108 0x61000000  DCD 0x61
 10636510c 0x6c000000  DCD 0x6c
 106365110 0x20000000  DCD 0x20
 106365114 0x73000000  DCD 0x73
 106365118 0x74000000  DCD 0x74
 10636511c 0x72000000  DCD 0x72
 106365120 0x69000000  DCD 0x69
 106365124 0x6e000000  DCD 0x6e
 106365128 0x67000000  DCD 0x67
 10636512c 0x3a000000  DCD 0x3a
 106365130 0x20000000  DCD 0x20
 106365134 0x00000000  DCD 0x0
 106365138 0x00000000  DCD 0x0
L_str3:
 10636513c 0x10000000  .quad 0x1
 106365140 0x00000000  ; (upper half)
L_str3_plus_8:
 106365144 0xa0000000  DCD 0xa
 106365148 0x00000000  DCD 0x0
 10636514c 0x00000000  DCD 0x0
L_str4:
 106365150 0x11000000  .quad 0x11
 106365154 0x00000000  ; (upper half)
L_str4_plus_8:
 106365158 0x43000000  DCD 0x43
 10636515c 0x61000000  DCD 0x61
 106365160 0x6c000000  DCD 0x6c
 106365164 0x6c000000  DCD 0x6c
 106365168 0x69000000  DCD 0x69
 10636516c 0x6e000000  DCD 0x6e
 106365170 0x67000000  DCD 0x67
 106365174 0x20000000  DCD 0x20
 106365178 0x53000000  DCD 0x53
 10636517c 0x50000000  DCD 0x50
 106365180 0x4c000000  DCD 0x4c
 106365184 0x49000000  DCD 0x49
 106365188 0x54000000  DCD 0x54
 10636518c 0x2e000000  DCD 0x2e
 106365190 0x2e000000  DCD 0x2e
 106365194 0x2e000000  DCD 0x2e
 106365198 0xa0000000  DCD 0xa
 10636519c 0x00000000  DCD 0x0
 1063651a0 0x00000000  DCD 0x0
L_str5:
 1063651a4 0x10000000  .quad 0x1
 1063651a8 0x00000000  ; (upper half)
L_str5_plus_8:
 1063651ac 0x20000000  DCD 0x20
 1063651b0 0x00000000  DCD 0x0
 1063651b4 0x00000000  DCD 0x0
L_str6:
 1063651b8 0x10000000  .quad 0x10
 1063651bc 0x00000000  ; (upper half)
L_str6_plus_8:
 1063651c0 0x53000000  DCD 0x53
 1063651c4 0x50000000  DCD 0x50
 1063651c8 0x4c000000  DCD 0x4c
 1063651cc 0x49000000  DCD 0x49
 1063651d0 0x54000000  DCD 0x54
 1063651d4 0x20000000  DCD 0x20
 1063651d8 0x63000000  DCD 0x63
 1063651dc 0x6f000000  DCD 0x6f
 1063651e0 0x6d000000  DCD 0x6d
 1063651e4 0x70000000  DCD 0x70
 1063651e8 0x6c000000  DCD 0x6c
 1063651ec 0x65000000  DCD 0x65
 1063651f0 0x74000000  DCD 0x74
 1063651f4 0x65000000  DCD 0x65
 1063651f8 0x64000000  DCD 0x64
 1063651fc 0xa0000000  DCD 0xa
 106365200 0x00000000  DCD 0x0
 106365204 0x00000000  DCD 0x0
L_str7:
 106365208 0x2b000000  .quad 0x2b
 10636520c 0x00000000  ; (upper half)
L_str7_plus_8:
 106365210 0x53000000  DCD 0x53
 106365214 0x50000000  DCD 0x50
 106365218 0x4c000000  DCD 0x4c
 10636521c 0x49000000  DCD 0x49
 106365220 0x54000000  DCD 0x54
 106365224 0x20000000  DCD 0x20
 106365228 0x72000000  DCD 0x72
 10636522c 0x65000000  DCD 0x65
 106365230 0x74000000  DCD 0x74
 106365234 0x75000000  DCD 0x75
 106365238 0x72000000  DCD 0x72
 10636523c 0x6e000000  DCD 0x6e
 106365240 0x65000000  DCD 0x65
 106365244 0x64000000  DCD 0x64
 106365248 0x20000000  DCD 0x20
 10636524c 0x61000000  DCD 0x61
 106365250 0x20000000  DCD 0x20
 106365254 0x6c000000  DCD 0x6c
 106365258 0x69000000  DCD 0x69
 10636525c 0x73000000  DCD 0x73
 106365260 0x74000000  DCD 0x74
 106365264 0x2c000000  DCD 0x2c
 106365268 0x20000000  DCD 0x20
 10636526c 0x6e000000  DCD 0x6e
 106365270 0x6f000000  DCD 0x6f
 106365274 0x77000000  DCD 0x77
 106365278 0x20000000  DCD 0x20
 10636527c 0x63000000  DCD 0x63
 106365280 0x61000000  DCD 0x61
 106365284 0x6c000000  DCD 0x6c
 106365288 0x6c000000  DCD 0x6c
 10636528c 0x69000000  DCD 0x69
 106365290 0x6e000000  DCD 0x6e
 106365294 0x67000000  DCD 0x67
 106365298 0x20000000  DCD 0x20
 10636529c 0x4a000000  DCD 0x4a
 1063652a0 0x4f000000  DCD 0x4f
 1063652a4 0x49000000  DCD 0x49
 1063652a8 0x4e000000  DCD 0x4e
 1063652ac 0x2e000000  DCD 0x2e
 1063652b0 0x2e000000  DCD 0x2e
 1063652b4 0x2e000000  DCD 0x2e
 1063652b8 0xa0000000  DCD 0xa
 1063652bc 0x00000000  DCD 0x0
 1063652c0 0x00000000  DCD 0x0
L_str8:
 1063652c4 0x10000000  .quad 0x1
 1063652c8 0x00000000  ; (upper half)
L_str8_plus_8:
 1063652cc 0x2d000000  DCD 0x2d
 1063652d0 0x00000000  DCD 0x0
 1063652d4 0x00000000  DCD 0x0
L_str9:
 1063652d8 0xf0000000  .quad 0xf
 1063652dc 0x00000000  ; (upper half)
L_str9_plus_8:
 1063652e0 0x4a000000  DCD 0x4a
 1063652e4 0x4f000000  DCD 0x4f
 1063652e8 0x49000000  DCD 0x49
 1063652ec 0x4e000000  DCD 0x4e
 1063652f0 0x20000000  DCD 0x20
 1063652f4 0x63000000  DCD 0x63
 1063652f8 0x6f000000  DCD 0x6f
 1063652fc 0x6d000000  DCD 0x6d
 106365300 0x70000000  DCD 0x70
 106365304 0x6c000000  DCD 0x6c
 106365308 0x65000000  DCD 0x65
 10636530c 0x74000000  DCD 0x74
 106365310 0x65000000  DCD 0x65
 106365314 0x64000000  DCD 0x64
 106365318 0xa0000000  DCD 0xa
 10636531c 0x00000000  DCD 0x0
 106365320 0x00000000  DCD 0x0
L_str10:
 106365324 0xd0000000  .quad 0xd
 106365328 0x00000000  ; (upper half)
L_str10_plus_8:
 10636532c 0x4a000000  DCD 0x4a
 106365330 0x4f000000  DCD 0x4f
 106365334 0x49000000  DCD 0x49
 106365338 0x4e000000  DCD 0x4e
 10636533c 0x20000000  DCD 0x20
 106365340 0x72000000  DCD 0x72
 106365344 0x65000000  DCD 0x65
 106365348 0x73000000  DCD 0x73
 10636534c 0x75000000  DCD 0x75
 106365350 0x6c000000  DCD 0x6c
 106365354 0x74000000  DCD 0x74
 106365358 0x3a000000  DCD 0x3a
 10636535c 0x20000000  DCD 0x20
 106365360 0x00000000  DCD 0x0
 106365364 0x00000000  DCD 0x0
L_str11:
 106365368 0x1b000000  .quad 0x1b
 10636536c 0x00000000  ; (upper half)
L_str11_plus_8:
 106365370 0x45000000  DCD 0x45
 106365374 0x52000000  DCD 0x52
 106365378 0x52000000  DCD 0x52
 10636537c 0x4f000000  DCD 0x4f
 106365380 0x52000000  DCD 0x52
 106365384 0x3a000000  DCD 0x3a
 106365388 0x20000000  DCD 0x20
 10636538c 0x53000000  DCD 0x53
 106365390 0x50000000  DCD 0x50
 106365394 0x4c000000  DCD 0x4c
 106365398 0x49000000  DCD 0x49
 10636539c 0x54000000  DCD 0x54
 1063653a0 0x20000000  DCD 0x20
 1063653a4 0x72000000  DCD 0x72
 1063653a8 0x65000000  DCD 0x65
 1063653ac 0x74000000  DCD 0x74
 1063653b0 0x75000000  DCD 0x75
 1063653b4 0x72000000  DCD 0x72
 1063653b8 0x6e000000  DCD 0x6e
 1063653bc 0x65000000  DCD 0x65
 1063653c0 0x64000000  DCD 0x64
 1063653c4 0x20000000  DCD 0x20
 1063653c8 0x6e000000  DCD 0x6e
 1063653cc 0x75000000  DCD 0x75
 1063653d0 0x6c000000  DCD 0x6c
 1063653d4 0x6c000000  DCD 0x6c
 1063653d8 0xa0000000  DCD 0xa
 1063653dc 0x00000000  DCD 0x0
 1063653e0 0x00000000  DCD 0x0
L_str12:
 1063653e4 0x1a000000  .quad 0x1a
 1063653e8 0x00000000  ; (upper half)
L_str12_plus_8:
 1063653ec 0x45000000  DCD 0x45
 1063653f0 0x52000000  DCD 0x52
 1063653f4 0x52000000  DCD 0x52
 1063653f8 0x4f000000  DCD 0x4f
 1063653fc 0x52000000  DCD 0x52
 106365400 0x3a000000  DCD 0x3a
 106365404 0x20000000  DCD 0x20
 106365408 0x4a000000  DCD 0x4a
 10636540c 0x4f000000  DCD 0x4f
 106365410 0x49000000  DCD 0x49
 106365414 0x4e000000  DCD 0x4e
 106365418 0x20000000  DCD 0x20
 10636541c 0x72000000  DCD 0x72
 106365420 0x65000000  DCD 0x65
 106365424 0x74000000  DCD 0x74
 106365428 0x75000000  DCD 0x75
 10636542c 0x72000000  DCD 0x72
 106365430 0x6e000000  DCD 0x6e
 106365434 0x65000000  DCD 0x65
 106365438 0x64000000  DCD 0x64
 10636543c 0x20000000  DCD 0x20
 106365440 0x6e000000  DCD 0x6e
 106365444 0x75000000  DCD 0x75
 106365448 0x6c000000  DCD 0x6c
 10636544c 0x6c000000  DCD 0x6c
 106365450 0xa0000000  DCD 0xa
 106365454 0x00000000  DCD 0x0
 106365458 0x00000000  DCD 0x0

--------------------------

JIT runtime table populated with 124 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x106360058
[JITExecutor] Starting execution of JIT-compiled function at address: 0x106360058
Testing SPLIT->JOIN round-trip...
Original string: hello world test
Calling SPLIT...
SAMM: Tracked freelist allocation 0x9f700d000 in scope (depth: 1, scope size: 1)
SAMM: Tracked list allocation 0x9f700d000 in scope (depth: 1, scope size: 2)
BCPL String Optimizations: Initialized (pool + SIMD)
SAMM: Tracked string pool allocation 0x9f70c37dc in scope (depth: 1, scope size: 3)
SAMM: Tracked string pool allocation 0x9f70c37a0 in scope (depth: 1, scope size: 4)
SPLIT completed
SPLIT returned a list, now calling JOIN...
