Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=tests/bcl_tests/class1.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.1618
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/tests/bcl_tests/class1.bcl"
// class1.bcl - Test for class member variable access
// This file demonstrates proper class member variable access with fixed offsets
// to avoid conflicts with the vtable pointer at offset 0.

CLASS Point $(
    DECL x, y  // These will be placed at offsets 8 and 16, after the vtable pointer

    // Constructor
    ROUTINE CREATE(initialX, initialY) BE $(
        x := initialX
        y := initialY
        WRITES("Point created at (")
        WRITEN(x)
        WRITES(", ")
        WRITEN(y)
        WRITES(")*N")
    $)

    // Accessor methods
    FUNCTION getX() = VALOF $(
        RESULTIS x
    $)

    FUNCTION getY() = VALOF $(
        RESULTIS y
    $)

    // Setter method
    ROUTINE set(newX, newY) BE $(
        x := newX
        y := newY
        WRITES("Point moved to (")
        WRITEN(x)
        WRITES(", ")
        WRITEN(y)
        WRITES(")*N")
    $)
$)

LET START() BE $(

    WRITES("Creating point...*N")

    LET p = NEW Point(50,75)

    WRITES("Reading values: x=")
    WRITEN(p.getX())
    WRITES(", y=")
    WRITEN(p.getY())
    WRITES("*N*N")

    WRITES("Setting new values...*N")
    p.set(100, 200)

    WRITES("Reading new values: x=")
    WRITEN(p.getX())
    WRITES(", y=")
    WRITEN(p.getY())
    WRITES("*N")
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x1027806d4
Registered 91 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x10277f408 | args: 0 | table_offset: 712
  FINISH           | address: 0x10277e1b8 | args: 0 | table_offset: 704
  FABS             | address: 0x10277e568 | args: 1 | table_offset: 672
  FSIN             | address: 0x10277e52c | args: 1 | table_offset: 648
  FILE_EOF         | address: 0x102781820 | args: 1 | table_offset: 616
  RAND             | address: 0x10277e3b8 | args: 1 | table_offset: 624
  FILE_TELL        | address: 0x1027817c8 | args: 1 | table_offset: 608
  FILE_SEEK        | address: 0x102781704 | args: 3 | table_offset: 600
  FILE_WRITE       | address: 0x1027815ec | args: 3 | table_offset: 592
  FIX              | address: 0x10277e5a8 | args: 1 | table_offset: 696
  FILE_READS       | address: 0x102781038 | args: 1 | table_offset: 576
  FILE_WRITES      | address: 0x102780d5c | args: 2 | table_offset: 568
  FEXP             | address: 0x10277e594 | args: 1 | table_offset: 688
  FILE_CLOSE       | address: 0x102780cf0 | args: 1 | table_offset: 560
  FILE_OPEN_APPEND | address: 0x102780c60 | args: 1 | table_offset: 552
  SLURP            | address: 0x10277ec90 | args: 1 | table_offset: 520
  PACKSTRING       | address: 0x10277e5c0 | args: 1 | table_offset: 504
  STRLEN           | address: 0x10277e1c8 | args: 1 | table_offset: 496
  FCOS             | address: 0x10277e540 | args: 1 | table_offset: 656
  STRCMP           | address: 0x10277e228 | args: 2 | table_offset: 488
  STRCOPY          | address: 0x10277e30c | args: 2 | table_offset: 480
  FIND             | address: 0x102784d48 | args: 3 | table_offset: 448
  DEEPCOPYLITERALLIST | address: 0x1027849c0 | args: 1 | table_offset: 432
  DEEPCOPYLIST     | address: 0x102784828 | args: 1 | table_offset: 424
  COPYLIST         | address: 0x102784728 | args: 1 | table_offset: 416
  CONCAT           | address: 0x102784b60 | args: 2 | table_offset: 408
  BCPL_CONCAT_LISTS | address: 0x102784b60 | args: 2 | table_offset: 400
  SPIT             | address: 0x10277f1bc | args: 2 | table_offset: 528
  JOIN             | address: 0x102783dc4 | args: 2 | table_offset: 472
  LPND             | address: 0x1027842d4 | args: 2 | table_offset: 392
  SPND             | address: 0x102784204 | args: 2 | table_offset: 384
  FPND             | address: 0x102784134 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x102785218 | args: 1 | table_offset: 720
  BCPL_LIST_APPEND_INT | address: 0x102784064 | args: 2 | table_offset: 344
  GETVEC           | address: 0x102780798 | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x10266f984 | args: 0 | table_offset: 312
  APND             | address: 0x102784064 | args: 2 | table_offset: 368
  HEAPMANAGER_ENTER_SCOPE | address: 0x10266f8bc | args: 0 | table_offset: 280
  HEAPMANAGER_SETSAMMENABLED | address: 0x10266f868 | args: 1 | table_offset: 296
  HEAPMANAGER_EXIT_SCOPE | address: 0x10266f8e8 | args: 0 | table_offset: 288
  PIC_RUNTIME_HELPER | address: 0x10278084c | args: 0 | table_offset: 272
  OBJECT_HEAP_FREE | address: 0x102780810 | args: 1 | table_offset: 256
  OBJECT_HEAP_ALLOC | address: 0x1027807ec | args: 1 | table_offset: 248
  BCPL_LIST_GET_REST | address: 0x102784590 | args: 1 | table_offset: 216
  FRND             | address: 0x10277e444 | args: 0 | table_offset: 640
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x1027844d8 | args: 1 | table_offset: 200
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x102784474 | args: 1 | table_offset: 192
  RUNTIME_METHOD_LOOKUP | address: 0x102780834 | args: 2 | table_offset: 264
  FREEVEC          | address: 0x1027806d4 | args: 1 | table_offset: 136
  BCPL_BOUNDS_ERROR | address: 0x10277c698 | args: 3 | table_offset: 184
  WRITEF4          | address: 0x10277dcec | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x102784eec | args: 1 | table_offset: 144
  BCPL_ALLOC_CHARS | address: 0x10278067c | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x102784134 | args: 2 | table_offset: 352
  GET_FREE_LIST_HEAD_ADDR | address: 0x10278520c | args: 0 | table_offset: 328
  BCPL_GET_ATOM_TYPE | address: 0x1027845f4 | args: 1 | table_offset: 224
  FWRITE           | address: 0x10277d6c8 | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x102784004 | args: 0 | table_offset: 336
  SPLIT            | address: 0x102783a58 | args: 2 | table_offset: 464
  BCPL_FREE_CELLS  | address: 0x102785208 | args: 0 | table_offset: 320
  RND              | address: 0x10277e498 | args: 1 | table_offset: 632
  HEAPMANAGER_ISSAMMENABLED | address: 0x10266f898 | args: 0 | table_offset: 304
  WRITEC           | address: 0x10277dfa8 | args: 1 | table_offset: 88
  MALLOC           | address: 0x10278061c | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x10278061c | args: 3 | table_offset: 104
  FTAN             | address: 0x10277e554 | args: 1 | table_offset: 664
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 240
  BCPL_GET_LAST_ERROR | address: 0x10277c518 | args: 1 | table_offset: 160
  RDCH             | address: 0x10277e16c | args: 0 | table_offset: 96
  FILE_READ        | address: 0x1027814d8 | args: 3 | table_offset: 584
  UNPACKSTRING     | address: 0x10277e8f8 | args: 1 | table_offset: 512
  WRITEF5          | address: 0x10277dd78 | args: 6 | table_offset: 64
  FILTER           | address: 0x102784e3c | args: 2 | table_offset: 456
  BCPL_FREE_LIST_SAFE | address: 0x102784ff4 | args: 1 | table_offset: 152
  FILE_OPEN_WRITE  | address: 0x102780bd0 | args: 1 | table_offset: 544
  FILE_OPEN_READ   | address: 0x102780850 | args: 1 | table_offset: 536
  BCPL_LIST_GET_NTH | address: 0x10278465c | args: 2 | table_offset: 232
  WRITEF7          | address: 0x10277deb4 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x10277dc6c | args: 4 | table_offset: 48
  WRITEF6          | address: 0x10277de10 | args: 7 | table_offset: 72
  REVERSE          | address: 0x102784c60 | args: 1 | table_offset: 440
  WRITEF2          | address: 0x10277dbf8 | args: 3 | table_offset: 40
  WRITEF1          | address: 0x10277db90 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x102784540 | args: 1 | table_offset: 208
  BCPL_CLEAR_ERRORS | address: 0x10277c5c8 | args: 0 | table_offset: 168
  WRITEF           | address: 0x10277d70c | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x102784204 | args: 2 | table_offset: 360
  WRITES           | address: 0x10277d458 | args: 1 | table_offset: 0
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x102785260 | args: 0 | table_offset: 176
  FLOG             | address: 0x10277e580 | args: 1 | table_offset: 680
  WRITEN           | address: 0x10277df64 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point moved to ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        RoutineDeclaration: RELEASE
          Body:
            CompoundStatement:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Creating point...
"
            AssignmentStatement:
              LHS:
                VariableAccess: p
              RHS:
                NewExpression: Point
                  Arguments:
                    NumberLiteral: 50
                    NumberLiteral: 75
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Reading values: x="
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEN
              Arguments:
                FunctionCall:
                  Callee:
                    MemberAccess: getX
                      Object:
                        VariableAccess: p
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: ", y="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getY
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "

"
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Setting new values...
"
                RoutineCallStatement:
                  Callee:
                    MemberAccess: set
                      Object:
                        VariableAccess: p
                    Arguments:
                      NumberLiteral: 100
                      NumberLiteral: 200
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Reading new values: x="
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITEN
                    Arguments:
                      FunctionCall:
                        Callee:
                          MemberAccess: getX
                            Object:
                              VariableAccess: p
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: ", y="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getY
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: "
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point moved to ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        RoutineDeclaration: RELEASE
          Body:
            CompoundStatement:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Creating point...
"
            AssignmentStatement:
              LHS:
                VariableAccess: p
              RHS:
                NewExpression: Point
                  Arguments:
                    NumberLiteral: 50
                    NumberLiteral: 75
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Reading values: x="
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEN
              Arguments:
                FunctionCall:
                  Callee:
                    MemberAccess: getX
                      Object:
                        VariableAccess: p
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: ", y="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getY
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "

"
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Setting new values...
"
                RoutineCallStatement:
                  Callee:
                    MemberAccess: set
                      Object:
                        VariableAccess: p
                    Arguments:
                      NumberLiteral: 100
                      NumberLiteral: 200
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Reading new values: x="
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITEN
                    Arguments:
                      FunctionCall:
                        Callee:
                          MemberAccess: getX
                            Object:
                              VariableAccess: p
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: ", y="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getY
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: "
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing class declaration: Point
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: x as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Added let variable: y as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing routine declaration: CREATE
[SymbolDiscoveryPass] Added routine: CREATE
[SymbolDiscoveryPass] Added parameter variable: _this in routine CREATE
[SymbolDiscoveryPass] Added parameter variable: initialX in routine CREATE
[SymbolDiscoveryPass] Added parameter variable: initialY in routine CREATE
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Registered CREATE routine as constructor for class: Point
[SymbolDiscoveryPass] Processing function declaration: getX
[SymbolDiscoveryPass] Added parameter '_this' as UNKNOWN (parameter type will be determined at call sites)
[SymbolDiscoveryPass] Added function: getX returns INTEGER with 1 parameters
[SymbolDiscoveryPass] Added parameter variable: _this in function getX
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing function declaration: getY
[SymbolDiscoveryPass] Added parameter '_this' as UNKNOWN (parameter type will be determined at call sites)
[SymbolDiscoveryPass] Added function: getY returns INTEGER with 1 parameters
[SymbolDiscoveryPass] Added parameter variable: _this in function getY
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing routine declaration: set
[SymbolDiscoveryPass] Added routine: set
[SymbolDiscoveryPass] Added parameter variable: _this in routine set
[SymbolDiscoveryPass] Added parameter variable: newX in routine set
[SymbolDiscoveryPass] Added parameter variable: newY in routine set
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing routine declaration: RELEASE
[SymbolDiscoveryPass] Added routine: RELEASE
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: p as INTEGER (default INTEGER)

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'x' (LOCAL_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'y' (LOCAL_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'CREATE' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='CREATE')
Symbol 'getX' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='getX', parameters=[UNKNOWN])
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='getX')
Symbol 'getY' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='getY', parameters=[UNKNOWN])
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='getY')
Symbol 'set' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='set')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='set')
Symbol 'newX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='set')
Symbol 'newY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='set')
Symbol 'RELEASE' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='RELEASE')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::getY'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::RELEASE'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::getX'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::set'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::CREATE'
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting ClassDeclaration: Point
[ANALYZER TRACE] Visiting class.
[ANALYZER TRACE] Visiting RoutineDeclaration: CREATE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::CREATE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialX' in different context 'CREATE' (requested context was 'Point::CREATE')
[ANALYZER] Set parameter type: initialX in Point::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialX in Point::CREATE set to 0
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialY' in different context 'CREATE' (requested context was 'Point::CREATE')
[ANALYZER] Set parameter type: initialY in Point::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialY in Point::CREATE set to 0
[ANALYZER] Starting parameter type inference for function: Point::CREATE
[ANALYZER] Analyzing parameter: initialX
[ANALYZER] Parameter 'initialX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: initialY
[ANALYZER] Parameter 'initialY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in Point::CREATE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::CREATE to 1056768 after inference
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialX' in different context 'CREATE' (requested context was 'Point::CREATE')
[ANALYZER] Set parameter type: initialX in Point::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialX in Point::CREATE to 0 after inference
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialY' in different context 'CREATE' (requested context was 'Point::CREATE')
[ANALYZER] Set parameter type: initialY in Point::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialY in Point::CREATE to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: CREATE
[ANALYZER TRACE] Entering block scope: Point::CREATE_block_3 (Function scope remains: Point::CREATE)
[ANALYZER TRACE] BlockStatement: Traversing 7 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialX
[DEBUG get_effective_variable_name] Called with: 'initialX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialX'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialY
[DEBUG get_effective_variable_name] Called with: 'initialY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialY'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1035673f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1035674e0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103567580
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568340
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1035683e0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: Point::CREATE
[ANALYZER TRACE] Visiting FunctionDeclaration: getX
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::getX
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::getX
[ANALYZER] Set parameter type: _this in Point::getX to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::getX to 1056768 after inference
[ANALYZER TRACE] Entering block scope: Point::getX_block_3 (Function scope remains: Point::getX)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[DEBUG get_variable_type] Looking for 'x' in function 'Point::getX'
[DEBUG get_variable_type] Found function metrics for 'Point::getX'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'x' not found in function metrics
[DEBUG get_variable_type] Found in symbol table: x -> 1
[ANALYZER TRACE] Exiting block scope, returning to: Point::getX
[DEBUG get_variable_type] Looking for 'x' in function 'Point::getX'
[DEBUG get_variable_type] Found function metrics for 'Point::getX'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'x' not found in function metrics
[DEBUG get_variable_type] Found in symbol table: x -> 1
[ANALYZER TRACE] Visiting FunctionDeclaration: getY
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::getY
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::getY
[ANALYZER] Set parameter type: _this in Point::getY to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::getY to 1056768 after inference
[ANALYZER TRACE] Entering block scope: Point::getY_block_3 (Function scope remains: Point::getY)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[DEBUG get_variable_type] Looking for 'y' in function 'Point::getY'
[DEBUG get_variable_type] Found function metrics for 'Point::getY'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'y' not found in function metrics
[DEBUG get_variable_type] Found in symbol table: y -> 1
[ANALYZER TRACE] Exiting block scope, returning to: Point::getY
[DEBUG get_variable_type] Looking for 'y' in function 'Point::getY'
[DEBUG get_variable_type] Found function metrics for 'Point::getY'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'y' not found in function metrics
[DEBUG get_variable_type] Found in symbol table: y -> 1
[ANALYZER TRACE] Visiting RoutineDeclaration: set
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::set
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[SYMBOL TABLE TRACE] Warning: Found symbol 'newX' in different context 'set' (requested context was 'Point::set')
[ANALYZER] Set parameter type: newX in Point::set to 0
[ANALYZER TRACE] Early parameter type for newX in Point::set set to 0
[SYMBOL TABLE TRACE] Warning: Found symbol 'newY' in different context 'set' (requested context was 'Point::set')
[ANALYZER] Set parameter type: newY in Point::set to 0
[ANALYZER TRACE] Early parameter type for newY in Point::set set to 0
[ANALYZER] Starting parameter type inference for function: Point::set
[ANALYZER] Analyzing parameter: newX
[ANALYZER] Parameter 'newX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: newY
[ANALYZER] Parameter 'newY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in Point::set to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::set to 1056768 after inference
[SYMBOL TABLE TRACE] Warning: Found symbol 'newX' in different context 'set' (requested context was 'Point::set')
[ANALYZER] Set parameter type: newX in Point::set to 0
[ANALYZER TRACE] Updated parameter type for newX in Point::set to 0 after inference
[SYMBOL TABLE TRACE] Warning: Found symbol 'newY' in different context 'set' (requested context was 'Point::set')
[ANALYZER] Set parameter type: newY in Point::set to 0
[ANALYZER TRACE] Updated parameter type for newY in Point::set to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: set
[ANALYZER TRACE] Entering block scope: Point::set_block_5 (Function scope remains: Point::set)
[ANALYZER TRACE] BlockStatement: Traversing 7 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: newX
[DEBUG get_effective_variable_name] Called with: 'newX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'newX'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: newY
[DEBUG get_effective_variable_name] Called with: 'newY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'newY'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568960
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568a30
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568ae0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568b90
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568c30
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: Point::set
[ANALYZER TRACE] Visiting RoutineDeclaration: RELEASE

[ANALYZER IMPORTANT] === Adding _this parameter to method: Point::RELEASE ===
[ANALYZER TRACE]   Injected '_this' parameter for method: Point::RELEASE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::RELEASE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::RELEASE
[ANALYZER] Set parameter type: _this in Point::RELEASE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::RELEASE to 1056768 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: RELEASE
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_5 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 14 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568e00
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: p
[DEBUG get_effective_variable_name] Called with: 'p'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103568fa0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103569000
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103569070
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1035690e0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103569150
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1035691c0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x753024000
[ANALYZER TRACE] BlockStatement: Calling accept on statement 9 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x753024030
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 10 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x753024060
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 11 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x753024090
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 12 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x7530240c0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 13 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x7530240f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 6
  Allocation-free functions: 5
  Allocation-free leaf functions: 3
  Allocation-free non-leaf functions: 2
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: Point::CREATE
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::RELEASE
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getX
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getY
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::set
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 2
  Float Locals: 0
  Runtime Calls: 12
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting ClassDeclaration: Point
[CreateMethodReorderPass] Visiting RoutineDeclaration: CREATE
[CreateMethodReorderPass] Found CREATE method in class Point
[CreateMethodReorderPass] Analyzing CREATE method body (BlockStatement)...
[CreateMethodReorderPass] Analyzing BlockStatement body with 7 statements
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: x
[CreateMethodReorderPass] Variable x is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 0
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: y
[CreateMethodReorderPass] Variable y is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 1
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] No reordering needed - missing _this assignments or SUPER.CREATE calls
[CreateMethodReorderPass] No reordering needed for CREATE method in class Point
[CreateMethodReorderPass] Visiting RoutineDeclaration: set
[CreateMethodReorderPass] Visiting RoutineDeclaration: RELEASE
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found ClassDecl at index 0
[CFGBuilderPass] Processing class: Point
[CFGBuilderPass] Found routine method 'CREATE' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::CREATE
[CFGBuilderPass] Creating CFG for routine: Point::CREATE
[CFGBuilderPass] Created CFG for routine: Point::CREATE
[CFGBuilderPass] Created new basic block: Point::CREATE_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::CREATE (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Created new basic block: Point::CREATE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found function method 'getX' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::getX
[CFGBuilderPass] visit(FunctionDeclaration) for function: Point::getX
[CFGBuilderPass] Created CFG for function: Point::getX
[CFGBuilderPass] Created new basic block: Point::getX_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::getX (leaf)
[CFGBuilderPass] Starting optimized block 2 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: Point::getX_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getX
[CFGBuilderPass] Found function method 'getY' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::getY
[CFGBuilderPass] visit(FunctionDeclaration) for function: Point::getY
[CFGBuilderPass] Created CFG for function: Point::getY
[CFGBuilderPass] Created new basic block: Point::getY_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::getY (leaf)
[CFGBuilderPass] Starting optimized block 3 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: Point::getY_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getY
[CFGBuilderPass] Found routine method 'set' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::set
[CFGBuilderPass] Creating CFG for routine: Point::set
[CFGBuilderPass] Created CFG for routine: Point::set
[CFGBuilderPass] Created new basic block: Point::set_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::set (call tree)
[CFGBuilderPass] Starting optimized block 4 variable tracking
[CFGBuilderPass] Created new basic block: Point::set_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found routine method 'RELEASE' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::RELEASE
[CFGBuilderPass] Creating CFG for routine: Point::RELEASE
[CFGBuilderPass] Created CFG for routine: Point::RELEASE
[CFGBuilderPass] Created new basic block: Point::RELEASE_Entry_0
[CFGBuilderPass] Created new basic block: Point::RELEASE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Processing declaration #1
[CFGBuilderPass] Found RoutineDecl at index 1
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 64 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 64 for function 'START'
[CFGBuilderPass] Starting block 5 variable tracking
[CFGBuilderPass] Tracking variable 'p' in current block
[CFGBuilderPass] Generating normal block-end cleanup for 1 variables
[CFGBuilderPass] Generating block-end cleanup for: p
[CFGBuilderPass] Skipping legacy cleanup for p - SAMM is active
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 65 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 65 for function 'START'
[CFGBuilderPass] Created new basic block: START_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] CFG found for: Point::getY
[CFGBuilderPass] CFG found for: Point::RELEASE
[CFGBuilderPass] CFG found for: Point::getX
[CFGBuilderPass] CFG found for: Point::set
[CFGBuilderPass] CFG found for: Point::CREATE
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::getY
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::RELEASE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::getX
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::set
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::CREATE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 6
  Blocks eliminated: 0
  Edges redirected: 0
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 17 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Intra-block call interval detected in START_Entry_0 - variables live across calls: _cse_temp_0 
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] CFG #2 for function 'Point::getY' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::getY_Exit_1) in function 'Point::getY'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getY_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::getY_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getY_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::getY_Entry_0) in function 'Point::getY'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getY_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::getY_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getY_Entry_0
[LivenessAnalysisPass] CFG #3 for function 'Point::RELEASE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::RELEASE_Exit_1) in function 'Point::RELEASE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::RELEASE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::RELEASE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::RELEASE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::RELEASE_Entry_0) in function 'Point::RELEASE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::RELEASE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::RELEASE_Entry_0 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::RELEASE_Entry_0
[LivenessAnalysisPass] CFG #4 for function 'Point::getX' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::getX_Exit_1) in function 'Point::getX'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getX_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::getX_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getX_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::getX_Entry_0) in function 'Point::getX'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getX_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::getX_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getX_Entry_0
[LivenessAnalysisPass] CFG #5 for function 'Point::set' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::set_Exit_1) in function 'Point::set'
[LivenessAnalysisPass] Entering analyze_block for block: Point::set_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::set_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::set_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::set_Entry_0) in function 'Point::set'
[LivenessAnalysisPass] Entering analyze_block for block: Point::set_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::set_Entry_0 with 7 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: y 
[LivenessAnalysisPass] Variables used after call: y 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: x 
[LivenessAnalysisPass] Variables used after call: x 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: newY 
[LivenessAnalysisPass] Variables used after call: newY 
[LivenessAnalysisPass] Statement uses variables: newX 
[LivenessAnalysisPass] Variables used after call: newX 
[LivenessAnalysisPass] Intra-block call interval detected in Point::set_Entry_0 - variables live across calls: newX newY x y 
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: Point::set_Entry_0
[LivenessAnalysisPass] CFG #6 for function 'Point::CREATE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::CREATE_Exit_1) in function 'Point::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::CREATE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::CREATE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::CREATE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::CREATE_Entry_0) in function 'Point::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::CREATE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::CREATE_Entry_0 with 7 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: y 
[LivenessAnalysisPass] Variables used after call: y 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: x 
[LivenessAnalysisPass] Variables used after call: x 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: initialY 
[LivenessAnalysisPass] Variables used after call: initialY 
[LivenessAnalysisPass] Statement uses variables: initialX 
[LivenessAnalysisPass] Variables used after call: initialX 
[LivenessAnalysisPass] Intra-block call interval detected in Point::CREATE_Entry_0 - variables live across calls: initialX initialY x y 
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: Point::CREATE_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getY_Exit_1 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::getY_Entry_0 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::RELEASE_Exit_1 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::RELEASE_Entry_0 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::getX_Exit_1 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::getX_Entry_0 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::set_Exit_1 in function: Point::set
[LivenessAnalysisPass] Processing block: Point::set_Entry_0 in function: Point::set
[LivenessAnalysisPass] Applying call interval fix to block Point::set_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::CREATE_Exit_1 in function: Point::CREATE
[LivenessAnalysisPass] Processing block: Point::CREATE_Entry_0 in function: Point::CREATE
[LivenessAnalysisPass] Applying call interval fix to block Point::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getY_Exit_1 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::getY_Entry_0 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::RELEASE_Exit_1 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::RELEASE_Entry_0 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::getX_Exit_1 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::getX_Entry_0 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::set_Exit_1 in function: Point::set
[LivenessAnalysisPass] Processing block: Point::set_Entry_0 in function: Point::set
[LivenessAnalysisPass] Applying call interval fix to block Point::set_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::CREATE_Exit_1 in function: Point::CREATE
[LivenessAnalysisPass] Processing block: Point::CREATE_Entry_0 in function: Point::CREATE
[LivenessAnalysisPass] Applying call interval fix to block Point::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { _cse_temp_0 }
  Def: { _cse_temp_0 p }
  In : { _cse_temp_0 }
  Out: { }

Liveness Analysis for function: Point::getY
-------------------------------------------
Block ID: Point::getY_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::getY_Entry_0
  Use: { y }
  Def: { }
  In : { y }
  Out: { }

Liveness Analysis for function: Point::RELEASE
-------------------------------------------
Block ID: Point::RELEASE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::RELEASE_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::getX
-------------------------------------------
Block ID: Point::getX_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::getX_Entry_0
  Use: { x }
  Def: { }
  In : { x }
  Out: { }

Liveness Analysis for function: Point::set
-------------------------------------------
Block ID: Point::set_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::set_Entry_0
  Use: { newX newY x y }
  Def: { x y }
  In : { newX newY x y }
  Out: { }

Liveness Analysis for function: Point::CREATE
-------------------------------------------
Block ID: Point::CREATE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::CREATE_Entry_0
  Use: { initialX initialY x y }
  Def: { x y }
  In : { initialX initialY x y }
  Out: { }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_1 (conceptual)

Block ID: START_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::getY
----------------------------------------
Entry Block: Point::getY_Entry_0
Exit Block: Point::getY_Exit_1 (conceptual)

Block ID: Point::getY_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::getY_Entry_0

Block ID: Point::getY_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: Point::getY_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::RELEASE
----------------------------------------
Entry Block: Point::RELEASE_Entry_0
Exit Block: Point::RELEASE_Exit_1 (conceptual)

Block ID: Point::RELEASE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::RELEASE_Entry_0

Block ID: Point::RELEASE_Entry_0 (Entry)
  Statements:
    (empty)
  Successors: Point::RELEASE_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::getX
----------------------------------------
Entry Block: Point::getX_Entry_0
Exit Block: Point::getX_Exit_1 (conceptual)

Block ID: Point::getX_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::getX_Entry_0

Block ID: Point::getX_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: Point::getX_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::set
----------------------------------------
Entry Block: Point::set_Entry_0
Exit Block: Point::set_Exit_1 (conceptual)

Block ID: Point::set_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::set_Entry_0

Block ID: Point::set_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: Point::set_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::CREATE
----------------------------------------
Entry Block: Point::CREATE_Entry_0
Exit Block: Point::CREATE_Exit_1 (conceptual)

Block ID: Point::CREATE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::CREATE_Entry_0

Block ID: Point::CREATE_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: Point::CREATE_Exit_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point moved to ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        RoutineDeclaration: RELEASE
          Parameters: _this 
          Body:
            CompoundStatement:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Creating point...
"
            AssignmentStatement:
              LHS:
                VariableAccess: p
              RHS:
                NewExpression: Point
                  Arguments:
                    NumberLiteral: 50
                    NumberLiteral: 75
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Reading values: x="
            AssignmentStatement:
              LHS:
                VariableAccess: _cse_temp_0
              RHS:
                FunctionCall:
                  Callee:
                    MemberAccess: getX
                      Object:
                        VariableAccess: p
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  VariableAccess: _cse_temp_0
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: ", y="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  VariableAccess: _cse_temp_0
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "

"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Setting new values...
"
              RoutineCallStatement:
                Callee:
                  MemberAccess: set
                    Object:
                      VariableAccess: p
                  Arguments:
                    NumberLiteral: 100
                    NumberLiteral: 200
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Reading new values: x="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: _cse_temp_0
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", y="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: _cse_temp_0
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[LiveIntervalPass] Created 2 intervals for function: START
  _cse_temp_0: [0-14]
  p: [2-4]
[LiveIntervalPass] Building intervals for function: Point::getY
[LiveIntervalPass] Injected _this interval for class method: Point::getY [0-3]
[LiveIntervalPass] Created 2 intervals for function: Point::getY
  _this: [0-3]
  y: [0-0]
[LiveIntervalPass] Building intervals for function: Point::RELEASE
[LiveIntervalPass] Injected _this interval for class method: Point::RELEASE [0-2]
[LiveIntervalPass] Created 1 intervals for function: Point::RELEASE
  _this: [0-2]
[LiveIntervalPass] Building intervals for function: Point::getX
[LiveIntervalPass] Injected _this interval for class method: Point::getX [0-3]
[LiveIntervalPass] Created 2 intervals for function: Point::getX
  _this: [0-3]
  x: [0-0]
[LiveIntervalPass] Building intervals for function: Point::set
[SYMBOL TABLE TRACE] Warning: Found symbol 'newX' in different context 'set' (requested context was 'Point::set')
[SYMBOL TABLE TRACE] Warning: Found symbol 'newY' in different context 'set' (requested context was 'Point::set')
[LiveIntervalPass] Injected _this interval for class method: Point::set [0-9]
[LiveIntervalPass] Created 5 intervals for function: Point::set
  _this: [0-9]
  newX: [0-0]
  newY: [0-1]
  x: [0-3]
  y: [0-5]
[LiveIntervalPass] Building intervals for function: Point::CREATE
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialX' in different context 'CREATE' (requested context was 'Point::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialY' in different context 'CREATE' (requested context was 'Point::CREATE')
[LiveIntervalPass] Injected _this interval for class method: Point::CREATE [0-9]
[LiveIntervalPass] Created 5 intervals for function: Point::CREATE
  _this: [0-9]
  initialX: [0-0]
  initialY: [0-1]
  x: [0-3]
  y: [0-5]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 18 call sites at: 0 4 8 9 15 19 20 26 30 38 42 43 49 53 54 60 64 65 
[Allocator] Partitioned: 2 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _cse_temp_0 [0-14]
  Assigned callee-saved register X27 to _cse_temp_0
[ALLOC] Updated allocations for _cse_temp_0: spilled=0, register='X27'
[Allocator] Allocating call-crossing p [2-4]
  Assigned callee-saved register X26 to p
[ALLOC] Updated allocations for p: spilled=0, register='X26'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 2
  Free integer registers: 11
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _cse_temp_0: reg X27 (callee-saved) [call-crossing]
  p: reg X26 (callee-saved) [call-crossing]
[Allocator] Starting partitioned linear scan for function: Point::getY
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 2 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Allocating local-only y [0-0]
  Assigned register X14 to y
[ALLOC] Updated allocations for y: spilled=0, register='X14'
[Allocator] Partitioned allocation complete for Point::getY
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 2
  Free integer registers: 11
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
  y: reg X14 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::RELEASE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-2]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for Point::RELEASE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::getX
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 2 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Allocating local-only x [0-0]
  Assigned register X14 to x
[ALLOC] Updated allocations for x: spilled=0, register='X14'
[Allocator] Partitioned allocation complete for Point::getX
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 2
  Free integer registers: 11
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
  x: reg X14 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::set
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 4 8 12 16 
[Allocator] Partitioned: 5 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-9]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Allocating call-crossing newX [0-0]
  Assigned callee-saved register X26 to newX
[ALLOC] Updated allocations for newX: spilled=0, register='X26'
[Allocator] Allocating call-crossing newY [0-1]
  Assigned callee-saved register X25 to newY
[ALLOC] Updated allocations for newY: spilled=0, register='X25'
[Allocator] Allocating call-crossing x [0-3]
  Assigned callee-saved register X24 to x
[ALLOC] Updated allocations for x: spilled=0, register='X24'
[Allocator] Allocating call-crossing y [0-5]
  Assigned callee-saved register X23 to y
[ALLOC] Updated allocations for y: spilled=0, register='X23'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for Point::set
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 5
  Free integer registers: 8
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
  newX: reg X26 (callee-saved) [call-crossing]
  newY: reg X25 (callee-saved) [call-crossing]
  x: reg X24 (callee-saved) [call-crossing]
  y: reg X23 (callee-saved) [call-crossing]
[Allocator] Starting partitioned linear scan for function: Point::CREATE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 4 8 12 16 
[Allocator] Partitioned: 5 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-9]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Allocating call-crossing initialX [0-0]
  Assigned callee-saved register X26 to initialX
[ALLOC] Updated allocations for initialX: spilled=0, register='X26'
[Allocator] Allocating call-crossing initialY [0-1]
  Assigned callee-saved register X25 to initialY
[ALLOC] Updated allocations for initialY: spilled=0, register='X25'
[Allocator] Allocating call-crossing x [0-3]
  Assigned callee-saved register X24 to x
[ALLOC] Updated allocations for x: spilled=0, register='X24'
[Allocator] Allocating call-crossing y [0-5]
  Assigned callee-saved register X23 to y
[ALLOC] Updated allocations for y: spilled=0, register='X23'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for Point::CREATE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 5
  Free integer registers: 8
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
  initialX: reg X26 (callee-saved) [call-crossing]
  initialY: reg X25 (callee-saved) [call-crossing]
  x: reg X24 (callee-saved) [call-crossing]
  y: reg X23 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: Point::CREATE
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 4
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::RELEASE
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getX
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 1
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getY
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 1
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::set
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 4
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 3
  Float Locals: 0
  Runtime Calls: 12
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 1
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4422156288
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 2 unique external functions:
[DEBUG]   - WRITEN
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] Generating 4 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITEN_veneer for function: WRITEN
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 4 veneers, estimated total size: 80 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Visiting ClassDeclaration for 'Point'. Setting class context.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: CREATE).
[DEBUG] Using qualified name for method: Point::CREATE
[DEBUG] Name 'Point::CREATE' is already qualified. Using unqualified part 'CREATE' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::CREATE
[DEBUG] DEBUG: generate_function_like_code called for: Point::CREATE
[DEBUG] Generating function-like code for: Point::CREATE
[DEBUG] Clearing local value tracking for function: Point::CREATE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: CREATE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: CREATE
[DEBUG] Using name as-is for lookup: Point::CREATE
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::CREATE'
Call Frame Layout for function: Point::CREATE
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialX' in different context 'CREATE' (requested context was 'Point::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialY' in different context 'CREATE' (requested context was 'Point::CREATE')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::CREATE'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::CREATE': 3
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['initialX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['initialY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialX' type from metrics: UNKNOWN
Added local variable 'initialX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialY' type from metrics: UNKNOWN
Added local variable 'initialY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::CREATE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialX' in different context 'CREATE' (requested context was 'Point::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialY' in different context 'CREATE' (requested context was 'Point::CREATE')
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::CREATE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X23 to callee_saved_registers_to_save list.
Added X24 to callee_saved_registers_to_save list.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::CREATE'.
--- Call Frame Layout for function: Point::CREATE (Total Size: 128 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X22                        | UNKNOWN
+72      | Saved Reg: X23                        | UNKNOWN
+80      | Saved Reg: X24                        | UNKNOWN
+88      | Saved Reg: X25                        | UNKNOWN
+96      | Saved Reg: X26                        | UNKNOWN
+104     | Saved Reg: X27                        | UNKNOWN
+112     | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+128 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-128]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X22, [X29, #64] ; Saved Reg: X22 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X23, [X29, #72] ; Saved Reg: X23 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X24, [X29, #80] ; Saved Reg: X24 @ FP+80
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #88] ; Saved Reg: X25 @ FP+88
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #96] ; Saved Reg: X26 @ FP+96
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #104] ; Saved Reg: X27 @ FP+104
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #112] ; Saved Reg: X28 @ FP+112
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG]   Moving 'initialX' from arg reg X1 to home reg X26.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X1    // Move parameter 'initialX' from X1 to X26
[DEBUG]   Moving 'initialY' from arg reg X2 to home reg X25.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X2    // Move parameter 'initialY' from X2 to X25
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X24' with the allocation system (spilled)
[DEBUG] Registered local variable 'X23' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Registered local variable 'X22' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::CREATE (Total Size: 128 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X22                        | UNKNOWN
+72      | Saved Reg: X23                        | UNKNOWN
+80      | Saved Reg: X24                        | UNKNOWN
+88      | Saved Reg: X25                        | UNKNOWN
+96      | Saved Reg: X26                        | UNKNOWN
+104     | Saved Reg: X27                        | UNKNOWN
+112     | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+128 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::CREATE
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialX' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'initialX' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialX' in different context 'CREATE' (requested context was 'Point::CREATE')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialX' lives in register X26
[DEBUG] Variable 'initialX' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Registering canonical address: x = VARIABLE:initialX
[DEBUG] Registered canonical address: x = VARIABLE:initialX
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: x
[DEBUG] Handling assignment for class member: x
[DEBUG] Member variable 'x' found in class 'Point' with offset 8
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X27, #8] ; Store to member x
[DEBUG]   Updating home register X24 for member 'x' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X24, X26
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialY' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'initialY' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'initialY' in different context 'CREATE' (requested context was 'Point::CREATE')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialY' lives in register X25
[DEBUG] Variable 'initialY' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] Registering canonical address: y = VARIABLE:initialY
[DEBUG] Registered canonical address: y = VARIABLE:initialY
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: y
[DEBUG] Handling assignment for class member: y
[DEBUG] Member variable 'y' found in class 'Point' with offset 16
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X27, #16] ; Store to member y
[DEBUG]   Updating home register X23 for member 'y' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X23, X25
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Point created at ('.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'x' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'y' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ')
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B Point::CREATE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L0
[DEBUG] Performing end-of-function scope cleanup for 'Point::CREATE'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'Point::CREATE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getX).
[DEBUG] Function metrics for getX not found.
[DEBUG] Using qualified name for method: Point::getX
[DEBUG] Name 'Point::getX' is already qualified. Using unqualified part 'getX' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::getX
[DEBUG] DEBUG: generate_function_like_code called for: Point::getX
[DEBUG] Generating function-like code for: Point::getX
[DEBUG] Clearing local value tracking for function: Point::getX
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getX
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getX
[DEBUG] Using name as-is for lookup: Point::getX
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::getX'
Call Frame Layout for function: Point::getX
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::getX'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::getX': 1
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::getX'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::getX'.
[DEBUG] No spills needed - all variables fit in registers.
Added X28 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::getX'.
--- Call Frame Layout for function: Point::getX (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X15.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0    // Move parameter '_this' from X0 to X15
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::getX (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::getX
[DEBUG] Visiting ResultisStatement node.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'Point::getX'
[DEBUG] get_variable_register for: 'x' in function 'Point::getX'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::getX'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X15
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X15, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: B .L1
[DEBUG] RESULTIS: Branching to function epilogue label .L1
[DEBUG LEVEL 5] Emitting instruction: B Point::getX_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L1
[DEBUG] Performing end-of-function scope cleanup for 'Point::getX'.
[DEBUG] Defining epilogue label: .L1
[DEBUG] Attempting to generate epilogue for 'Point::getX'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getY).
[DEBUG] Function metrics for getY not found.
[DEBUG] Using qualified name for method: Point::getY
[DEBUG] Name 'Point::getY' is already qualified. Using unqualified part 'getY' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::getY
[DEBUG] DEBUG: generate_function_like_code called for: Point::getY
[DEBUG] Generating function-like code for: Point::getY
[DEBUG] Clearing local value tracking for function: Point::getY
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getY
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getY
[DEBUG] Using name as-is for lookup: Point::getY
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::getY'
Call Frame Layout for function: Point::getY
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::getY'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::getY': 1
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::getY'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::getY'.
[DEBUG] No spills needed - all variables fit in registers.
Added X28 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::getY'.
--- Call Frame Layout for function: Point::getY (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X15.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0    // Move parameter '_this' from X0 to X15
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::getY (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::getY
[DEBUG] Visiting ResultisStatement node.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'Point::getY'
[DEBUG] get_variable_register for: 'y' in function 'Point::getY'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::getY'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X15
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X15, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG LEVEL 5] Emitting instruction: B .L2
[DEBUG] RESULTIS: Branching to function epilogue label .L2
[DEBUG LEVEL 5] Emitting instruction: B Point::getY_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L2
[DEBUG] Performing end-of-function scope cleanup for 'Point::getY'.
[DEBUG] Defining epilogue label: .L2
[DEBUG] Attempting to generate epilogue for 'Point::getY'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: set).
[DEBUG] Using qualified name for method: Point::set
[DEBUG] Name 'Point::set' is already qualified. Using unqualified part 'set' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::set
[DEBUG] DEBUG: generate_function_like_code called for: Point::set
[DEBUG] Generating function-like code for: Point::set
[DEBUG] Clearing local value tracking for function: Point::set
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: set
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: set
[DEBUG] Using name as-is for lookup: Point::set
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::set'
Call Frame Layout for function: Point::set
[SYMBOL TABLE TRACE] Warning: Found symbol 'newX' in different context 'set' (requested context was 'Point::set')
[SYMBOL TABLE TRACE] Warning: Found symbol 'newY' in different context 'set' (requested context was 'Point::set')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::set'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::set': 3
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['newX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['newY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'newX' type from metrics: UNKNOWN
Added local variable 'newX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'newX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'newY' type from metrics: UNKNOWN
Added local variable 'newY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'newY' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::set'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'newX' to CallFrameManager locals.
[DEBUG] Added parameter 'newY' to CallFrameManager locals.
[SYMBOL TABLE TRACE] Warning: Found symbol 'newX' in different context 'set' (requested context was 'Point::set')
[SYMBOL TABLE TRACE] Warning: Found symbol 'newY' in different context 'set' (requested context was 'Point::set')
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::set'.
[DEBUG] No spills needed - all variables fit in registers.
Added X23 to callee_saved_registers_to_save list.
Added X24 to callee_saved_registers_to_save list.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::set'.
--- Call Frame Layout for function: Point::set (Total Size: 128 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: newX                           | UNKNOWN
+32      | Local: newY                           | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X22                        | UNKNOWN
+72      | Saved Reg: X23                        | UNKNOWN
+80      | Saved Reg: X24                        | UNKNOWN
+88      | Saved Reg: X25                        | UNKNOWN
+96      | Saved Reg: X26                        | UNKNOWN
+104     | Saved Reg: X27                        | UNKNOWN
+112     | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+128 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-128]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X22, [X29, #64] ; Saved Reg: X22 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X23, [X29, #72] ; Saved Reg: X23 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X24, [X29, #80] ; Saved Reg: X24 @ FP+80
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #88] ; Saved Reg: X25 @ FP+88
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #96] ; Saved Reg: X26 @ FP+96
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #104] ; Saved Reg: X27 @ FP+104
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #112] ; Saved Reg: X28 @ FP+112
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG]   Moving 'newX' from arg reg X1 to home reg X26.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X1    // Move parameter 'newX' from X1 to X26
[DEBUG]   Moving 'newY' from arg reg X2 to home reg X25.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X2    // Move parameter 'newY' from X2 to X25
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X24' with the allocation system (spilled)
[DEBUG] Registered local variable 'X23' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Registered local variable 'X22' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::set (Total Size: 128 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: newX                           | UNKNOWN
+32      | Local: newY                           | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X22                        | UNKNOWN
+72      | Saved Reg: X23                        | UNKNOWN
+80      | Saved Reg: X24                        | UNKNOWN
+88      | Saved Reg: X25                        | UNKNOWN
+96      | Saved Reg: X26                        | UNKNOWN
+104     | Saved Reg: X27                        | UNKNOWN
+112     | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+128 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::set
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'newX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'newX' in function 'Point::set'
[DEBUG] get_variable_register for: 'newX' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'newX' in different context 'set' (requested context was 'Point::set')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'newX' lives in register X26
[DEBUG] Variable 'newX' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Registering canonical address: x = VARIABLE:newX
[DEBUG] Registered canonical address: x = VARIABLE:newX
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: x
[DEBUG] Handling assignment for class member: x
[DEBUG] Member variable 'x' found in class 'Point' with offset 8
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X27, #8] ; Store to member x
[DEBUG]   Updating home register X24 for member 'x' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X24, X26
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'newY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'newY' in function 'Point::set'
[DEBUG] get_variable_register for: 'newY' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'newY' in different context 'set' (requested context was 'Point::set')
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'newY' lives in register X25
[DEBUG] Variable 'newY' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] Registering canonical address: y = VARIABLE:newY
[DEBUG] Registered canonical address: y = VARIABLE:newY
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: y
[DEBUG] Handling assignment for class member: y
[DEBUG] Member variable 'y' found in class 'Point' with offset 16
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X27, #16] ; Store to member y
[DEBUG]   Updating home register X23 for member 'y' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X23, X25
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Point moved to ('.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'Point::set'
[DEBUG] get_variable_register for: 'x' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'Point::set'
[DEBUG] get_variable_register for: 'y' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ')
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B Point::set_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L3
[DEBUG] Performing end-of-function scope cleanup for 'Point::set'.
[DEBUG] Defining epilogue label: .L3
[DEBUG] Attempting to generate epilogue for 'Point::set'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: RELEASE).
[DEBUG] Using qualified name for method: Point::RELEASE
[DEBUG] Name 'Point::RELEASE' is already qualified. Using unqualified part 'RELEASE' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::RELEASE
[DEBUG] DEBUG: generate_function_like_code called for: Point::RELEASE
[DEBUG] Generating function-like code for: Point::RELEASE
[DEBUG] Clearing local value tracking for function: Point::RELEASE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: RELEASE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: RELEASE
[DEBUG] Using name as-is for lookup: Point::RELEASE
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::RELEASE'
Call Frame Layout for function: Point::RELEASE
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::RELEASE'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::RELEASE': 1
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::RELEASE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::RELEASE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X19 to callee_saved_registers_to_save list.
Added X28 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::RELEASE'.
--- Call Frame Layout for function: Point::RELEASE (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X15.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0    // Move parameter '_this' from X0 to X15
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::RELEASE (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::RELEASE
[DEBUG LEVEL 5] Emitting instruction: B Point::RELEASE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L4
[DEBUG] Performing end-of-function scope cleanup for 'Point::RELEASE'.
[DEBUG] Defining epilogue label: .L4
[DEBUG] Attempting to generate epilogue for 'Point::RELEASE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Finished with ClassDeclaration for 'Point'. Restoring context.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: START
[SYNC] Found 2 variable allocations
[SYNC] Reserved register X27 for variable _cse_temp_0
[SYNC] Reserved register X26 for variable p
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 2
[DEBUG] DEBUG: variable_types['_cse_temp_0'] = UNKNOWN
[DEBUG] DEBUG: variable_types['p'] = POINTER_TO|OBJECT
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable '_cse_temp_0' of type 0 at offset 16 (size 8)
[DEBUG] Registered local '_cse_temp_0' from analyzer metrics.
Added local variable 'p' of type 1056768 at offset 24 (size 8)
[DEBUG] Registered local 'p' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _cse_temp_0                    | UNKNOWN
+24      | Local: p                              | POINTER_TO|OBJECT
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X26                        | UNKNOWN
+48      | Saved Reg: X27                        | UNKNOWN
+56      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-64]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #40] ; Saved Reg: X26 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #48] ; Saved Reg: X27 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #56] ; Saved Reg: X28 @ FP+56
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _cse_temp_0                    | UNKNOWN
+24      | Local: p                              | POINTER_TO|OBJECT
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X26                        | UNKNOWN
+48      | Saved Reg: X27                        | UNKNOWN
+56      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Creating point...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting NewExpression node for class: Point
[DEBUG]   - Constructor arguments count: 2
[DEBUG]   - Assigned variable name: [empty]
[DEBUG LEVEL 5] Emitting instruction: BL OBJECT_HEAP_ALLOC
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X0
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, Point_vtable
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:Point_vtable
[DEBUG LEVEL 5] Emitting instruction: STR X9, [X20, #0] ; store vtable ptr
[DEBUG] Calling CREATE routine for Point
[DEBUG]   - CREATE method found at vtable slot: 0
[DEBUG]   - Will pass 2 arguments to CREATE
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #50
[DEBUG] Loaded integer literal 50 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #75
[DEBUG] Loaded integer literal 75 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X9
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X20, #0] ; Load vtable pointer for CREATE call
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #0] ; Load CREATE method address
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] Handling assignment for variable: p
[DEBUG] store_variable_register for 'p' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'p' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X20
[DEBUG]   Updating home register X26 for variable 'p' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str5
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str5
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG]   [CSE DEBUG] *** CSE-GENERATED ASSIGNMENT DETECTED: _cse_temp_0 ***
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X26
[DEBUG] Variable 'p' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X26, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #16] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::getX'
[DEBUG] Handling assignment for variable: _cse_temp_0
[DEBUG] store_variable_register for '_cse_temp_0' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable '_cse_temp_0' lives in X27. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG]   Updating home register X27 for variable '_cse_temp_0' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str7
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str7
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '

'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str8
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str8
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Setting new values...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a method call to: set
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #100
[DEBUG] Loaded integer literal 100 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #200
[DEBUG] Loaded integer literal 200 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X21, X9
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X26
[DEBUG] Variable 'p' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'Point::set'
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X21
[DEBUG LEVEL 5] Emitting instruction: BL Point::set
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str9
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str9
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading new values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L5
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L5
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_str5
[InstructionStream TRACE] Adding label definition: L_str6
[InstructionStream TRACE] Adding label definition: L_str7
[InstructionStream TRACE] Adding label definition: L_str8
[InstructionStream TRACE] Adding label definition: L_str9
[InstructionStream TRACE] Adding label definition: L_str10

[DataGenerator VTABLE] ===== Generating vtable in RODATA: Point_vtable =====
  Class: Point
  Vtable size: 5 method(s)
  Memory layout:
[InstructionStream TRACE] Adding label definition: Point_vtable
    [+0] Slot 0: Point::CREATE
    [+8] Slot 1: Point::RELEASE
    [+16] Slot 2: Point::getX
    [+24] Slot 3: Point::getY
    [+32] Slot 4: Point::set
  Total vtable size: 40 bytes
[DataGenerator VTABLE] ==========================================

[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'x' (LOCAL_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'y' (LOCAL_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'CREATE' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='CREATE')
Symbol 'getX' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='getX', parameters=[UNKNOWN])
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='getX')
Symbol 'getY' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='getY', parameters=[UNKNOWN])
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='getY')
Symbol 'set' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='set')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='set')
Symbol 'newX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='set')
Symbol 'newY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='set')
Symbol 'RELEASE' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='RELEASE')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p' (class: Point, LOCAL_VAR, POINTER_TO|OBJECT, scope=2, block=0, class_name='Point', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_cse_temp_0' (LOCAL_VAR, UNKNOWN, scope=0, block=0, class_name='', function_name='START')

Data sections generated.

=== Peephole Optimization ===
Analyzing 518 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 244
  Before:
    MOV X26, X20  [Opcode=1, Dest=26, Src1=20]
    MOV X26, X20  [Opcode=1, Dest=26, Src1=20]
  After:
    MOV X26, X20  [Opcode=1, Dest=26, Src1=20]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 254
  Before:
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
  After:
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 518
  Instructions after:  516
  Total optimizations: 2
  Patterns matched:
    - Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn): 2
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x10794c000) ---
Address Hex Code    Assembly
--------------------------------------------------
 10794c000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 10794c004 0xd29f1790  MOVZ X16, #63676
 10794c008 0xf2a04cd0  MOVK X16, #614, LSL #16
 10794c00c 0xf2c00030  MOVK X16, #1, LSL #32
 10794c010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 10794c014 0xd29f1d10  MOVZ X16, #63720
 10794c018 0xf2a04cd0  MOVK X16, #614, LSL #16
 10794c01c 0xf2c00030  MOVK X16, #1, LSL #32
 10794c020 0xd61f0200  BR X16
WRITEN_veneer:
 10794c024 0xd29bec90  MOVZ X16, #57188
 10794c028 0xf2a04ef0  MOVK X16, #631, LSL #16
 10794c02c 0xf2c00030  MOVK X16, #1, LSL #32
 10794c030 0xd61f0200  BR X16
WRITES_veneer:
 10794c034 0xd29a8b10  MOVZ X16, #54360
 10794c038 0xf2a04ef0  MOVK X16, #631, LSL #16
 10794c03c 0xf2c00030  MOVK X16, #1, LSL #32
 10794c040 0xd61f0200  BR X16
 10794c044 0x00000000  ; --- End Veneer Section ---

Point::CREATE:
 10794c048 0xa9b87bfd  STP X29, X30, [SP, #-128]!
 10794c04c 0x910003fd  MOV X29, SP
 10794c050 0xf90017b3  STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
 10794c054 0xf9001bb4  STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
 10794c058 0xf9001fb5  STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
 10794c05c 0xf90023b6  STR X22, [X29, #64] ; Saved Reg: X22 @ FP+64
 10794c060 0xf90027b7  STR X23, [X29, #72] ; Saved Reg: X23 @ FP+72
 10794c064 0xf9002bb8  STR X24, [X29, #80] ; Saved Reg: X24 @ FP+80
 10794c068 0xf9002fb9  STR X25, [X29, #88] ; Saved Reg: X25 @ FP+88
 10794c06c 0xf90033ba  STR X26, [X29, #96] ; Saved Reg: X26 @ FP+96
 10794c070 0xf90037bb  STR X27, [X29, #104] ; Saved Reg: X27 @ FP+104
 10794c074 0xf9003bbc  STR X28, [X29, #112] ; Saved Reg: X28 @ FP+112
 10794c078 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 10794c07c 0xaa0103fa  MOV X26, X1    // Move parameter 'initialX' from X1 to X26
 10794c080 0xaa0203f9  MOV X25, X2    // Move parameter 'initialY' from X2 to X25
 10794c084 0xd290001c  MOVZ X28, #32768
 10794c088 0xf2a05e9c  MOVK X28, #756, LSL #16
 10794c08c 0xf2c0003c  MOVK X28, #1, LSL #32
 10794c090 0xf2e0001c  MOVK X28, #0, LSL #48
Point::CREATE_Entry_0:
 10794c094 0xf900077a  STR X26, [X27, #8] ; Store to member x
 10794c098 0xaa1a03f8  MOV X24, X26
 10794c09c 0xf9000b79  STR X25, [X27, #16] ; Store to member y
 10794c0a0 0xaa1903f7  MOV X23, X25
 10794c0a4 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x107951000
 10794c0a8 0x91000129  ADD X9, X9, #:lo12:L_str0    ; Reloc -> 'L_str0' @ 0x107951000
 10794c0ac 0x91002129  ADD X9, X9, #8
 10794c0b0 0xaa0903e0  MOV X0, X9
 10794c0b4 0x97ffffe0  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c0b8 0xf9400769  LDR X9, [X27, #8] ; x
 10794c0bc 0xaa0903e0  MOV X0, X9
 10794c0c0 0x97ffffd9  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c0c4 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x107951058
 10794c0c8 0x91016129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x107951058
 10794c0cc 0x91002129  ADD X9, X9, #8
 10794c0d0 0xaa0903e0  MOV X0, X9
 10794c0d4 0x97ffffd8  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c0d8 0xf9400b69  LDR X9, [X27, #16] ; y
 10794c0dc 0xaa0903e0  MOV X0, X9
 10794c0e0 0x97ffffd1  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c0e4 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x107951070
 10794c0e8 0x9101c129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x107951070
 10794c0ec 0x91002129  ADD X9, X9, #8
 10794c0f0 0xaa0903e0  MOV X0, X9
 10794c0f4 0x97ffffd0  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c0f8 0x14000001  B Point::CREATE_Exit_1    ; Reloc -> 'Point::CREATE_Exit_1' @ 0x10794c0fc
Point::CREATE_Exit_1:
 10794c0fc 0x14000001  B .L0    ; Reloc -> '.L0' @ 0x10794c100
.L0:
 10794c100 0xf94017b3  LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40
 10794c104 0xf9401bb4  LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48
 10794c108 0xf9401fb5  LDR X21, [X29, #56] ; Restored Reg: X21 @ FP+56
 10794c10c 0xf94023b6  LDR X22, [X29, #64] ; Restored Reg: X22 @ FP+64
 10794c110 0xf94027b7  LDR X23, [X29, #72] ; Restored Reg: X23 @ FP+72
 10794c114 0xf9402bb8  LDR X24, [X29, #80] ; Restored Reg: X24 @ FP+80
 10794c118 0xf9402fb9  LDR X25, [X29, #88] ; Restored Reg: X25 @ FP+88
 10794c11c 0xf94033ba  LDR X26, [X29, #96] ; Restored Reg: X26 @ FP+96
 10794c120 0xf94037bb  LDR X27, [X29, #104] ; Restored Reg: X27 @ FP+104
 10794c124 0xf9403bbc  LDR X28, [X29, #112] ; Restored Reg: X28 @ FP+112
 10794c128 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 10794c12c 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 10794c130 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 10794c134 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10794c138 0xd65f03c0  RET
Point::getX:
 10794c13c 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 10794c140 0x910003fd  MOV X29, SP
 10794c144 0xf9000fb3  STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
 10794c148 0xf90013bc  STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
 10794c14c 0xaa0003ef  MOV X15, X0    // Move parameter '_this' from X0 to X15
Point::getX_Entry_0:
 10794c150 0xf94005e9  LDR X9, [X15, #8] ; x
 10794c154 0xaa0903e0  MOV X0, X9
 10794c158 0x14000003  B .L1    ; Reloc -> '.L1' @ 0x10794c164
 10794c15c 0x14000001  B Point::getX_Exit_1    ; Reloc -> 'Point::getX_Exit_1' @ 0x10794c160
Point::getX_Exit_1:
 10794c160 0x14000001  B .L1    ; Reloc -> '.L1' @ 0x10794c164
.L1:
 10794c164 0xf9400fb3  LDR X19, [X29, #24] ; Restored Reg: X19 @ FP+24
 10794c168 0xf94013bc  LDR X28, [X29, #32] ; Restored Reg: X28 @ FP+32
 10794c16c 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 10794c170 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 10794c174 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 10794c178 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10794c17c 0xd65f03c0  RET
Point::getY:
 10794c180 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 10794c184 0x910003fd  MOV X29, SP
 10794c188 0xf9000fb3  STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
 10794c18c 0xf90013bc  STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
 10794c190 0xaa0003ef  MOV X15, X0    // Move parameter '_this' from X0 to X15
Point::getY_Entry_0:
 10794c194 0xf94009e9  LDR X9, [X15, #16] ; y
 10794c198 0xaa0903e0  MOV X0, X9
 10794c19c 0x14000003  B .L2    ; Reloc -> '.L2' @ 0x10794c1a8
 10794c1a0 0x14000001  B Point::getY_Exit_1    ; Reloc -> 'Point::getY_Exit_1' @ 0x10794c1a4
Point::getY_Exit_1:
 10794c1a4 0x14000001  B .L2    ; Reloc -> '.L2' @ 0x10794c1a8
.L2:
 10794c1a8 0xf9400fb3  LDR X19, [X29, #24] ; Restored Reg: X19 @ FP+24
 10794c1ac 0xf94013bc  LDR X28, [X29, #32] ; Restored Reg: X28 @ FP+32
 10794c1b0 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 10794c1b4 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 10794c1b8 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 10794c1bc 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10794c1c0 0xd65f03c0  RET
Point::set:
 10794c1c4 0xa9b87bfd  STP X29, X30, [SP, #-128]!
 10794c1c8 0x910003fd  MOV X29, SP
 10794c1cc 0xf90017b3  STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
 10794c1d0 0xf9001bb4  STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
 10794c1d4 0xf9001fb5  STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
 10794c1d8 0xf90023b6  STR X22, [X29, #64] ; Saved Reg: X22 @ FP+64
 10794c1dc 0xf90027b7  STR X23, [X29, #72] ; Saved Reg: X23 @ FP+72
 10794c1e0 0xf9002bb8  STR X24, [X29, #80] ; Saved Reg: X24 @ FP+80
 10794c1e4 0xf9002fb9  STR X25, [X29, #88] ; Saved Reg: X25 @ FP+88
 10794c1e8 0xf90033ba  STR X26, [X29, #96] ; Saved Reg: X26 @ FP+96
 10794c1ec 0xf90037bb  STR X27, [X29, #104] ; Saved Reg: X27 @ FP+104
 10794c1f0 0xf9003bbc  STR X28, [X29, #112] ; Saved Reg: X28 @ FP+112
 10794c1f4 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 10794c1f8 0xaa0103fa  MOV X26, X1    // Move parameter 'newX' from X1 to X26
 10794c1fc 0xaa0203f9  MOV X25, X2    // Move parameter 'newY' from X2 to X25
 10794c200 0xd290001c  MOVZ X28, #32768
 10794c204 0xf2a05e9c  MOVK X28, #756, LSL #16
 10794c208 0xf2c0003c  MOVK X28, #1, LSL #32
 10794c20c 0xf2e0001c  MOVK X28, #0, LSL #48
Point::set_Entry_0:
 10794c210 0xf900077a  STR X26, [X27, #8] ; Store to member x
 10794c214 0xaa1a03f8  MOV X24, X26
 10794c218 0xf9000b79  STR X25, [X27, #16] ; Store to member y
 10794c21c 0xaa1903f7  MOV X23, X25
 10794c220 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x107951088
 10794c224 0x91022129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x107951088
 10794c228 0x91002129  ADD X9, X9, #8
 10794c22c 0xaa0903e0  MOV X0, X9
 10794c230 0x97ffff81  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c234 0xf9400769  LDR X9, [X27, #8] ; x
 10794c238 0xaa0903e0  MOV X0, X9
 10794c23c 0x97ffff7a  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c240 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x107951058
 10794c244 0x91016129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x107951058
 10794c248 0x91002129  ADD X9, X9, #8
 10794c24c 0xaa0903e0  MOV X0, X9
 10794c250 0x97ffff79  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c254 0xf9400b69  LDR X9, [X27, #16] ; y
 10794c258 0xaa0903e0  MOV X0, X9
 10794c25c 0x97ffff72  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c260 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x107951070
 10794c264 0x9101c129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x107951070
 10794c268 0x91002129  ADD X9, X9, #8
 10794c26c 0xaa0903e0  MOV X0, X9
 10794c270 0x97ffff71  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c274 0x14000001  B Point::set_Exit_1    ; Reloc -> 'Point::set_Exit_1' @ 0x10794c278
Point::set_Exit_1:
 10794c278 0x14000001  B .L3    ; Reloc -> '.L3' @ 0x10794c27c
.L3:
 10794c27c 0xf94017b3  LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40
 10794c280 0xf9401bb4  LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48
 10794c284 0xf9401fb5  LDR X21, [X29, #56] ; Restored Reg: X21 @ FP+56
 10794c288 0xf94023b6  LDR X22, [X29, #64] ; Restored Reg: X22 @ FP+64
 10794c28c 0xf94027b7  LDR X23, [X29, #72] ; Restored Reg: X23 @ FP+72
 10794c290 0xf9402bb8  LDR X24, [X29, #80] ; Restored Reg: X24 @ FP+80
 10794c294 0xf9402fb9  LDR X25, [X29, #88] ; Restored Reg: X25 @ FP+88
 10794c298 0xf94033ba  LDR X26, [X29, #96] ; Restored Reg: X26 @ FP+96
 10794c29c 0xf94037bb  LDR X27, [X29, #104] ; Restored Reg: X27 @ FP+104
 10794c2a0 0xf9403bbc  LDR X28, [X29, #112] ; Restored Reg: X28 @ FP+112
 10794c2a4 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 10794c2a8 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 10794c2ac 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 10794c2b0 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10794c2b4 0xd65f03c0  RET
Point::RELEASE:
 10794c2b8 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 10794c2bc 0x910003fd  MOV X29, SP
 10794c2c0 0xf9000fb3  STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
 10794c2c4 0xf90013bc  STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
 10794c2c8 0xaa0003ef  MOV X15, X0    // Move parameter '_this' from X0 to X15
Point::RELEASE_Entry_0:
 10794c2cc 0x14000001  B Point::RELEASE_Exit_1    ; Reloc -> 'Point::RELEASE_Exit_1' @ 0x10794c2d0
Point::RELEASE_Exit_1:
 10794c2d0 0x14000001  B .L4    ; Reloc -> '.L4' @ 0x10794c2d4
.L4:
 10794c2d4 0xf9400fb3  LDR X19, [X29, #24] ; Restored Reg: X19 @ FP+24
 10794c2d8 0xf94013bc  LDR X28, [X29, #32] ; Restored Reg: X28 @ FP+32
 10794c2dc 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 10794c2e0 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 10794c2e4 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 10794c2e8 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10794c2ec 0xd65f03c0  RET
START:
 10794c2f0 0xa9bc7bfd  STP X29, X30, [SP, #-64]!
 10794c2f4 0x910003fd  MOV X29, SP
 10794c2f8 0xf90013b3  STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
 10794c2fc 0xf90017ba  STR X26, [X29, #40] ; Saved Reg: X26 @ FP+40
 10794c300 0xf9001bbb  STR X27, [X29, #48] ; Saved Reg: X27 @ FP+48
 10794c304 0xf9001fbc  STR X28, [X29, #56] ; Saved Reg: X28 @ FP+56
 10794c308 0xd290001c  MOVZ X28, #32768
 10794c30c 0xf2a05e9c  MOVK X28, #756, LSL #16
 10794c310 0xf2c0003c  MOVK X28, #1, LSL #32
 10794c314 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 10794c318 0x97ffff3b  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x10794c004
 10794c31c 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x1079510d8
 10794c320 0x91036129  ADD X9, X9, #:lo12:L_str4    ; Reloc -> 'L_str4' @ 0x1079510d8
 10794c324 0x91002129  ADD X9, X9, #8
 10794c328 0xaa0903e0  MOV X0, X9
 10794c32c 0x97ffff42  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c330 0xd2800300  MOVZ X0, #24
 10794c334 0x96b8d12e  BL OBJECT_HEAP_ALLOC    ; Reloc -> 'OBJECT_HEAP_ALLOC' @ 0x1027807ec
 10794c338 0xaa0003f4  MOV X20, X0
 10794c33c 0xb0000029  ADRP X9, Point_vtable    ; Reloc -> 'Point_vtable' @ 0x1079512a4
 10794c340 0x910a9129  ADD X9, X9, #:lo12:Point_vtable    ; Reloc -> 'Point_vtable' @ 0x1079512a4
 10794c344 0xf9000289  STR X9, [X20, #0] ; store vtable ptr
 10794c348 0xaa1403e0  MOV X0, X20
 10794c34c 0xd2800649  MOVZ X9, #50
 10794c350 0xaa0903e1  MOV X1, X9
 10794c354 0xd2800969  MOVZ X9, #75
 10794c358 0xaa0903e2  MOV X2, X9
 10794c35c 0xf9400289  LDR X9, [X20, #0] ; Load vtable pointer for CREATE call
 10794c360 0xf940012a  LDR X10, [X9, #0] ; Load CREATE method address
 10794c364 0xd63f0140  BLR X10
 10794c368 0xaa1403fa  MOV X26, X20
 10794c36c 0xb0000029  ADRP X9, L_str5    ; Reloc -> 'L_str5' @ 0x107951130
 10794c370 0x9104c129  ADD X9, X9, #:lo12:L_str5    ; Reloc -> 'L_str5' @ 0x107951130
 10794c374 0x91002129  ADD X9, X9, #8
 10794c378 0xaa0903e0  MOV X0, X9
 10794c37c 0x97ffff2e  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c380 0xf9400349  LDR X9, [X26, #0] ; Load vtable pointer
 10794c384 0xf940092a  LDR X10, [X9, #16] ; Load method address
 10794c388 0xaa1a03e0  MOV X0, X26
 10794c38c 0xd63f0140  BLR X10
 10794c390 0xaa0003fb  MOV X27, X0
 10794c394 0xaa1b03e0  MOV X0, X27
 10794c398 0x97ffff23  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c39c 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x107951188
 10794c3a0 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x107951188
 10794c3a4 0x91002129  ADD X9, X9, #8
 10794c3a8 0xaa0903e0  MOV X0, X9
 10794c3ac 0x97ffff22  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c3b0 0xaa1b03e0  MOV X0, X27
 10794c3b4 0x97ffff1c  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c3b8 0xb0000029  ADRP X9, L_str7    ; Reloc -> 'L_str7' @ 0x1079511a8
 10794c3bc 0x9106a129  ADD X9, X9, #:lo12:L_str7    ; Reloc -> 'L_str7' @ 0x1079511a8
 10794c3c0 0x91002129  ADD X9, X9, #8
 10794c3c4 0xaa0903e0  MOV X0, X9
 10794c3c8 0x97ffff1b  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c3cc 0xb0000029  ADRP X9, L_str8    ; Reloc -> 'L_str8' @ 0x1079511c0
 10794c3d0 0x91070129  ADD X9, X9, #:lo12:L_str8    ; Reloc -> 'L_str8' @ 0x1079511c0
 10794c3d4 0x91002129  ADD X9, X9, #8
 10794c3d8 0xaa0903e0  MOV X0, X9
 10794c3dc 0x97ffff16  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c3e0 0xd2800c89  MOVZ X9, #100
 10794c3e4 0xaa0903f4  MOV X20, X9
 10794c3e8 0xd2801909  MOVZ X9, #200
 10794c3ec 0xaa0903f5  MOV X21, X9
 10794c3f0 0xaa1a03e0  MOV X0, X26
 10794c3f4 0xaa1403e1  MOV X1, X20
 10794c3f8 0xaa1503e2  MOV X2, X21
 10794c3fc 0x97ffff72  BL Point::set    ; Reloc -> 'Point::set' @ 0x10794c1c4
 10794c400 0xb0000029  ADRP X9, L_str9    ; Reloc -> 'L_str9' @ 0x107951228
 10794c404 0x9108a129  ADD X9, X9, #:lo12:L_str9    ; Reloc -> 'L_str9' @ 0x107951228
 10794c408 0x91002129  ADD X9, X9, #8
 10794c40c 0xaa0903e0  MOV X0, X9
 10794c410 0x97ffff09  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c414 0xaa1b03e0  MOV X0, X27
 10794c418 0x97ffff03  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c41c 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x107951188
 10794c420 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x107951188
 10794c424 0x91002129  ADD X9, X9, #8
 10794c428 0xaa0903e0  MOV X0, X9
 10794c42c 0x97ffff02  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c430 0xaa1b03e0  MOV X0, X27
 10794c434 0x97fffefc  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x10794c024
 10794c438 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x107951290
 10794c43c 0x910a4129  ADD X9, X9, #:lo12:L_str10    ; Reloc -> 'L_str10' @ 0x107951290
 10794c440 0x91002129  ADD X9, X9, #8
 10794c444 0xaa0903e0  MOV X0, X9
 10794c448 0x97fffefb  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x10794c034
 10794c44c 0x97fffef2  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x10794c014
 10794c450 0x14000001  B START_Exit_1    ; Reloc -> 'START_Exit_1' @ 0x10794c454
START_Exit_1:
 10794c454 0x14000001  B .L5    ; Reloc -> '.L5' @ 0x10794c458
.L5:
 10794c458 0xf94013b3  LDR X19, [X29, #32] ; Restored Reg: X19 @ FP+32
 10794c45c 0xf94017ba  LDR X26, [X29, #40] ; Restored Reg: X26 @ FP+40
 10794c460 0xf9401bbb  LDR X27, [X29, #48] ; Restored Reg: X27 @ FP+48
 10794c464 0xf9401fbc  LDR X28, [X29, #56] ; Restored Reg: X28 @ FP+56
 10794c468 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 10794c46c 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 10794c470 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 10794c474 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 10794c478 0xd65f03c0  RET
L_str0:
 107951000 0x12000000  .quad 0x12
 107951004 0x00000000  ; (upper half)
 107951008 0x50000000  DCD 0x50
 10795100c 0x6f000000  DCD 0x6f
 107951010 0x69000000  DCD 0x69
 107951014 0x6e000000  DCD 0x6e
 107951018 0x74000000  DCD 0x74
 10795101c 0x20000000  DCD 0x20
 107951020 0x63000000  DCD 0x63
 107951024 0x72000000  DCD 0x72
 107951028 0x65000000  DCD 0x65
 10795102c 0x61000000  DCD 0x61
 107951030 0x74000000  DCD 0x74
 107951034 0x65000000  DCD 0x65
 107951038 0x64000000  DCD 0x64
 10795103c 0x20000000  DCD 0x20
 107951040 0x61000000  DCD 0x61
 107951044 0x74000000  DCD 0x74
 107951048 0x20000000  DCD 0x20
 10795104c 0x28000000  DCD 0x28
 107951050 0x00000000  DCD 0x0
 107951054 0x00000000  DCD 0x0
L_str1:
 107951058 0x20000000  .quad 0x2
 10795105c 0x00000000  ; (upper half)
 107951060 0x2c000000  DCD 0x2c
 107951064 0x20000000  DCD 0x20
 107951068 0x00000000  DCD 0x0
 10795106c 0x00000000  DCD 0x0
L_str2:
 107951070 0x20000000  .quad 0x2
 107951074 0x00000000  ; (upper half)
 107951078 0x29000000  DCD 0x29
 10795107c 0xa0000000  DCD 0xa
 107951080 0x00000000  DCD 0x0
 107951084 0x00000000  DCD 0x0
L_str3:
 107951088 0x10000000  .quad 0x10
 10795108c 0x00000000  ; (upper half)
 107951090 0x50000000  DCD 0x50
 107951094 0x6f000000  DCD 0x6f
 107951098 0x69000000  DCD 0x69
 10795109c 0x6e000000  DCD 0x6e
 1079510a0 0x74000000  DCD 0x74
 1079510a4 0x20000000  DCD 0x20
 1079510a8 0x6d000000  DCD 0x6d
 1079510ac 0x6f000000  DCD 0x6f
 1079510b0 0x76000000  DCD 0x76
 1079510b4 0x65000000  DCD 0x65
 1079510b8 0x64000000  DCD 0x64
 1079510bc 0x20000000  DCD 0x20
 1079510c0 0x74000000  DCD 0x74
 1079510c4 0x6f000000  DCD 0x6f
 1079510c8 0x20000000  DCD 0x20
 1079510cc 0x28000000  DCD 0x28
 1079510d0 0x00000000  DCD 0x0
 1079510d4 0x00000000  DCD 0x0
L_str4:
 1079510d8 0x12000000  .quad 0x12
 1079510dc 0x00000000  ; (upper half)
 1079510e0 0x43000000  DCD 0x43
 1079510e4 0x72000000  DCD 0x72
 1079510e8 0x65000000  DCD 0x65
 1079510ec 0x61000000  DCD 0x61
 1079510f0 0x74000000  DCD 0x74
 1079510f4 0x69000000  DCD 0x69
 1079510f8 0x6e000000  DCD 0x6e
 1079510fc 0x67000000  DCD 0x67
 107951100 0x20000000  DCD 0x20
 107951104 0x70000000  DCD 0x70
 107951108 0x6f000000  DCD 0x6f
 10795110c 0x69000000  DCD 0x69
 107951110 0x6e000000  DCD 0x6e
 107951114 0x74000000  DCD 0x74
 107951118 0x2e000000  DCD 0x2e
 10795111c 0x2e000000  DCD 0x2e
 107951120 0x2e000000  DCD 0x2e
 107951124 0xa0000000  DCD 0xa
 107951128 0x00000000  DCD 0x0
 10795112c 0x00000000  DCD 0x0
L_str5:
 107951130 0x12000000  .quad 0x12
 107951134 0x00000000  ; (upper half)
 107951138 0x52000000  DCD 0x52
 10795113c 0x65000000  DCD 0x65
 107951140 0x61000000  DCD 0x61
 107951144 0x64000000  DCD 0x64
 107951148 0x69000000  DCD 0x69
 10795114c 0x6e000000  DCD 0x6e
 107951150 0x67000000  DCD 0x67
 107951154 0x20000000  DCD 0x20
 107951158 0x76000000  DCD 0x76
 10795115c 0x61000000  DCD 0x61
 107951160 0x6c000000  DCD 0x6c
 107951164 0x75000000  DCD 0x75
 107951168 0x65000000  DCD 0x65
 10795116c 0x73000000  DCD 0x73
 107951170 0x3a000000  DCD 0x3a
 107951174 0x20000000  DCD 0x20
 107951178 0x78000000  DCD 0x78
 10795117c 0x3d000000  DCD 0x3d
 107951180 0x00000000  DCD 0x0
 107951184 0x00000000  DCD 0x0
L_str6:
 107951188 0x40000000  .quad 0x4
 10795118c 0x00000000  ; (upper half)
 107951190 0x2c000000  DCD 0x2c
 107951194 0x20000000  DCD 0x20
 107951198 0x79000000  DCD 0x79
 10795119c 0x3d000000  DCD 0x3d
 1079511a0 0x00000000  DCD 0x0
 1079511a4 0x00000000  DCD 0x0
L_str7:
 1079511a8 0x20000000  .quad 0x2
 1079511ac 0x00000000  ; (upper half)
 1079511b0 0xa0000000  DCD 0xa
 1079511b4 0xa0000000  DCD 0xa
 1079511b8 0x00000000  DCD 0x0
 1079511bc 0x00000000  DCD 0x0
L_str8:
 1079511c0 0x16000000  .quad 0x16
 1079511c4 0x00000000  ; (upper half)
 1079511c8 0x53000000  DCD 0x53
 1079511cc 0x65000000  DCD 0x65
 1079511d0 0x74000000  DCD 0x74
 1079511d4 0x74000000  DCD 0x74
 1079511d8 0x69000000  DCD 0x69
 1079511dc 0x6e000000  DCD 0x6e
 1079511e0 0x67000000  DCD 0x67
 1079511e4 0x20000000  DCD 0x20
 1079511e8 0x6e000000  DCD 0x6e
 1079511ec 0x65000000  DCD 0x65
 1079511f0 0x77000000  DCD 0x77
 1079511f4 0x20000000  DCD 0x20
 1079511f8 0x76000000  DCD 0x76
 1079511fc 0x61000000  DCD 0x61
 107951200 0x6c000000  DCD 0x6c
 107951204 0x75000000  DCD 0x75
 107951208 0x65000000  DCD 0x65
 10795120c 0x73000000  DCD 0x73
 107951210 0x2e000000  DCD 0x2e
 107951214 0x2e000000  DCD 0x2e
 107951218 0x2e000000  DCD 0x2e
 10795121c 0xa0000000  DCD 0xa
 107951220 0x00000000  DCD 0x0
 107951224 0x00000000  DCD 0x0
L_str9:
 107951228 0x16000000  .quad 0x16
 10795122c 0x00000000  ; (upper half)
 107951230 0x52000000  DCD 0x52
 107951234 0x65000000  DCD 0x65
 107951238 0x61000000  DCD 0x61
 10795123c 0x64000000  DCD 0x64
 107951240 0x69000000  DCD 0x69
 107951244 0x6e000000  DCD 0x6e
 107951248 0x67000000  DCD 0x67
 10795124c 0x20000000  DCD 0x20
 107951250 0x6e000000  DCD 0x6e
 107951254 0x65000000  DCD 0x65
 107951258 0x77000000  DCD 0x77
 10795125c 0x20000000  DCD 0x20
 107951260 0x76000000  DCD 0x76
 107951264 0x61000000  DCD 0x61
 107951268 0x6c000000  DCD 0x6c
 10795126c 0x75000000  DCD 0x75
 107951270 0x65000000  DCD 0x65
 107951274 0x73000000  DCD 0x73
 107951278 0x3a000000  DCD 0x3a
 10795127c 0x20000000  DCD 0x20
 107951280 0x78000000  DCD 0x78
 107951284 0x3d000000  DCD 0x3d
 107951288 0x00000000  DCD 0x0
 10795128c 0x00000000  DCD 0x0
L_str10:
 107951290 0x10000000  .quad 0x1
 107951294 0x00000000  ; (upper half)
 107951298 0xa0000000  DCD 0xa
 10795129c 0x00000000  DCD 0x0
 1079512a0 0x00000000  DCD 0x0
Point_vtable:
 1079512a4 0x794c0480  .quad Point::CREATE    ; Reloc -> 'Point::CREATE' @ 0x10794c048
 1079512ac 0x794c2b80  .quad Point::RELEASE    ; Reloc -> 'Point::RELEASE' @ 0x10794c2b8
 1079512b4 0x794c13c0  .quad Point::getX    ; Reloc -> 'Point::getX' @ 0x10794c13c
 1079512bc 0x794c1800  .quad Point::getY    ; Reloc -> 'Point::getY' @ 0x10794c180
 1079512c4 0x794c1c40  .quad Point::set    ; Reloc -> 'Point::set' @ 0x10794c1c4

--------------------------

JIT runtime table populated with 123 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x10794c2f0
[JITExecutor] Starting execution of JIT-compiled function at address: 0x10794c2f0
SAMM: Entered scope (depth: 2)
Creating point...
SAMM: Tracked allocation 0x752c380e0 in scope (depth: 2, scope size: 1)
DEBUG: ListAtom allocated at 0x752c380e0 (total atoms: 1)
Point created at (50, 75)
Reading values: x=50, y=50

Setting new values...
Point moved to (100, 200)
Reading new values: x=50, y=50
SAMM: Scope exit - found 1 objects to cleanup (remaining depth: 1)
SAMM: About to queue 1 objects for cleanup
SAMM: Queued objects for background cleanup (queue depth: 1)
SAMM: Notified background worker
JIT Execution completed with result: 4464098944
  Same value as double: 2.20556e-314
[JITExecutor] Execution completed. Result: 4464098944

--- JIT returned with result: 4464098944 ---
SAMM: Worker woke up, queue size: 1, running: YES
SAMM: Processing batch of 1 objects
SAMM: cleanupPointersImmediate called with 1 pointers
SAMM: Cleaning up pointer 0x752c380e0
DEBUG: HeapManager::free called with payload=0x752c380e0
DEBUG: Checking payload 0x752c380e0 in Bloom filter
DEBUG: Checking base address 0x752c380d8 in Bloom filter
DEBUG: Adding base address 0x752c380e0 to Bloom filter

--- BCPL Runtime Metrics ---
Memory allocations: 1 (24 bytes)
Memory frees: 1 (24 bytes)
Vector allocations: 0
String allocations: 0
Double-free attempts: 0
Current active allocations: 0 (0 bytes)
Bloom filter statistics:
  Items tracked: 1
  Memory usage: 12000000 bytes
  False positives: 0
DEBUG: Fixed Bloom filter (12MB) now has ~1 items (capacity: 10M, estimated false positive rate: 0.0000%)
SAMM: Successfully cleaned pointer 0x752c380e0
SAMM: cleanupPointersImmediate completed 1 items in 41.093 ms
SAMM: Background worker processed batch of 1 objects
SAMM: Worker waiting for cleanup queue (queue size: 0)
  Est. false positive rate: 0.0000%
File I/O operations:
  Files opened: 0
  Files closed: 0
  Bytes read: 0
  Bytes written: 0
  Open files: 0
--------------------------
SAMM: Processed all pending cleanup operations
SAMM: Worker woke up, queue size: 0, running: NO
SAMM: Background cleanup worker thread stopped (DEBUG)
SAMM: Background worker stopped
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: Shutdown complete
