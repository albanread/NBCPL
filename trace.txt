Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=tests/bcl_tests/lists8.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.1653
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/tests/bcl_tests/lists8.bcl"
LET START() BE
$(
   LET L = LIST("a", "string", "list")
   FOREACH S IN L DO
   $( 
            WRITES("String: ")
            WRITES(S)
            WRITES("*N")
    $)
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x100a0a054
Registered 91 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x100a08d88 | args: 0 | table_offset: 712
  FINISH           | address: 0x100a07b38 | args: 0 | table_offset: 704
  FABS             | address: 0x100a07ee8 | args: 1 | table_offset: 672
  FSIN             | address: 0x100a07eac | args: 1 | table_offset: 648
  FILE_EOF         | address: 0x100a0b1a0 | args: 1 | table_offset: 616
  RAND             | address: 0x100a07d38 | args: 1 | table_offset: 624
  FILE_TELL        | address: 0x100a0b148 | args: 1 | table_offset: 608
  FILE_SEEK        | address: 0x100a0b084 | args: 3 | table_offset: 600
  FILE_WRITE       | address: 0x100a0af6c | args: 3 | table_offset: 592
  FIX              | address: 0x100a07f28 | args: 1 | table_offset: 696
  FILE_READS       | address: 0x100a0a9b8 | args: 1 | table_offset: 576
  FILE_WRITES      | address: 0x100a0a6dc | args: 2 | table_offset: 568
  FEXP             | address: 0x100a07f14 | args: 1 | table_offset: 688
  FILE_CLOSE       | address: 0x100a0a670 | args: 1 | table_offset: 560
  FILE_OPEN_APPEND | address: 0x100a0a5e0 | args: 1 | table_offset: 552
  SLURP            | address: 0x100a08610 | args: 1 | table_offset: 520
  PACKSTRING       | address: 0x100a07f40 | args: 1 | table_offset: 504
  STRLEN           | address: 0x100a07b48 | args: 1 | table_offset: 496
  FCOS             | address: 0x100a07ec0 | args: 1 | table_offset: 656
  STRCMP           | address: 0x100a07ba8 | args: 2 | table_offset: 488
  STRCOPY          | address: 0x100a07c8c | args: 2 | table_offset: 480
  FIND             | address: 0x100a0e6c8 | args: 3 | table_offset: 448
  DEEPCOPYLITERALLIST | address: 0x100a0e340 | args: 1 | table_offset: 432
  DEEPCOPYLIST     | address: 0x100a0e1a8 | args: 1 | table_offset: 424
  COPYLIST         | address: 0x100a0e0a8 | args: 1 | table_offset: 416
  CONCAT           | address: 0x100a0e4e0 | args: 2 | table_offset: 408
  BCPL_CONCAT_LISTS | address: 0x100a0e4e0 | args: 2 | table_offset: 400
  SPIT             | address: 0x100a08b3c | args: 2 | table_offset: 528
  JOIN             | address: 0x100a0d744 | args: 2 | table_offset: 472
  LPND             | address: 0x100a0dc54 | args: 2 | table_offset: 392
  SPND             | address: 0x100a0db84 | args: 2 | table_offset: 384
  FPND             | address: 0x100a0dab4 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x100a0eb98 | args: 1 | table_offset: 720
  BCPL_LIST_APPEND_INT | address: 0x100a0d9e4 | args: 2 | table_offset: 344
  GETVEC           | address: 0x100a0a118 | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x1008e79e0 | args: 0 | table_offset: 312
  APND             | address: 0x100a0d9e4 | args: 2 | table_offset: 368
  HEAPMANAGER_ENTER_SCOPE | address: 0x1008e7918 | args: 0 | table_offset: 280
  HEAPMANAGER_SETSAMMENABLED | address: 0x1008e78c4 | args: 1 | table_offset: 296
  HEAPMANAGER_EXIT_SCOPE | address: 0x1008e7944 | args: 0 | table_offset: 288
  PIC_RUNTIME_HELPER | address: 0x100a0a1cc | args: 0 | table_offset: 272
  OBJECT_HEAP_FREE | address: 0x100a0a190 | args: 1 | table_offset: 256
  OBJECT_HEAP_ALLOC | address: 0x100a0a16c | args: 1 | table_offset: 248
  BCPL_LIST_GET_REST | address: 0x100a0df10 | args: 1 | table_offset: 216
  FRND             | address: 0x100a07dc4 | args: 0 | table_offset: 640
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x100a0de58 | args: 1 | table_offset: 200
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x100a0ddf4 | args: 1 | table_offset: 192
  RUNTIME_METHOD_LOOKUP | address: 0x100a0a1b4 | args: 2 | table_offset: 264
  FREEVEC          | address: 0x100a0a054 | args: 1 | table_offset: 136
  BCPL_BOUNDS_ERROR | address: 0x100a06018 | args: 3 | table_offset: 184
  WRITEF4          | address: 0x100a0766c | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x100a0e86c | args: 1 | table_offset: 144
  BCPL_ALLOC_CHARS | address: 0x100a09ffc | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x100a0dab4 | args: 2 | table_offset: 352
  GET_FREE_LIST_HEAD_ADDR | address: 0x100a0eb8c | args: 0 | table_offset: 328
  BCPL_GET_ATOM_TYPE | address: 0x100a0df74 | args: 1 | table_offset: 224
  FWRITE           | address: 0x100a07048 | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x100a0d984 | args: 0 | table_offset: 336
  SPLIT            | address: 0x100a0d3d8 | args: 2 | table_offset: 464
  BCPL_FREE_CELLS  | address: 0x100a0eb88 | args: 0 | table_offset: 320
  RND              | address: 0x100a07e18 | args: 1 | table_offset: 632
  HEAPMANAGER_ISSAMMENABLED | address: 0x1008e78f4 | args: 0 | table_offset: 304
  WRITEC           | address: 0x100a07928 | args: 1 | table_offset: 88
  MALLOC           | address: 0x100a09f9c | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x100a09f9c | args: 3 | table_offset: 104
  FTAN             | address: 0x100a07ed4 | args: 1 | table_offset: 664
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 240
  BCPL_GET_LAST_ERROR | address: 0x100a05e98 | args: 1 | table_offset: 160
  RDCH             | address: 0x100a07aec | args: 0 | table_offset: 96
  FILE_READ        | address: 0x100a0ae58 | args: 3 | table_offset: 584
  UNPACKSTRING     | address: 0x100a08278 | args: 1 | table_offset: 512
  WRITEF5          | address: 0x100a076f8 | args: 6 | table_offset: 64
  FILTER           | address: 0x100a0e7bc | args: 2 | table_offset: 456
  BCPL_FREE_LIST_SAFE | address: 0x100a0e974 | args: 1 | table_offset: 152
  FILE_OPEN_WRITE  | address: 0x100a0a550 | args: 1 | table_offset: 544
  FILE_OPEN_READ   | address: 0x100a0a1d0 | args: 1 | table_offset: 536
  BCPL_LIST_GET_NTH | address: 0x100a0dfdc | args: 2 | table_offset: 232
  WRITEF7          | address: 0x100a07834 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x100a075ec | args: 4 | table_offset: 48
  WRITEF6          | address: 0x100a07790 | args: 7 | table_offset: 72
  REVERSE          | address: 0x100a0e5e0 | args: 1 | table_offset: 440
  WRITEF2          | address: 0x100a07578 | args: 3 | table_offset: 40
  WRITEF1          | address: 0x100a07510 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x100a0dec0 | args: 1 | table_offset: 208
  BCPL_CLEAR_ERRORS | address: 0x100a05f48 | args: 0 | table_offset: 168
  WRITEF           | address: 0x100a0708c | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x100a0db84 | args: 2 | table_offset: 360
  WRITES           | address: 0x100a06dd8 | args: 1 | table_offset: 0
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x100a0ebe0 | args: 0 | table_offset: 176
  FLOG             | address: 0x100a07f00 | args: 1 | table_offset: 680
  WRITEN           | address: 0x100a078e4 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: L as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing foreach statement, loop variable: S
[SymbolDiscoveryPass] Added foreach loop variable: S
[SymbolDiscoveryPass] Entering block scope

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'S' (LOCAL_VAR, UNKNOWN, scope=2, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 2 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[DEBUG] ListExpression: contains_literals = true, num_initializers = 3
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE] Pushed FOREACH loop context. Context stack size: 1
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 1
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Entering block scope: START_block_0_block_1 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 3 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0xb8f0041b0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0xb8f0041e0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S
[DEBUG get_effective_variable_name] Called with: 'S'
[DEBUG get_effective_variable_name] Loop context stack size: 1
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0xb8f004210
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[DEBUG get_variable_type] Looking for 'L' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Found in variable_types: L -> 1050625
[ANALYZER TRACE] Popped FOREACH loop context. Context stack size: 0
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 0
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 0
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 2
  Float Locals: 0
  Runtime Calls: 3
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 12 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 12 for function 'START'
[CFGBuilderPass] Starting block 1 variable tracking
[CFGBuilderPass] Tracking variable 'L' in current block
[CFGBuilderPass] visit(ForEachStatement) entered.
[DEBUG get_variable_type] Looking for 'L' in function 'START'
[DEBUG get_variable_type] Found function metrics for 'START'
[DEBUG get_variable_type] Parameter types count: 0
[DEBUG get_variable_type] Variable types count: 2
[DEBUG get_variable_type] Found in variable_types: L -> 1050625
[CFGBuilderPass] OPTIMIZATION: Using direct variable 'L' for list FOREACH instead of creating a temporary header.
[CFGBuilderPass] Created new basic block: START_ForEachHeader_1
[CFGBuilderPass] Created new basic block: START_ForEachBody_2
[CFGBuilderPass] Created new basic block: START_ForEachExit_3
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 13 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 13 for function 'START'
[CFGBuilderPass] Starting block 2 variable tracking
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 14 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 14 for function 'START'
[CFGBuilderPass] Created new basic block: START_ForEachAdvance_4
[CFGBuilderPass] Correctly built low-level CFG for list-based FOREACH.
[CFGBuilderPass] visit(ForEachStatement) exiting.
[CFGBuilderPass] Generating normal block-end cleanup for 1 variables
[CFGBuilderPass] Generating block-end cleanup for: L
[CFGBuilderPass] Skipping BCPL_FREE_LIST(L) - SAMM is active
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 15 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 15 for function 'START'
[CFGBuilderPass] Created new basic block: START_Exit_5
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 0
  Edges redirected: 0
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 6 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_5) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_5
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_5 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_5
[LivenessAnalysisPass] Analyzing block #2 (id=START_ForEachAdvance_4) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachAdvance_4
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachAdvance_4 with 1 statements
[LivenessAnalysisPass] Statement uses variables: _forEach_cursor_0 
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachAdvance_4
[LivenessAnalysisPass] Analyzing block #3 (id=START_ForEachBody_2) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachBody_2
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachBody_2 with 6 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: S 
[LivenessAnalysisPass] Variables used after call: S 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _forEach_cursor_0 
[LivenessAnalysisPass] Variables used after call: _forEach_cursor_0 
[LivenessAnalysisPass] Intra-block call interval detected in START_ForEachBody_2 - variables live across calls: S _forEach_cursor_0 
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_ForEachBody_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachBody_2
[LivenessAnalysisPass] Analyzing block #4 (id=START_ForEachHeader_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachHeader_1
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachHeader_1 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachHeader_1
[LivenessAnalysisPass] Analyzing block #5 (id=START_ForEachExit_3) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_ForEachExit_3
[LivenessAnalysisPass] Starting intra-block analysis for START_ForEachExit_3 with 1 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block START_ForEachExit_3 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_ForEachExit_3
[LivenessAnalysisPass] Analyzing block #6 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 3 statements
[LivenessAnalysisPass] Statement uses variables: L 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_ForEachAdvance_4 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachBody_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachBody_2 - adding 1 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Exit_5 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachExit_3 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachExit_3 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_ForEachHeader_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_ForEachAdvance_4 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachBody_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachBody_2 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Exit_5 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachExit_3 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachExit_3 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_ForEachHeader_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 3
[LivenessAnalysisPass] Processing block: START_ForEachAdvance_4 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachBody_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachBody_2 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Exit_5 in function: START
[LivenessAnalysisPass] Processing block: START_ForEachExit_3 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_ForEachExit_3 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_ForEachHeader_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_5
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_ForEachAdvance_4
  Use: { _forEach_cursor_0 }
  Def: { _forEach_cursor_0 }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }
Block ID: START_ForEachBody_2
  Use: { S _forEach_cursor_0 }
  Def: { S }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }
Block ID: START_ForEachHeader_1
  Use: { _forEach_cursor_0 }
  Def: { }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }
Block ID: START_ForEachExit_3
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { }
  Def: { L _forEach_cursor_0 }
  In : { S _forEach_cursor_0 }
  Out: { S _forEach_cursor_0 }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_5 (conceptual)

Block ID: START_Exit_5 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_ForEachExit_3

Block ID: START_ForEachAdvance_4
  Statements:
    - AssignmentStmt
  Successors: START_ForEachHeader_1
  Predecessors: START_ForEachBody_2

Block ID: START_ForEachBody_2
  Statements:
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_ForEachAdvance_4
  Predecessors: START_ForEachHeader_1

Block ID: START_ForEachHeader_1
  Statements:
    - ConditionalBranchStmt
  Successors: START_ForEachBody_2, START_ForEachExit_3
  Predecessors: START_Entry_0, START_ForEachAdvance_4

Block ID: START_ForEachExit_3
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_5
  Predecessors: START_ForEachHeader_1

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - AssignmentStmt
  Successors: START_ForEachHeader_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[LiveIntervalPass] Created 3 intervals for function: START
  S: [0-17]
  _forEach_cursor_0: [0-17]
  L: [1-2]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 7 call sites at: 0 4 8 12 13 14 15 
[Allocator] Partitioned: 2 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing S [0-17]
  Assigned callee-saved register X27 to S
[ALLOC] Updated allocations for S: spilled=0, register='X27'
[Allocator] Allocating call-crossing _forEach_cursor_0 [0-17]
  Assigned callee-saved register X26 to _forEach_cursor_0
[ALLOC] Updated allocations for _forEach_cursor_0: spilled=0, register='X26'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only L [1-2]
  Assigned register X15 to L
[ALLOC] Updated allocations for L: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  L: reg X15 (caller-saved) [local-only]
  S: reg X27 (callee-saved) [call-crossing]
  _forEach_cursor_0: reg X26 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 3
  Float Locals: 0
  Runtime Calls: 3
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 2
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4391944192
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 1 unique external functions:
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] Generating 3 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 3 veneers, estimated total size: 60 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: START
[SYNC] Found 3 variable allocations
[SYNC] Reserved register X15 for variable L
[SYNC] Reserved register X27 for variable S
[SYNC] Reserved register X26 for variable _forEach_cursor_0
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 3
[DEBUG] DEBUG: variable_types['L'] = POINTER_TO|LIST|INTEGER
[DEBUG] DEBUG: variable_types['S'] = INTEGER
[DEBUG] DEBUG: variable_types['_forEach_cursor_0'] = POINTER_TO|LIST
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'L' of type 1050625 at offset 16 (size 8)
[DEBUG] Registered local 'L' from analyzer metrics.
Added local variable 'S' of type 1 at offset 24 (size 8)
[DEBUG] Registered local 'S' from analyzer metrics.
Added local variable '_forEach_cursor_0' of type 1050624 at offset 32 (size 8)
[DEBUG] Registered local '_forEach_cursor_0' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 80 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|INTEGER
+24      | Local: S                              | INTEGER
+32      | Local: _forEach_cursor_0              | POINTER_TO|LIST
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X26                        | UNKNOWN
+64      | Saved Reg: X27                        | UNKNOWN
+72      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+80 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-80]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #56] ; Saved Reg: X26 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #64] ; Saved Reg: X27 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #72] ; Saved Reg: X28 @ FP+72
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 80 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|INTEGER
+24      | Local: S                              | INTEGER
+32      | Local: _forEach_cursor_0              | POINTER_TO|LIST
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X26                        | UNKNOWN
+64      | Saved Reg: X27                        | UNKNOWN
+72      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+80 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting ListExpression node.
[DEBUG] List is constant. Using static template generation.
[DataGenerator TRACE] add_list_literal called. Generated Key: "list[string(a),string(string),string(list)]"
[DataGenerator TRACE] >> Cache MISS. Generating new labels.
[DEBUG LEVEL 5] Emitting instruction: ADRP X0, L_list0_header
[DEBUG LEVEL 5] Emitting instruction: ADD X0, X0, #:lo12:L_list0_header
[DEBUG LEVEL 5] Emitting instruction: BL DEEPCOPYLITERALLIST
[DEBUG] Emitted deep copy logic for LIST.
[DEBUG] Handling assignment for variable: L
[DEBUG] store_variable_register for 'L' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'L' lives in X15. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0
[DEBUG]   Updating home register X15 for variable 'L' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting UnaryOp node.
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1050625, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X15
[DEBUG] Variable 'L' value loaded into X15
[DEBUG]   [DEBUG] get_variable_register returned: 'X15'
[DEBUG] LEFT side evaluation complete. left_reg = 'X15'
[DEBUG] OPTIMIZATION: Right operand is constant: 16
[DEBUG] Checking type promotion: left_reg=X15, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X15
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #16
[DEBUG] OPTIMIZATION: Generated ADD with immediate: 16
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X9
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #0]
[DEBUG] Handling assignment for variable: _forEach_cursor_0
[DEBUG] store_variable_register for '_forEach_cursor_0' from register 'X10'
[DEBUG]   [ALLOCATOR HIT] Variable '_forEach_cursor_0' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X10
[DEBUG]   Updating home register X26 for variable '_forEach_cursor_0' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X10
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachHeader_1
[DEBUG LEVEL 5] Emitting instruction: B .L0
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting UnaryOp node.
[DEBUG] Generating INLINE code for hybrid static/runtime REST operation.
[DEBUG] Visiting VariableAccess node for '_forEach_cursor_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_forEach_cursor_0' in function 'START'
[DEBUG] get_variable_register for: '_forEach_cursor_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_forEach_cursor_0' lives in register X26
[DEBUG] Variable '_forEach_cursor_0' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] REST operand is statically known as a List Node. Generating direct next-ptr load.
[DEBUG LEVEL 5] Emitting instruction: CMP X26, #0
[DEBUG LEVEL 5] Emitting instruction: B.EQ .L2
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X26, #16]
[DEBUG LEVEL 5] Emitting instruction: B .L1
[DEBUG LEVEL 5] Emitting instruction: MOV X9, XZR
[DEBUG] Handling assignment for variable: _forEach_cursor_0
[DEBUG] store_variable_register for '_forEach_cursor_0' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable '_forEach_cursor_0' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG]   Updating home register X26 for variable '_forEach_cursor_0' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachHeader_1
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting UnaryOp node.
[DEBUG] Generating INLINE code for hybrid static/runtime HD operation.
[DEBUG] Visiting VariableAccess node for '_forEach_cursor_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_forEach_cursor_0' in function 'START'
[DEBUG] get_variable_register for: '_forEach_cursor_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_forEach_cursor_0' lives in register X26
[DEBUG] Variable '_forEach_cursor_0' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] HD operand is statically known as a List Node. Generating direct load.
[DEBUG LEVEL 5] Emitting instruction: CMP X26, #0
[DEBUG LEVEL 5] Emitting instruction: B.EQ .L4
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X26, #8]
[DEBUG LEVEL 5] Emitting instruction: B .L3
[DEBUG LEVEL 5] Emitting instruction: MOV X9, XZR
[DEBUG] Handling assignment for variable: S
[DEBUG] store_variable_register for 'S' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable 'S' lives in X27. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X9
[DEBUG]   Updating home register X27 for variable 'S' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'String: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S' in function 'START'
[DEBUG] get_variable_register for: 'S' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S' lives in register X27
[DEBUG] Variable 'S' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachAdvance_4
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_5
[DEBUG] Visiting ConditionalBranchStatement (codegen is handled by block epilogue).
[DEBUG] Visiting VariableAccess node for '_forEach_cursor_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_forEach_cursor_0' in function 'START'
[DEBUG] get_variable_register for: '_forEach_cursor_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_forEach_cursor_0' lives in register X26
[DEBUG] Variable '_forEach_cursor_0' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: CMP X26, XZR
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_ForEachExit_3
[DEBUG LEVEL 5] Emitting instruction: B START_ForEachBody_2
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str4
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 1
[DataGenerator TRACE] >> Processing header: L_list0_header
[DataGenerator TRACE]   Internal nodes vector size: 3
[DataGenerator TRACE]   --- Dumping Node Labels ---
[DataGenerator TRACE]     -> L_list0_node_0
[DataGenerator TRACE]     -> L_list0_node_1
[DataGenerator TRACE]     -> L_list0_node_2
[DataGenerator TRACE]   --- End Dump ---
[InstructionStream TRACE] Adding label definition: L_list0_header
[InstructionStream TRACE] Adding label definition: L_list0_node_0
[InstructionStream TRACE] Adding label definition: L_list0_node_1
[InstructionStream TRACE] Adding label definition: L_list0_node_2
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, POINTER_TO|LIST|INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'S' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol '_forEach_cursor_0' (LOCAL_VAR, POINTER_TO|LIST, scope=1, block=0, class_name='', function_name='START')

Data sections generated.

=== Peephole Optimization ===
Analyzing 177 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 20
  Before:
    STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40  [Opcode=26, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
    STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48  [Opcode=26, Dest=-1, Src1=20, Imm=48, Base=29, Offset=48]
  After:
    STP x19, x20, [x29, #40]  [Opcode=30, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 21
  Before:
    STR X26, [X29, #56] ; Saved Reg: X26 @ FP+56  [Opcode=26, Dest=-1, Src1=26, Imm=56, Base=29, Offset=56]
    STR X27, [X29, #64] ; Saved Reg: X27 @ FP+64  [Opcode=26, Dest=-1, Src1=27, Imm=64, Base=29, Offset=64]
  After:
    STP x26, x27, [x29, #56]  [Opcode=30, Dest=-1, Src1=26, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 32
  Before:
    MOV X15, X0  [Opcode=1, Dest=15, Src1=0]
    MOV X15, X0  [Opcode=1, Dest=15, Src1=0]
  After:
    MOV X15, X0  [Opcode=1, Dest=15, Src1=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Eliminate load through scratch register (LDR Xs, [..]; MOV Xt, Xs => LDR Xt, [..])
  Position: 35
  Before:
    LDR X10, [X9, #0]  [Opcode=27, Dest=10, Src1=-1, Imm=0, Base=9, Offset=0]
    MOV X26, X10  [Opcode=1, Dest=26, Src1=10]
  After:
    LDR X10, [X9, #0]  [Opcode=27, Dest=26, Src1=-1, Imm=0, Base=9, Offset=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 48
  Before:
    MOV X26, X9  [Opcode=1, Dest=26, Src1=9]
    MOV X26, X9  [Opcode=1, Dest=26, Src1=9]
  After:
    MOV X26, X9  [Opcode=1, Dest=26, Src1=9]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 58
  Before:
    MOV X27, X9  [Opcode=1, Dest=27, Src1=9]
    MOV X27, X9  [Opcode=1, Dest=27, Src1=9]
  After:
    MOV X27, X9  [Opcode=1, Dest=27, Src1=9]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 82
  Before:
    LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40  [Opcode=27, Dest=19, Src1=-1, Imm=40, Base=29, Offset=40]
    LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48  [Opcode=27, Dest=20, Src1=-1, Imm=48, Base=29, Offset=48]
  After:
    LDP x19, x20, [x29, #40]  [Opcode=31, Dest=19, Src1=20, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 83
  Before:
    LDR X26, [X29, #56] ; Restored Reg: X26 @ FP+56  [Opcode=27, Dest=26, Src1=-1, Imm=56, Base=29, Offset=56]
    LDR X27, [X29, #64] ; Restored Reg: X27 @ FP+64  [Opcode=27, Dest=27, Src1=-1, Imm=64, Base=29, Offset=64]
  After:
    LDP x26, x27, [x29, #56]  [Opcode=31, Dest=26, Src1=27, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 86
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [x31]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 177
  Instructions after:  168
  Total optimizations: 9
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 3
    - Eliminate load through scratch register (LDR Xs, [..]; MOV Xt, Xs => LDR Xt, [..]): 1
    - Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn): 3
    - Combine adjacent X-register STRs into STP: 2
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x105c7c000) ---
Address Hex Code    Assembly
--------------------------------------------------
 105c7c000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 105c7c004 0xd28f2310  MOVZ X16, #31000
 105c7c008 0xf2a011d0  MOVK X16, #142, LSL #16
 105c7c00c 0xf2c00030  MOVK X16, #1, LSL #32
 105c7c010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 105c7c014 0xd28f2890  MOVZ X16, #31044
 105c7c018 0xf2a011d0  MOVK X16, #142, LSL #16
 105c7c01c 0xf2c00030  MOVK X16, #1, LSL #32
 105c7c020 0xd61f0200  BR X16
WRITES_veneer:
 105c7c024 0xd28dbb10  MOVZ X16, #28120
 105c7c028 0xf2a01410  MOVK X16, #160, LSL #16
 105c7c02c 0xf2c00030  MOVK X16, #1, LSL #32
 105c7c030 0xd61f0200  BR X16
 105c7c034 0x00000000  ; --- End Veneer Section ---

START:
 105c7c038 0xa9bb7bfd  STP X29, X30, [SP, #-80]!
 105c7c03c 0x910003fd  MOV X29, SP
 105c7c040 0xa902d3b3  STP x19, x20, [x29, #40]
 105c7c044 0xa903efba  STP x26, x27, [x29, #56]
 105c7c048 0xf90027bc  STR X28, [X29, #72] ; Saved Reg: X28 @ FP+72
 105c7c04c 0xd298001c  MOVZ X28, #49152
 105c7c050 0xf2a0b6fc  MOVK X28, #1463, LSL #16
 105c7c054 0xf2c0003c  MOVK X28, #1, LSL #32
 105c7c058 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 105c7c05c 0x97ffffea  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x105c7c004
 105c7c060 0xb0000020  ADRP X0, L_list0_header    ; Reloc -> 'L_list0_header' @ 0x105c810a0
 105c7c064 0x91028000  ADD X0, X0, #:lo12:L_list0_header    ; Reloc -> 'L_list0_header' @ 0x105c810a0
 105c7c068 0x96b648b6  BL DEEPCOPYLITERALLIST    ; Reloc -> 'DEEPCOPYLITERALLIST' @ 0x100a0e340
 105c7c06c 0xaa0003ef  MOV X15, X0
 105c7c070 0xaa0f03e9  MOV X9, X15
 105c7c074 0x91004129  ADD X9, X9, #16
 105c7c078 0xf940012a  LDR X10, [X9, #0]
 105c7c07c 0xaa0a03fa  MOV X26, X10
 105c7c080 0x14000020  B START_ForEachHeader_1    ; Reloc -> 'START_ForEachHeader_1' @ 0x105c7c100
START_Exit_5:
 105c7c084 0x14000022  B .L0    ; Reloc -> '.L0' @ 0x105c7c10c
START_ForEachAdvance_4:
 105c7c088 0xf100035f  CMP X26, #0
 105c7c08c 0x54000060  B.EQ .L2    ; Reloc -> '.L2' @ 0x105c7c098
 105c7c090 0xf9400b49  LDR X9, [X26, #16]
 105c7c094 0x14000002  B .L1    ; Reloc -> '.L1' @ 0x105c7c09c
.L2:
 105c7c098 0xaa1f03e9  MOV X9, XZR
.L1:
 105c7c09c 0xaa0903fa  MOV X26, X9
 105c7c0a0 0x14000018  B START_ForEachHeader_1    ; Reloc -> 'START_ForEachHeader_1' @ 0x105c7c100
START_ForEachBody_2:
 105c7c0a4 0xf100035f  CMP X26, #0
 105c7c0a8 0x54000060  B.EQ .L4    ; Reloc -> '.L4' @ 0x105c7c0b4
 105c7c0ac 0xf9400749  LDR X9, [X26, #8]
 105c7c0b0 0x14000002  B .L3    ; Reloc -> '.L3' @ 0x105c7c0b8
.L4:
 105c7c0b4 0xaa1f03e9  MOV X9, XZR
.L3:
 105c7c0b8 0xaa0903fb  MOV X27, X9
 105c7c0bc 0x97ffffd2  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x105c7c004
 105c7c0c0 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x105c8105c
 105c7c0c4 0x91017129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x105c8105c
 105c7c0c8 0x91002129  ADD X9, X9, #8
 105c7c0cc 0xaa0903e0  MOV X0, X9
 105c7c0d0 0x97ffffd5  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x105c7c024
 105c7c0d4 0xaa1b03e0  MOV X0, X27
 105c7c0d8 0x97ffffd3  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x105c7c024
 105c7c0dc 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x105c8108c
 105c7c0e0 0x91023129  ADD X9, X9, #:lo12:L_str4    ; Reloc -> 'L_str4' @ 0x105c8108c
 105c7c0e4 0x91002129  ADD X9, X9, #8
 105c7c0e8 0xaa0903e0  MOV X0, X9
 105c7c0ec 0x97ffffce  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x105c7c024
 105c7c0f0 0x97ffffc9  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x105c7c014
 105c7c0f4 0x17ffffe5  B START_ForEachAdvance_4    ; Reloc -> 'START_ForEachAdvance_4' @ 0x105c7c088
START_ForEachExit_3:
 105c7c0f8 0x97ffffc7  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x105c7c014
 105c7c0fc 0x17ffffe2  B START_Exit_5    ; Reloc -> 'START_Exit_5' @ 0x105c7c084
START_ForEachHeader_1:
 105c7c100 0xeb1f035f  CMP X26, XZR
 105c7c104 0x54ffffa0  B.EQ START_ForEachExit_3    ; Reloc -> 'START_ForEachExit_3' @ 0x105c7c0f8
 105c7c108 0x17ffffe7  B START_ForEachBody_2    ; Reloc -> 'START_ForEachBody_2' @ 0x105c7c0a4
.L0:
 105c7c10c 0xa942d3b3  LDP x19, x20, [x29, #40]
 105c7c110 0xa943efba  LDP x26, x27, [x29, #56]
 105c7c114 0xf94027bc  LDR X28, [X29, #72] ; Restored Reg: X28 @ FP+72
 105c7c118 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 105c7c11c 0xa9407bfd  LDP x29, x30, [x31]
 105c7c120 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 105c7c124 0xd65f03c0  RET
L_str0:
 105c81000 0x10000000  .quad 0x1
 105c81004 0x00000000  ; (upper half)
 105c81008 0x61000000  DCD 0x61
 105c8100c 0x00000000  DCD 0x0
 105c81010 0x00000000  DCD 0x0
L_str1:
 105c81014 0x60000000  .quad 0x6
 105c81018 0x00000000  ; (upper half)
 105c8101c 0x73000000  DCD 0x73
 105c81020 0x74000000  DCD 0x74
 105c81024 0x72000000  DCD 0x72
 105c81028 0x69000000  DCD 0x69
 105c8102c 0x6e000000  DCD 0x6e
 105c81030 0x67000000  DCD 0x67
 105c81034 0x00000000  DCD 0x0
 105c81038 0x00000000  DCD 0x0
L_str2:
 105c8103c 0x40000000  .quad 0x4
 105c81040 0x00000000  ; (upper half)
 105c81044 0x6c000000  DCD 0x6c
 105c81048 0x69000000  DCD 0x69
 105c8104c 0x73000000  DCD 0x73
 105c81050 0x74000000  DCD 0x74
 105c81054 0x00000000  DCD 0x0
 105c81058 0x00000000  DCD 0x0
L_str3:
 105c8105c 0x80000000  .quad 0x8
 105c81060 0x00000000  ; (upper half)
 105c81064 0x53000000  DCD 0x53
 105c81068 0x74000000  DCD 0x74
 105c8106c 0x72000000  DCD 0x72
 105c81070 0x69000000  DCD 0x69
 105c81074 0x6e000000  DCD 0x6e
 105c81078 0x67000000  DCD 0x67
 105c8107c 0x3a000000  DCD 0x3a
 105c81080 0x20000000  DCD 0x20
 105c81084 0x00000000  DCD 0x0
 105c81088 0x00000000  DCD 0x0
L_str4:
 105c8108c 0x10000000  .quad 0x1
 105c81090 0x00000000  ; (upper half)
 105c81094 0xa0000000  DCD 0xa
 105c81098 0x00000000  DCD 0x0
 105c8109c 0x00000000  DCD 0x0
L_list0_header:
 105c810a0 0x00000000  DCD 0x0
 105c810a4 0x00000000  DCD 0x0
 105c810a8 0x5c810f00  .quad L_list0_node_2    ; Reloc -> 'L_list0_node_2' @ 0x105c810f0
 105c810b0 0x5c810c00  .quad L_list0_node_0    ; Reloc -> 'L_list0_node_0' @ 0x105c810c0
 105c810b8 0x30000000  .quad 0x3
 105c810bc 0x00000000  ; (upper half)
L_list0_node_0:
 105c810c0 0x30000000  DCD 0x3
 105c810c4 0x00000000  DCD 0x0
 105c810c8 0x5c810000  .quad L_str0    ; Reloc -> 'L_str0' @ 0x105c81000
 105c810d0 0x5c810d80  .quad L_list0_node_1    ; Reloc -> 'L_list0_node_1' @ 0x105c810d8
L_list0_node_1:
 105c810d8 0x30000000  DCD 0x3
 105c810dc 0x00000000  DCD 0x0
 105c810e0 0x5c810140  .quad L_str1    ; Reloc -> 'L_str1' @ 0x105c81014
 105c810e8 0x5c810f00  .quad L_list0_node_2    ; Reloc -> 'L_list0_node_2' @ 0x105c810f0
L_list0_node_2:
 105c810f0 0x30000000  DCD 0x3
 105c810f4 0x00000000  DCD 0x0
 105c810f8 0x5c8103c0  .quad L_str2    ; Reloc -> 'L_str2' @ 0x105c8103c
 105c81100 0x00000000  .quad 0x0
 105c81104 0x00000000  ; (upper half)

--------------------------

JIT runtime table populated with 123 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x105c7c038
[JITExecutor] Starting execution of JIT-compiled function at address: 0x105c7c038
SAMM: Entered scope (depth: 2)
SAMM: Tracked freelist allocation 0x1017951b0 in scope (depth: 2, scope size: 1)
SAMM: Tracked list allocation 0x1017951b0 in scope (depth: 2, scope size: 2)
BCPL String Optimizations: Initialized (pool + SIMD)
SAMM: Tracked string pool allocation 0xb8ece37dc in scope (depth: 2, scope size: 3)
SAMM: Tracked string pool allocation 0xb8ece37a0 in scope (depth: 2, scope size: 4)
SAMM: Tracked string pool allocation 0xb8ece3764 in scope (depth: 2, scope size: 5)
SAMM: Entered scope (depth: 3)
String: 
SAMM: Scope exit - found 0 objects to cleanup (remaining depth: 2)
SAMM: No objects to cleanup in this scope
SAMM: Entered scope (depth: 3)
String: 
SAMM: Scope exit - found 0 objects to cleanup (remaining depth: 2)
SAMM: No objects to cleanup in this scope
SAMM: Entered scope (depth: 3)
String: 
SAMM: Scope exit - found 0 objects to cleanup (remaining depth: 2)
SAMM: No objects to cleanup in this scope
SAMM: Scope exit - found 5 objects to cleanup (remaining depth: 1)
SAMM: About to queue 5 objects for cleanup
SAMM: Queued objects for background cleanup (queue depth: 1)
SAMM: Notified background worker
JIT Execution completed with result: 4433887088
  Same value as double: SAMM: Worker woke up, queue size: 1, running: YES
SAMM: Processing batch of 5 objects
SAMM: cleanupPointersImmediate called with 5 pointers
SAMM: Cleaning up pointer 0x1017951b0
SAMM: Freeing list header 0x1017951b0 and returning all atoms to freelist
2.19063e-314
[JITExecutor] Execution completed. Result: 4433887088
SAMM: Successfully cleaned pointer 0x1017951b0
SAMM: Cleaning up pointer 0x1017951b0
SAMM: Ignoring free() for 0x1017951b0 - already freed by SAMM
SAMM: Successfully cleaned pointer 0x1017951b0
SAMM: Cleaning up pointer 0xb8ece37dc

--- JIT returned with result: 4433887088 ---
SAMM: Returning string pool allocation 0xb8ece37dc to pool for reuse
SAMM: Successfully cleaned pointer 0xb8ece37dc
SAMM: Cleaning up pointer 0xb8ece37a0
SAMM: Returning string pool allocation 0xb8ece37a0 to pool for reuse
SAMM: Successfully cleaned pointer 0xb8ece37a0
SAMM: Cleaning up pointer 0xb8ece3764
SAMM: Returning string pool allocation 0xb8ece3764 to pool for reuse
SAMM: Successfully cleaned pointer 0xb8ece3764
SAMM: cleanupPointersImmediate completed 5 items in 0.015 ms
SAMM: Background worker processed batch of 5 objects
SAMM: Worker waiting for cleanup queue (queue size: 0)

--- BCPL Runtime Metrics ---
Memory allocations: 0 (0 bytes)
Memory frees: 0 (0 bytes)
Vector allocations: 0
String allocations: 0
Double-free attempts: 0
Current active allocations: 0 (0 bytes)
Bloom filter statistics:
  Items tracked: 0
  Memory usage: 12000000 bytes
  False positives: 0
  Est. false positive rate: 0.0000%
File I/O operations:
  Files opened: 0
  Files closed: 0
  Bytes read: 0
  Bytes written: 0
  Open files: 0
--------------------------
SAMM: Processed all pending cleanup operations
SAMM: Worker woke up, queue size: 0, running: NO
SAMM: Background cleanup worker thread stopped (DEBUG)
SAMM: Background worker stopped
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: Shutdown complete
