NeonReducerRegistry: Registered 13 NEON reduction encoders
Found source file: test_split_join_simple.bcl
Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=test_split_join_simple.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.2429
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/test_split_join_simple.bcl"
LET START() BE
$(
   WRITES("Testing SPLIT->JOIN round-trip...*N")

   LET S1 = "hello world test"
   WRITES("Original string: ")
   WRITES(S1)
   WRITES("*N")

   WRITES("Calling SPLIT...*N")
   LET L = SPLIT(S1, " ")
   WRITES("SPLIT completed*N")

   TEST L = 0 THEN
   $(
       WRITES("ERROR: SPLIT returned null*N")
   $)
   ELSE
   $(
       WRITES("SPLIT returned a list, now calling JOIN...*N")
       LET S2 = JOIN(L, "-")
       WRITES("JOIN completed*N")

       TEST S2 = 0 THEN
       $(
           WRITES("ERROR: JOIN returned null*N")
       $)
       ELSE
       $(
           WRITES("JOIN result: ")
           WRITES(S2)
           WRITES("*N")
       $)
   $)
$)

Using BCPL Runtime v1.0.0
Parsing complete. AST built.
=== Importing Runtime Functions from Manifest ===
API Version: 1.0.0
Found 125 functions in manifest
Runtime: WRITES               -> 0x102a55400
Symbol:  WRITES               (Write a string to standard output)
Runtime: WRITEN               -> 0x102a56294
Symbol:  WRITEN               (Write an integer to standard output)
Runtime: FWRITE               -> 0x102a5595c
Symbol:  FWRITE               (Write a float to standard output)
Runtime: WRITEF               -> 0x102a559a0
Symbol:  WRITEF               (Write formatted output (base case))
Runtime: WRITEF1              -> 0x102a55ec0
Symbol:  WRITEF1              (Write formatted output with 1 argument)
Runtime: WRITEF2              -> 0x102a55f28
Symbol:  WRITEF2              (Write formatted output with 2 arguments)
Runtime: WRITEF3              -> 0x102a55f9c
Symbol:  WRITEF3              (Write formatted output with 3 arguments)
Runtime: WRITEF4              -> 0x102a5601c
Symbol:  WRITEF4              (Write formatted output with 4 arguments)
Runtime: WRITEF5              -> 0x102a560a8
Symbol:  WRITEF5              (Write formatted output with 5 arguments)
Runtime: WRITEF6              -> 0x102a56140
Symbol:  WRITEF6              (Write formatted output with 6 arguments)
Runtime: WRITEF7              -> 0x102a561e4
Symbol:  WRITEF7              (Write formatted output with 7 arguments)
Runtime: WRITEC               -> 0x102a562d8
Symbol:  WRITEC               (Write a character to standard output)
Runtime: RDCH                 -> 0x102a5649c
Symbol:  RDCH                 (Read a character from standard input)
Runtime: NEWLINE              -> 0x102a57738
Symbol:  NEWLINE              (Output a newline character)
Runtime: SPLIT                -> 0x102a58c4c
Symbol:  SPLIT                (Split a string into a list using delimiter)
Runtime: JOIN                 -> 0x102a58c20
Symbol:  JOIN                 (Join a list of strings using delimiter)
Runtime: STRLEN               -> 0x102a564f8
Symbol:  STRLEN               (Get length of a string)
Runtime: STRCMP               -> 0x102a56558
Symbol:  STRCMP               (Compare two strings)
Runtime: STRCOPY              -> 0x102a5663c
Symbol:  STRCOPY              (Copy one string to another)
Runtime: PACKSTRING           -> 0x102a568f0
Symbol:  PACKSTRING           (Pack a string into memory)
Runtime: UNPACKSTRING         -> 0x102a56c28
Symbol:  UNPACKSTRING         (Unpack a string from memory)
Runtime: SLURP                -> 0x102a56fc0
Symbol:  SLURP                (Read entire file into string)
Runtime: SPIT                 -> 0x102a574ec
Symbol:  SPIT                 (Write string to file)
Runtime: GETVEC               -> 0x102a58ac8
Symbol:  GETVEC               (Allocate integer vector)
Runtime: FGETVEC              -> 0x102a58afc
Symbol:  FGETVEC              (Allocate float vector)
Runtime: FREEVEC              -> 0x102a58a04
Symbol:  FREEVEC              (Free allocated vector)
Runtime: BCPL_ALLOC_WORDS     -> 0x102a5894c
Symbol:  BCPL_ALLOC_WORDS     (Allocate words with type info)
Runtime: BCPL_ALLOC_CHARS     -> 0x102a589ac
Symbol:  BCPL_ALLOC_CHARS     (Allocate character buffer)
Runtime: MALLOC               -> 0x102a5894c
Symbol:  MALLOC               (Allocate memory (alias for BCPL_ALLOC_WORDS))
Runtime: BCPL_FREE_LIST       -> 0x102a5d4f0
Symbol:  BCPL_FREE_LIST       (Free a list structure)
Runtime: BCPL_FREE_LIST_SAFE  -> 0x102a5d5f8
Symbol:  BCPL_FREE_LIST_SAFE  (Safely free a list structure)
Runtime: BCPL_GET_LAST_ERROR  -> 0x102a544c0
Symbol:  BCPL_GET_LAST_ERROR  (Get last error message)
Runtime: BCPL_CLEAR_ERRORS    -> 0x102a54570
Symbol:  BCPL_CLEAR_ERRORS    (Clear error state)
Runtime: BCPL_CHECK_AND_DISPLAY_ERRORS -> 0x102a5d864
Symbol:  BCPL_CHECK_AND_DISPLAY_ERRORS (Check and display any errors)
Runtime: BCPL_BOUNDS_ERROR    -> 0x102a54640
Symbol:  BCPL_BOUNDS_ERROR    (Report bounds checking error)
Runtime: BCPL_FREE_CELLS      -> 0x102a5d80c
Symbol:  BCPL_FREE_CELLS      (Free memory cells)
Runtime: GET_FREE_LIST_HEAD_ADDR -> 0x102a5d810
Symbol:  GET_FREE_LIST_HEAD_ADDR (Get address of free list head)
Runtime: LIST_CREATE          -> 0x102a5c608
Symbol:  LIST_CREATE          (Create empty list)
Runtime: LIST_APPEND_INT      -> 0x102a5c668
Symbol:  LIST_APPEND_INT      (Append integer to list)
Runtime: LIST_APPEND_FLOAT    -> 0x102a5c738
Symbol:  LIST_APPEND_FLOAT    (Append float to list)
Runtime: LIST_APPEND_STRING   -> 0x102a5c808
Symbol:  LIST_APPEND_STRING   (Append string to list)
Runtime: LIST_HEAD_INT        -> 0x102a5ca78
Symbol:  LIST_HEAD_INT        (Get first element of list as integer)
Runtime: LIST_HEAD_FLOAT      -> 0x102a5cadc
Symbol:  LIST_HEAD_FLOAT      (Get first element of list as float)
Runtime: LIST_TAIL            -> 0x102a5cb44
Symbol:  LIST_TAIL            (Get tail (rest) of list)
Runtime: LIST_FREE            -> 0x102a5d4f0
Symbol:  LIST_FREE            (Free a list and all its elements)
Runtime: BCPL_LIST_APPEND_LIST -> 0x102a5c8d8
Symbol:  BCPL_LIST_APPEND_LIST (Append list to another list)
Runtime: BCPL_LIST_GET_REST   -> 0x102a5cb94
Symbol:  BCPL_LIST_GET_REST   (Get rest of list (alias for tail))
Runtime: BCPL_GET_ATOM_TYPE   -> 0x102a5cbf8
Symbol:  BCPL_GET_ATOM_TYPE   (Get type of atomic value)
Runtime: BCPL_LIST_GET_NTH    -> 0x102a5cc60
Symbol:  BCPL_LIST_GET_NTH    (Get nth element of list)
Runtime: BCPL_CONCAT_LISTS    -> 0x102a5d164
Symbol:  BCPL_CONCAT_LISTS    (Concatenate two lists)
Runtime: CONCAT               -> 0x102a5d164
Symbol:  CONCAT               (Concatenate two lists (alias))
Runtime: COPYLIST             -> 0x102a5cd2c
Symbol:  COPYLIST             (Create shallow copy of list)
Runtime: DEEPCOPYLIST         -> 0x102a5ce2c
Symbol:  DEEPCOPYLIST         (Create deep copy of list)
Runtime: DEEPCOPYLITERALLIST  -> 0x102a5cfc4
Symbol:  DEEPCOPYLITERALLIST  (Create deep copy of literal list)
Runtime: REVERSE              -> 0x102a5d264
Symbol:  REVERSE              (Reverse a list)
Runtime: FIND                 -> 0x102a5d34c
Symbol:  FIND                 (Find element in list)
Runtime: FILTER               -> 0x102a5d440
Symbol:  FILTER               (Filter list elements)
Runtime: APND                 -> 0x102a5c668
Symbol:  APND                 (Append integer to list (alias))
Runtime: FPND                 -> 0x102a5c738
Symbol:  FPND                 (Append float to list (alias))
Runtime: SPND                 -> 0x102a5c808
Symbol:  SPND                 (Append string to list (alias))
Runtime: LPND                 -> 0x102a5c8d8
Symbol:  LPND                 (Append list to list (alias))
Runtime: returnNodeToFreelist -> 0x102a5d81c
Symbol:  returnNodeToFreelist (Return node to freelist)
Runtime: RAND                 -> 0x102a566e8
Symbol:  RAND                 (Generate random integer (0 to max_val-1))
Runtime: RND                  -> 0x102a567c8
Symbol:  RND                  (Generate random float (0.0 to max_val))
Runtime: FRND                 -> 0x102a56774
Symbol:  FRND                 (Generate random float (0.0 to 1.0))
Runtime: FSIN                 -> 0x102a5685c
Symbol:  FSIN                 (Sine function (radians))
Runtime: FCOS                 -> 0x102a56870
Symbol:  FCOS                 (Cosine function (radians))
Runtime: FTAN                 -> 0x102a56884
Symbol:  FTAN                 (Tangent function (radians))
Runtime: FABS                 -> 0x102a56898
Symbol:  FABS                 (Absolute value (float))
Runtime: FLOG                 -> 0x102a568b0
Symbol:  FLOG                 (Natural logarithm)
Runtime: FEXP                 -> 0x102a568c4
Symbol:  FEXP                 (Exponential function)
Runtime: FIX                  -> 0x102a568d8
Symbol:  FIX                  (Convert float to integer)
Runtime: FILE_OPEN_READ       -> 0x102a58c78
Symbol:  FILE_OPEN_READ       (Open file for reading)
Runtime: FILE_OPEN_WRITE      -> 0x102a58ff8
Symbol:  FILE_OPEN_WRITE      (Open file for writing)
Runtime: FILE_OPEN_APPEND     -> 0x102a59088
Symbol:  FILE_OPEN_APPEND     (Open file for appending)
Runtime: FILE_CLOSE           -> 0x102a59118
Symbol:  FILE_CLOSE           (Close file handle)
Runtime: FILE_WRITES          -> 0x102a59184
Symbol:  FILE_WRITES          (Write string to file)
Runtime: FILE_READS           -> 0x102a59460
Symbol:  FILE_READS           (Read string from file)
Runtime: FILE_READ            -> 0x102a59900
Symbol:  FILE_READ            (Read bytes from file)
Runtime: FILE_WRITE           -> 0x102a59a14
Symbol:  FILE_WRITE           (Write bytes to file)
Runtime: FILE_SEEK            -> 0x102a59b2c
Symbol:  FILE_SEEK            (Seek to position in file)
Runtime: FILE_TELL            -> 0x102a59bf0
Symbol:  FILE_TELL            (Get current position in file)
Runtime: FILE_EOF             -> 0x102a59c48
Symbol:  FILE_EOF             (Check if at end of file)
Runtime: FINISH               -> 0x102a564e8
Symbol:  FINISH               (Terminate program execution)
Runtime: SETTYPE              -> 0x0
Symbol:  SETTYPE              (Set type information (compiler intrinsic))
Runtime: HeapManager_enter_scope -> 0x102a18f68
Symbol:  HeapManager_enter_scope (Enter new memory management scope)
Runtime: HeapManager_exit_scope -> 0x102a18f94
Symbol:  HeapManager_exit_scope (Exit current memory management scope)
Runtime: HEAPMANAGER_ISSAMMENABLED -> 0x102a18f44
Symbol:  HEAPMANAGER_ISSAMMENABLED (Check if SAMM (Scope Aware Memory Management) is enabled)
Runtime: HEAPMANAGER_SETSAMMENABLED -> 0x102a18f14
Symbol:  HEAPMANAGER_SETSAMMENABLED (Enable or disable SAMM)
Runtime: HEAPMANAGER_WAITFORSAMM -> 0x102a19030
Symbol:  HEAPMANAGER_WAITFORSAMM (Wait for SAMM operations to complete)
Runtime: OBJECT_HEAP_ALLOC    -> 0x102a58b50
Symbol:  OBJECT_HEAP_ALLOC    (Allocate object on heap)
Runtime: OBJECT_HEAP_FREE     -> 0x102a58b74
Symbol:  OBJECT_HEAP_FREE     (Free object from heap)
Runtime: RUNTIME_METHOD_LOOKUP -> 0x102a58b98
Symbol:  RUNTIME_METHOD_LOOKUP (Look up method at runtime)
Runtime: PIC_RUNTIME_HELPER   -> 0x102a58bb0
Symbol:  PIC_RUNTIME_HELPER   (Polymorphic inline cache helper)
Runtime: SDL2_INIT            -> 0x102a5dad8
Symbol:  SDL2_INIT            (Initialize SDL2 video subsystem)
Runtime: SDL2_INIT_SUBSYSTEMS -> 0x102a5dc1c
Symbol:  SDL2_INIT_SUBSYSTEMS (Initialize specific SDL2 subsystems)
Runtime: SDL2_QUIT            -> 0x102a5dfb8
Symbol:  SDL2_QUIT            (Quit SDL2 and cleanup all resources)
Runtime: SDL2_CREATE_WINDOW   -> 0x102a5dfcc
Symbol:  SDL2_CREATE_WINDOW   (Create a 640x480 window with default settings)
Runtime: SDL2_CREATE_WINDOW_EX -> 0x102a5e004
Symbol:  SDL2_CREATE_WINDOW_EX (Create a window with custom properties)
Runtime: SDL2_DESTROY_WINDOW  -> 0x102a5e2a4
Symbol:  SDL2_DESTROY_WINDOW  (Destroy a window and free its resources)
Runtime: SDL2_SET_WINDOW_TITLE -> 0x102a5e3fc
Symbol:  SDL2_SET_WINDOW_TITLE (Change a window's title)
Runtime: SDL2_SET_WINDOW_SIZE -> 0x102a5e4d0
Symbol:  SDL2_SET_WINDOW_SIZE (Resize a window)
Runtime: SDL2_CREATE_RENDERER -> 0x102a5e564
Symbol:  SDL2_CREATE_RENDERER (Create a renderer for a window with default settings)
Runtime: SDL2_CREATE_RENDERER_EX -> 0x102a5e58c
Symbol:  SDL2_CREATE_RENDERER_EX (Create a renderer with custom flags)
Runtime: SDL2_DESTROY_RENDERER -> 0x102a5e760
Symbol:  SDL2_DESTROY_RENDERER (Destroy a renderer and free its resources)
Runtime: SDL2_SET_DRAW_COLOR  -> 0x102a5e8b8
Symbol:  SDL2_SET_DRAW_COLOR  (Set the color for drawing operations)
Runtime: SDL2_CLEAR           -> 0x102a5e964
Symbol:  SDL2_CLEAR           (Clear the screen with current draw color)
Runtime: SDL2_PRESENT         -> 0x102a5e9dc
Symbol:  SDL2_PRESENT         (Display the rendered frame (swap buffers))
Runtime: SDL2_DRAW_POINT      -> 0x102a5ea54
Symbol:  SDL2_DRAW_POINT      (Draw a single point)
Runtime: SDL2_DRAW_LINE       -> 0x102a5eae8
Symbol:  SDL2_DRAW_LINE       (Draw a line between two points)
Runtime: SDL2_DRAW_RECT       -> 0x102a5eb94
Symbol:  SDL2_DRAW_RECT       (Draw a rectangle outline)
Runtime: SDL2_FILL_RECT       -> 0x102a5ec4c
Symbol:  SDL2_FILL_RECT       (Draw a filled rectangle)
Runtime: SDL2_POLL_EVENT      -> 0x102a5ed04
Symbol:  SDL2_POLL_EVENT      (Check for pending events)
Runtime: SDL2_GET_EVENT_KEY   -> 0x102a5ed60
Symbol:  SDL2_GET_EVENT_KEY   (Get the key code from the last keyboard event)
Runtime: SDL2_GET_EVENT_MOUSE -> 0x102a5edc4
Symbol:  SDL2_GET_EVENT_MOUSE (Get mouse coordinates from the last mouse event)
Runtime: SDL2_GET_EVENT_BUTTON -> 0x102a5eeb4
Symbol:  SDL2_GET_EVENT_BUTTON (Get the mouse button from the last mouse button event)
Runtime: SDL2_DELAY           -> 0x102a5ef18
Symbol:  SDL2_DELAY           (Pause execution for specified time)
Runtime: SDL2_GET_TICKS       -> 0x102a5ef54
Symbol:  SDL2_GET_TICKS       (Get milliseconds since SDL initialization)
Runtime: SDL2_GET_ERROR       -> 0x102a5ef70
Symbol:  SDL2_GET_ERROR       (Get the last SDL error message)
Runtime: SDL2_CLEAR_ERROR     -> 0x102a5f0cc
Symbol:  SDL2_CLEAR_ERROR     (Clear the SDL error state)
Runtime: SDL2_GET_VERSION     -> 0x102a5f0e0
Symbol:  SDL2_GET_VERSION     (Get SDL2 version information)
Runtime: SDL2_GET_VIDEO_DRIVERS -> 0x102a5f12c
Symbol:  SDL2_GET_VIDEO_DRIVERS (Get list of available video drivers)
Runtime: SDL2_GET_CURRENT_VIDEO_DRIVER -> 0x102a5f148
Symbol:  SDL2_GET_CURRENT_VIDEO_DRIVER (Get the name of the current video driver)
Runtime: SDL2_GET_DISPLAY_MODES -> 0x102a5f19c
Symbol:  SDL2_GET_DISPLAY_MODES (Get information about available display modes)
Runtime: SDL2_TEST_BASIC      -> 0x102a5f210
Symbol:  SDL2_TEST_BASIC      (Test basic SDL2 functionality)
=== Import Results ===
Runtime registrations: 125/125
Symbol registrations:  125/125
=== Runtime Function Import COMPLETED ===

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: S1 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: L as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing FunctionCall
[SymbolDiscoveryPass] Processing test statement
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: S2 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing FunctionCall
[SymbolDiscoveryPass] Processing test statement
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Entering block scope

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF1' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF2' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF3' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF4' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF5' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF6' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF7' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEC' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RDCH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPLIT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'JOIN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'STRLEN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'STRCMP' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'STRCOPY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'PACKSTRING' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'UNPACKSTRING' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SLURP' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'GETVEC' (RUNTIME_FUNCTION, POINTER_TO|VEC|INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FGETVEC' (RUNTIME_FUNCTION, POINTER_TO|VEC|FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FREEVEC' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_ALLOC_WORDS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_ALLOC_CHARS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'MALLOC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_FREE_LIST' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_FREE_LIST_SAFE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_GET_LAST_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_CLEAR_ERRORS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_CHECK_AND_DISPLAY_ERRORS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_BOUNDS_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_FREE_CELLS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'GET_FREE_LIST_HEAD_ADDR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_CREATE' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_APPEND_INT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_APPEND_FLOAT' (RUNTIME_FLOAT_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_APPEND_STRING' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_HEAD_INT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_HEAD_FLOAT' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_TAIL' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_FREE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_LIST_APPEND_LIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_LIST_GET_REST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_GET_ATOM_TYPE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_LIST_GET_NTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_CONCAT_LISTS' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'CONCAT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'COPYLIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'DEEPCOPYLIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'DEEPCOPYLITERALLIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'REVERSE' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FIND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILTER' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'APND' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FPND' (RUNTIME_FLOAT_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPND' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LPND' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'returnNodeToFreelist' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FIX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FINISH' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SETTYPE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_enter_scope' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HEAPMANAGER_ISSAMMENABLED' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HEAPMANAGER_SETSAMMENABLED' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HEAPMANAGER_WAITFORSAMM' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'OBJECT_HEAP_ALLOC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'OBJECT_HEAP_FREE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RUNTIME_METHOD_LOOKUP' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'PIC_RUNTIME_HELPER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'S1' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'S2' (LOCAL_VAR, INTEGER, scope=3, block=0, class_name='', function_name='START')

================================================

Verifying runtime function import...
=== Verifying Runtime Function Import Completeness ===
✅ Runtime function import verification passed (125 functions)
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 9 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2210
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2450
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2540
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2620
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2700
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 52
[ANALYZER TRACE]   Detected call to runtime function: SPLIT, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb29c0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 56
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Entering block scope: START_block_0_block_2 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2ac0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Entering block scope: START_block_0_block_2 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 4 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb2b50
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE]   Detected call to runtime function: JOIN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb31e0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 56
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] Entering block scope: START_block_0_block_2_block_3 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb3290
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0_block_2
[ANALYZER TRACE] Entering block scope: START_block_0_block_2_block_3 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 3 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb3320
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb33f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x103bb3430
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0_block_2
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 1
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 1
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 15
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Tracking variable 'S1' in current block
[CFGBuilderPass] Tracking variable 'L' in current block
[CFGBuilderPass] visit(TestStatement) entered.
[CFGBuilderPass] Created new basic block: START_Then_1
[CFGBuilderPass] Created new basic block: START_Else_2
[CFGBuilderPass] Created new basic block: START_Join_3
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 2 variable tracking
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 3 variable tracking
[CFGBuilderPass] Tracking variable 'S2' in current block
[CFGBuilderPass] visit(TestStatement) entered.
[CFGBuilderPass] Created new basic block: START_Then_4
[CFGBuilderPass] Created new basic block: START_Else_5
[CFGBuilderPass] Created new basic block: START_Join_6
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 4 variable tracking
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 5 variable tracking
[CFGBuilderPass] visit(TestStatement) exiting.
[CFGBuilderPass] visit(TestStatement) exiting.
[CFGBuilderPass] Created new basic block: START_Exit_7
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]     Found jump-only block: START_Join_3 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Then_1 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Join_6 -> START_Exit_7
[CFGSimplificationPass]     Eliminated block: START_Join_3
[CFGSimplificationPass]     Found jump-only block: START_Join_6 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Then_4 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Else_5 -> START_Exit_7
[CFGSimplificationPass]     Eliminated block: START_Join_6
[CFGSimplificationPass]     Removing unreachable block: START_Join_3
[CFGSimplificationPass]     Removing unreachable block: START_Join_6
[CFGSimplificationPass]   Iteration 2
[CFGSimplificationPass]   Simplification completed after 2 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 2
  Edges redirected: 4
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 6 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_7) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_7
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_7 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_7
[LivenessAnalysisPass] Analyzing block #2 (id=START_Else_5) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Else_5
[LivenessAnalysisPass] Starting intra-block analysis for START_Else_5 with 3 statements
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S2
[LivenessAnalysisPass] Reverse scan - Statement 1 uses variables: S2 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S2 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 1
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Else_5 - variables live across calls: S2 
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Else_5
[LivenessAnalysisPass] Analyzing block #3 (id=START_Then_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Then_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Then_1 with 1 statements
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Then_1 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Then_1
[LivenessAnalysisPass] Analyzing block #4 (id=START_Then_4) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Then_4
[LivenessAnalysisPass] Starting intra-block analysis for START_Then_4 with 1 statements
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Then_4 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Then_4
[LivenessAnalysisPass] Analyzing block #5 (id=START_Else_2) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Else_2
[LivenessAnalysisPass] Starting intra-block analysis for START_Else_2 with 4 statements
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 13TestStatement
[LivenessAnalysisPass] Reverse scan - Statement 3 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 12FunctionCall
[LivenessAnalysisPass] Found FunctionCall with 2 arguments
[LivenessAnalysisPass] Function name: JOIN
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: L
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 1 uses variables: L 
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: L 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 1
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Else_2 - variables live across calls: L 
[LivenessAnalysisPass] Block START_Else_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_2 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Else_2
[LivenessAnalysisPass] Analyzing block #6 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 9 statements
[LivenessAnalysisPass] Reverse scan - processing statement 8 type: 13TestStatement
[LivenessAnalysisPass] Reverse scan - Statement 8 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 8 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 7 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 7 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 7 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 7
[LivenessAnalysisPass] Reverse scan - processing statement 6 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 12FunctionCall
[LivenessAnalysisPass] Found FunctionCall with 2 arguments
[LivenessAnalysisPass] Function name: SPLIT
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S1
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 6 uses variables: S1 
[LivenessAnalysisPass] Reverse scan - Statement 6 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S1 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 6
[LivenessAnalysisPass] Reverse scan - processing statement 5 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 5 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 5 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 5
[LivenessAnalysisPass] Reverse scan - processing statement 4 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 4 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 4 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 4
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S1
[LivenessAnalysisPass] Reverse scan - Statement 3 uses variables: S1 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S1 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 3
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 1 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: NO
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Entry_0 - variables live across calls: S1 
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_7 in function: START
[LivenessAnalysisPass] Processing block: START_Then_1 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_1 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Then_4 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_4 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Else_5 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_5 - adding 0 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Else_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_2 - adding 1 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_7 in function: START
[LivenessAnalysisPass] Processing block: START_Then_1 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_1 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Then_4 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_4 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Else_5 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_5 - adding 0 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Else_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_2 - adding 1 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_7
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Else_5
  Use: { S2 }
  Def: { }
  In : { S2 }
  Out: { }
Block ID: START_Then_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Then_4
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Else_2
  Use: { L }
  Def: { S2 }
  In : { L S2 }
  Out: { S2 }
Block ID: START_Entry_0
  Use: { S1 }
  Def: { L S1 }
  In : { L S1 S2 }
  Out: { L S2 }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_7 (conceptual)

Block ID: START_Exit_7 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Then_1, START_Then_4, START_Else_5

Block ID: START_Else_5
  Statements:
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Else_2

Block ID: START_Then_1
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Entry_0

Block ID: START_Then_4
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Else_2

Block ID: START_Else_2
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - TestStmt
  Successors: START_Then_4, START_Else_5
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - TestStmt
  Successors: START_Then_1, START_Else_2
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[LiveIntervalPass] Created 3 intervals for function: START
  L: [0-11]
  S1: [0-6]
  S2: [0-16]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 9, float registers: 8
[Allocator] Function has 15 call sites at: 0 4 8 12 16 20 25 29 33 37 42 46 50 54 58 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 0, Reserved scratch INT: 0
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 0
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing L [0-11]
  Assigned callee-saved register X27 to L
[ALLOC] Updated allocations for L: spilled=0, register='X27'
[Allocator] Allocating call-crossing S1 [0-6]
  Assigned callee-saved register X26 to S1
[ALLOC] Updated allocations for S1: spilled=0, register='X26'
[Allocator] Allocating call-crossing S2 [0-16]
  Assigned callee-saved register X25 to S2
[ALLOC] Updated allocations for S2: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 0 scratch registers for code generation: 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 6
  Free float registers: 8
  ✓ No register conflicts detected
[Allocator] Results:
  L: reg X27 (callee-saved) [call-crossing]
  S1: reg X26 (callee-saved) [call-crossing]
  S2: reg X25 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 15
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 3
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4428759040
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 3 unique external functions:
[DEBUG]   - JOIN
[DEBUG]   - SPLIT
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] Generating 5 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: JOIN_veneer for function: JOIN
[VeneerManager] Created veneer: SPLIT_veneer for function: SPLIT
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 5 veneers, estimated total size: 100 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Caching live intervals for function: START
[SYNC] Found 3 variable allocations
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 3
[DEBUG] DEBUG: variable_types['L'] = POINTER_TO|LIST|STRING
[DEBUG] DEBUG: variable_types['S1'] = POINTER_TO|STRING
[DEBUG] DEBUG: variable_types['S2'] = INTEGER
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'L' of type 1081348 at offset 16 (size 8)
[DEBUG] Registered local 'L' from analyzer metrics.
Added local variable 'S1' of type 1048580 at offset 24 (size 8)
[DEBUG] Registered local 'S1' from analyzer metrics.
Added local variable 'S2' of type 1 at offset 32 (size 8)
[DEBUG] Registered local 'S2' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S1                             | POINTER_TO|STRING
+32      | Local: S2                             | INTEGER
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[LIVE] Updating live intervals at instruction point -1
[LIVE] Freed register X25 (no active variables)
[LIVE] Freed register X27 (no active variables)
[LIVE] Freed register X26 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
[LIVE] Updating live intervals at instruction point -1
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S1                             | POINTER_TO|STRING
+32      | Local: S2                             | INTEGER
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0_plus_8
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Testing SPLIT->JOIN round-trip...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1_plus_8
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'hello world test'.
[DEBUG] Registering canonical address: S1 = STRING_LITERAL:"hello world test"
[DEBUG] Registered canonical address: S1 = STRING_LITERAL:"hello world test"
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: S1
[DEBUG] store_variable_register for 'S1' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable 'S1' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X26 for variable 'S1' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X26, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2_plus_8
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Original string: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S1' in function 'START'
[DEBUG] get_variable_register for: 'S1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S1' lives in register X26
[DEBUG] Variable 'S1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X26 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X26
[DEBUG] Deferring release of source register: X26
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X26
[DEBUG] Releasing source register: X26
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3_plus_8
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4_plus_8
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Calling SPLIT...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'S1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S1' in function 'START'
[DEBUG] get_variable_register for: 'S1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S1' lives in register X26
[DEBUG] Variable 'S1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X26
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str5
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str5_plus_8
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal ' '.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Found function symbol: SPLIT with 0 parameters
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X20 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Arg 1: src=X20 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X1, X20
[DEBUG] Releasing source register: X20
[DEBUG] Releasing source register: X20
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL SPLIT_veneer
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Handling assignment for variable: L
[DEBUG] store_variable_register for 'L' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'L' lives in X27. Emitting MOV.
[DEBUG]   [LOOP VAR PROTECTION] Extra protection for loop variable: L
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X27 for variable 'L' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X27, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X10 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X10, L_str6
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X26 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: ADD X10, X10, #:lo12:L_str6_plus_8
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'SPLIT completed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X10 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X10
[DEBUG] Deferring release of source register: X10
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X10
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X10
[DEBUG] Releasing source register: X10
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting TestStatement node (NOTE: branching is handled by block epilogue).
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1081348, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X27
[DEBUG] Variable 'L' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] LEFT side evaluation complete. left_reg = 'X27'
[DEBUG] OPTIMIZATION: Right operand is constant: 0
[DEBUG] Checking type promotion: left_reg=X27, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X27
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: CMP X9, #0
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: CSET X10, EQ
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X10
[DEBUG LEVEL 5] Emitting instruction: CMP X10, XZR
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_Else_2
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B START_Then_1
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str7
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str7_plus_8
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'SPLIT returned a list, now calling JOIN...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X27
[DEBUG] Variable 'L' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X27
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str8
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str8_plus_8
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '-'.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Found function symbol: JOIN with 0 parameters
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X20 expr_type=POINTER_TO|LIST|STRING expected=UNKNOWN target=POINTER_TO|LIST|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Arg 1: src=X20 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X1, X20
[DEBUG] Releasing source register: X20
[DEBUG] Releasing source register: X20
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL JOIN_veneer
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Handling assignment for variable: S2
[DEBUG] store_variable_register for 'S2' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'S2' lives in X25. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X0
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X25 for variable 'S2' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X25, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X10 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X10, L_str9
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X10, X10, #:lo12:L_str9_plus_8
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'JOIN completed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X10 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X10
[DEBUG] Deferring release of source register: X10
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X10
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X10
[DEBUG] Releasing source register: X10
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting TestStatement node (NOTE: branching is handled by block epilogue).
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'S2'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S2' in function 'START'
[DEBUG] get_variable_register for: 'S2' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S2' lives in register X25
[DEBUG] Variable 'S2' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] LEFT side evaluation complete. left_reg = 'X25'
[DEBUG] OPTIMIZATION: Right operand is constant: 0
[DEBUG] Checking type promotion: left_reg=X25, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X25
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X27 (no active variables)
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: CMP X9, #0
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: CSET X10, EQ
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X10
[DEBUG LEVEL 5] Emitting instruction: CMP X10, XZR
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_Else_5
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B START_Then_4
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10_plus_8
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'JOIN result: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S2'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S2' in function 'START'
[DEBUG] get_variable_register for: 'S2' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S2' lives in register X25
[DEBUG] Variable 'S2' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X25 expr_type=INTEGER expected=UNKNOWN target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X25
[DEBUG] Deferring release of source register: X25
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X25
[LIVE] Updating live intervals at instruction point 14
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X25
[DEBUG] Releasing source register: X25
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 14
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3_plus_8
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B .L0
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11_plus_8
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'ERROR: SPLIT returned null
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str12
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[LIVE] Freed register X25 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str12_plus_8
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'ERROR: JOIN returned null
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str0_plus_8
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str1_plus_8
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str2_plus_8
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str3_plus_8
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_str4_plus_8
[InstructionStream TRACE] Adding label definition: L_str5
[InstructionStream TRACE] Adding label definition: L_str5_plus_8
[InstructionStream TRACE] Adding label definition: L_str6
[InstructionStream TRACE] Adding label definition: L_str6_plus_8
[InstructionStream TRACE] Adding label definition: L_str7
[InstructionStream TRACE] Adding label definition: L_str7_plus_8
[InstructionStream TRACE] Adding label definition: L_str8
[InstructionStream TRACE] Adding label definition: L_str8_plus_8
[InstructionStream TRACE] Adding label definition: L_str9
[InstructionStream TRACE] Adding label definition: L_str9_plus_8
[InstructionStream TRACE] Adding label definition: L_str10
[InstructionStream TRACE] Adding label definition: L_str10_plus_8
[InstructionStream TRACE] Adding label definition: L_str11
[InstructionStream TRACE] Adding label definition: L_str11_plus_8
[InstructionStream TRACE] Adding label definition: L_str12
[InstructionStream TRACE] Adding label definition: L_str12_plus_8
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF1' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF2' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF3' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF4' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF5' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF6' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEF7' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'WRITEC' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RDCH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPLIT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'JOIN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'STRLEN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'STRCMP' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'STRCOPY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'PACKSTRING' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'UNPACKSTRING' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SLURP' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'GETVEC' (RUNTIME_FUNCTION, POINTER_TO|VEC|INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FGETVEC' (RUNTIME_FUNCTION, POINTER_TO|VEC|FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FREEVEC' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_ALLOC_WORDS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_ALLOC_CHARS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'MALLOC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_FREE_LIST' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_FREE_LIST_SAFE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_GET_LAST_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_CLEAR_ERRORS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_CHECK_AND_DISPLAY_ERRORS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_BOUNDS_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_FREE_CELLS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'GET_FREE_LIST_HEAD_ADDR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_CREATE' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_APPEND_INT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_APPEND_FLOAT' (RUNTIME_FLOAT_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_APPEND_STRING' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_HEAD_INT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_HEAD_FLOAT' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_TAIL' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LIST_FREE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_LIST_APPEND_LIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_LIST_GET_REST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_GET_ATOM_TYPE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_LIST_GET_NTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'BCPL_CONCAT_LISTS' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'CONCAT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'COPYLIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'DEEPCOPYLIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'DEEPCOPYLITERALLIST' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'REVERSE' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FIND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILTER' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'APND' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FPND' (RUNTIME_FLOAT_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SPND' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'LPND' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='Global')
Symbol 'returnNodeToFreelist' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FIX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'FINISH' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SETTYPE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_enter_scope' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HEAPMANAGER_ISSAMMENABLED' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HEAPMANAGER_SETSAMMENABLED' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HEAPMANAGER_WAITFORSAMM' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'OBJECT_HEAP_ALLOC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'OBJECT_HEAP_FREE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'RUNTIME_METHOD_LOOKUP' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'PIC_RUNTIME_HELPER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'S1' (LOCAL_VAR, POINTER_TO|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, POINTER_TO|LIST|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'S2' (LOCAL_VAR, INTEGER, scope=3, block=0, class_name='', function_name='START')

Data sections generated.

=== Peephole Optimization ===
Analyzing 459 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 30
  Before:
    STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40  [Opcode=26, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
    STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48  [Opcode=26, Dest=-1, Src1=20, Imm=48, Base=29, Offset=48]
  After:
    STP x19, x20, [x29, #40]  [Opcode=30, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 31
  Before:
    STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56  [Opcode=26, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
    STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64  [Opcode=26, Dest=-1, Src1=25, Imm=64, Base=29, Offset=64]
  After:
    STP x21, x25, [x29, #56]  [Opcode=30, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 32
  Before:
    STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72  [Opcode=26, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
    STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80  [Opcode=26, Dest=-1, Src1=27, Imm=80, Base=29, Offset=80]
  After:
    STP x26, x27, [x29, #72]  [Opcode=30, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: In-place comparison optimization (MOV-CMP -> CMP)
  Position: 72
  Before:
    MOV X9, X27  [Opcode=1, Dest=9, Src1=27]
    CMP X9, #0  [Opcode=24, Dest=-1, Src1=9, Imm=0]
  After:
    CMP x27, #0  [Opcode=24, Dest=-1, Src1=27, Imm=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: In-place comparison optimization (MOV-CMP -> CMP)
  Position: 94
  Before:
    MOV X9, X25  [Opcode=1, Dest=9, Src1=25]
    CMP X9, #0  [Opcode=24, Dest=-1, Src1=9, Imm=0]
  After:
    CMP x25, #0  [Opcode=24, Dest=-1, Src1=25, Imm=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 126
  Before:
    LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40  [Opcode=27, Dest=19, Src1=-1, Imm=40, Base=29, Offset=40]
    LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48  [Opcode=27, Dest=20, Src1=-1, Imm=48, Base=29, Offset=48]
  After:
    LDP x19, x20, [x29, #40]  [Opcode=31, Dest=19, Src1=20, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 127
  Before:
    LDR X21, [X29, #56] ; Restored Reg: X21 @ FP+56  [Opcode=27, Dest=21, Src1=-1, Imm=56, Base=29, Offset=56]
    LDR X25, [X29, #64] ; Restored Reg: X25 @ FP+64  [Opcode=27, Dest=25, Src1=-1, Imm=64, Base=29, Offset=64]
  After:
    LDP x21, x25, [x29, #56]  [Opcode=31, Dest=21, Src1=25, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 128
  Before:
    LDR X26, [X29, #72] ; Restored Reg: X26 @ FP+72  [Opcode=27, Dest=26, Src1=-1, Imm=72, Base=29, Offset=72]
    LDR X27, [X29, #80] ; Restored Reg: X27 @ FP+80  [Opcode=27, Dest=27, Src1=-1, Imm=80, Base=29, Offset=80]
  After:
    LDP x26, x27, [x29, #72]  [Opcode=31, Dest=26, Src1=27, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 131
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [SP, #0]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 459
  Instructions after:  450
  Total optimizations: 9
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 4
    - In-place comparison optimization (MOV-CMP -> CMP): 2
    - Combine adjacent X-register STRs into STP: 3
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x107f98000) ---
Address Hex Code    Assembly
--------------------------------------------------
 107f98000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 107f98004 0xd291ed10  MOVZ X16, #36712
 107f98008 0xf2a05430  MOVK X16, #673, LSL #16
 107f9800c 0xf2c00030  MOVK X16, #1, LSL #32
 107f98010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 107f98014 0xd291f290  MOVZ X16, #36756
 107f98018 0xf2a05430  MOVK X16, #673, LSL #16
 107f9801c 0xf2c00030  MOVK X16, #1, LSL #32
 107f98020 0xd61f0200  BR X16
JOIN_veneer:
 107f98024 0xd2918410  MOVZ X16, #35872
 107f98028 0xf2a054b0  MOVK X16, #677, LSL #16
 107f9802c 0xf2c00030  MOVK X16, #1, LSL #32
 107f98030 0xd61f0200  BR X16
SPLIT_veneer:
 107f98034 0xd2918990  MOVZ X16, #35916
 107f98038 0xf2a054b0  MOVK X16, #677, LSL #16
 107f9803c 0xf2c00030  MOVK X16, #1, LSL #32
 107f98040 0xd61f0200  BR X16
WRITES_veneer:
 107f98044 0xd28a8010  MOVZ X16, #21504
 107f98048 0xf2a054b0  MOVK X16, #677, LSL #16
 107f9804c 0xf2c00030  MOVK X16, #1, LSL #32
 107f98050 0xd61f0200  BR X16
 107f98054 0x00000000  ; --- End Veneer Section ---

START:
 107f98058 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 107f9805c 0x910003fd  MOV X29, SP
 107f98060 0xa902d3b3  STP x19, x20, [x29, #40]
 107f98064 0xa903e7b5  STP x21, x25, [x29, #56]
 107f98068 0xa904efba  STP x26, x27, [x29, #72]
 107f9806c 0xf9002fbc  STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
 107f98070 0xd298001c  MOVZ X28, #49152
 107f98074 0xf2a06afc  MOVK X28, #855, LSL #16
 107f98078 0xf2c0003c  MOVK X28, #1, LSL #32
 107f9807c 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 107f98080 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x107f9d000
 107f98084 0x91002129  ADD X9, X9, #:lo12:L_str0_plus_8    ; Reloc -> 'L_str0' @ 0x107f9d000
 107f98088 0xaa0903e0  MOV X0, X9
 107f9808c 0x97ffffee  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f98090 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x107f9d098
 107f98094 0x91028129  ADD X9, X9, #:lo12:L_str1_plus_8    ; Reloc -> 'L_str1' @ 0x107f9d098
 107f98098 0xaa0903fa  MOV X26, X9
 107f9809c 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x107f9d0e8
 107f980a0 0x9103c129  ADD X9, X9, #:lo12:L_str2_plus_8    ; Reloc -> 'L_str2' @ 0x107f9d0e8
 107f980a4 0xaa0903e0  MOV X0, X9
 107f980a8 0x97ffffe7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f980ac 0xaa1a03e0  MOV X0, X26
 107f980b0 0x97ffffe5  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f980b4 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x107f9d13c
 107f980b8 0x91051129  ADD X9, X9, #:lo12:L_str3_plus_8    ; Reloc -> 'L_str3' @ 0x107f9d13c
 107f980bc 0xaa0903e0  MOV X0, X9
 107f980c0 0x97ffffe1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f980c4 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x107f9d150
 107f980c8 0x91056129  ADD X9, X9, #:lo12:L_str4_plus_8    ; Reloc -> 'L_str4' @ 0x107f9d150
 107f980cc 0xaa0903e0  MOV X0, X9
 107f980d0 0x97ffffdd  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f980d4 0xaa1a03f4  MOV X20, X26
 107f980d8 0xb0000029  ADRP X9, L_str5    ; Reloc -> 'L_str5' @ 0x107f9d1a4
 107f980dc 0x9106b129  ADD X9, X9, #:lo12:L_str5_plus_8    ; Reloc -> 'L_str5' @ 0x107f9d1a4
 107f980e0 0xaa0903f4  MOV X20, X9
 107f980e4 0xaa1403e0  MOV X0, X20
 107f980e8 0xaa1403e1  MOV X1, X20
 107f980ec 0x97ffffd2  BL SPLIT_veneer    ; Reloc -> 'SPLIT_veneer' @ 0x107f98034
 107f980f0 0xaa0003fb  MOV X27, X0
 107f980f4 0xb000002a  ADRP X10, L_str6    ; Reloc -> 'L_str6' @ 0x107f9d1b8
 107f980f8 0x9107014a  ADD X10, X10, #:lo12:L_str6_plus_8    ; Reloc -> 'L_str6' @ 0x107f9d1b8
 107f980fc 0xaa0a03e0  MOV X0, X10
 107f98100 0x97ffffd1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f98104 0xf100037f  CMP x27, #0
 107f98108 0x9a9f17ea  CSET X10, EQ
 107f9810c 0xeb1f015f  CMP X10, XZR
 107f98110 0x54000040  B.EQ START_Else_2    ; Reloc -> 'START_Else_2' @ 0x107f98118
 107f98114 0x14000022  B START_Then_1    ; Reloc -> 'START_Then_1' @ 0x107f9819c
START_Else_2:
 107f98118 0xb0000029  ADRP X9, L_str7    ; Reloc -> 'L_str7' @ 0x107f9d208
 107f9811c 0x91084129  ADD X9, X9, #:lo12:L_str7_plus_8    ; Reloc -> 'L_str7' @ 0x107f9d208
 107f98120 0xaa0903e0  MOV X0, X9
 107f98124 0x97ffffc8  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f98128 0xaa1b03f4  MOV X20, X27
 107f9812c 0xb0000029  ADRP X9, L_str8    ; Reloc -> 'L_str8' @ 0x107f9d2c4
 107f98130 0x910b3129  ADD X9, X9, #:lo12:L_str8_plus_8    ; Reloc -> 'L_str8' @ 0x107f9d2c4
 107f98134 0xaa0903f4  MOV X20, X9
 107f98138 0xaa1403e0  MOV X0, X20
 107f9813c 0xaa1403e1  MOV X1, X20
 107f98140 0x97ffffb9  BL JOIN_veneer    ; Reloc -> 'JOIN_veneer' @ 0x107f98024
 107f98144 0xaa0003f9  MOV X25, X0
 107f98148 0xb000002a  ADRP X10, L_str9    ; Reloc -> 'L_str9' @ 0x107f9d2d8
 107f9814c 0x910b814a  ADD X10, X10, #:lo12:L_str9_plus_8    ; Reloc -> 'L_str9' @ 0x107f9d2d8
 107f98150 0xaa0a03e0  MOV X0, X10
 107f98154 0x97ffffbc  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f98158 0xf100033f  CMP x25, #0
 107f9815c 0x9a9f17ea  CSET X10, EQ
 107f98160 0xeb1f015f  CMP X10, XZR
 107f98164 0x54000040  B.EQ START_Else_5    ; Reloc -> 'START_Else_5' @ 0x107f9816c
 107f98168 0x14000012  B START_Then_4    ; Reloc -> 'START_Then_4' @ 0x107f981b0
START_Else_5:
 107f9816c 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x107f9d324
 107f98170 0x910cb129  ADD X9, X9, #:lo12:L_str10_plus_8    ; Reloc -> 'L_str10' @ 0x107f9d324
 107f98174 0xaa0903e0  MOV X0, X9
 107f98178 0x97ffffb3  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f9817c 0xaa1903e0  MOV X0, X25
 107f98180 0x97ffffb1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f98184 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x107f9d13c
 107f98188 0x91051129  ADD X9, X9, #:lo12:L_str3_plus_8    ; Reloc -> 'L_str3' @ 0x107f9d13c
 107f9818c 0xaa0903e0  MOV X0, X9
 107f98190 0x97ffffad  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f98194 0x14000001  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x107f98198
START_Exit_7:
 107f98198 0x1400000b  B .L0    ; Reloc -> '.L0' @ 0x107f981c4
START_Then_1:
 107f9819c 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x107f9d368
 107f981a0 0x910dc129  ADD X9, X9, #:lo12:L_str11_plus_8    ; Reloc -> 'L_str11' @ 0x107f9d368
 107f981a4 0xaa0903e0  MOV X0, X9
 107f981a8 0x97ffffa7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f981ac 0x17fffffb  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x107f98198
START_Then_4:
 107f981b0 0xb0000029  ADRP X9, L_str12    ; Reloc -> 'L_str12' @ 0x107f9d3e4
 107f981b4 0x910fb129  ADD X9, X9, #:lo12:L_str12_plus_8    ; Reloc -> 'L_str12' @ 0x107f9d3e4
 107f981b8 0xaa0903e0  MOV X0, X9
 107f981bc 0x97ffffa2  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107f98044
 107f981c0 0x17fffff6  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x107f98198
.L0:
 107f981c4 0xa942d3b3  LDP x19, x20, [x29, #40]
 107f981c8 0xa943e7b5  LDP x21, x25, [x29, #56]
 107f981cc 0xa944efba  LDP x26, x27, [x29, #72]
 107f981d0 0xf9402fbc  LDR X28, [X29, #88] ; Restored Reg: X28 @ FP+88
 107f981d4 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 107f981d8 0xa9407bfd  LDP x29, x30, [SP, #0]
 107f981dc 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 107f981e0 0xd65f03c0  RET
L_str0:
 107f9d000 0x22000000  .quad 0x22
 107f9d004 0x00000000  ; (upper half)
L_str0_plus_8:
 107f9d008 0x54000000  DCD 0x54
 107f9d00c 0x65000000  DCD 0x65
 107f9d010 0x73000000  DCD 0x73
 107f9d014 0x74000000  DCD 0x74
 107f9d018 0x69000000  DCD 0x69
 107f9d01c 0x6e000000  DCD 0x6e
 107f9d020 0x67000000  DCD 0x67
 107f9d024 0x20000000  DCD 0x20
 107f9d028 0x53000000  DCD 0x53
 107f9d02c 0x50000000  DCD 0x50
 107f9d030 0x4c000000  DCD 0x4c
 107f9d034 0x49000000  DCD 0x49
 107f9d038 0x54000000  DCD 0x54
 107f9d03c 0x2d000000  DCD 0x2d
 107f9d040 0x3e000000  DCD 0x3e
 107f9d044 0x4a000000  DCD 0x4a
 107f9d048 0x4f000000  DCD 0x4f
 107f9d04c 0x49000000  DCD 0x49
 107f9d050 0x4e000000  DCD 0x4e
 107f9d054 0x20000000  DCD 0x20
 107f9d058 0x72000000  DCD 0x72
 107f9d05c 0x6f000000  DCD 0x6f
 107f9d060 0x75000000  DCD 0x75
 107f9d064 0x6e000000  DCD 0x6e
 107f9d068 0x64000000  DCD 0x64
 107f9d06c 0x2d000000  DCD 0x2d
 107f9d070 0x74000000  DCD 0x74
 107f9d074 0x72000000  DCD 0x72
 107f9d078 0x69000000  DCD 0x69
 107f9d07c 0x70000000  DCD 0x70
 107f9d080 0x2e000000  DCD 0x2e
 107f9d084 0x2e000000  DCD 0x2e
 107f9d088 0x2e000000  DCD 0x2e
 107f9d08c 0xa0000000  DCD 0xa
 107f9d090 0x00000000  DCD 0x0
 107f9d094 0x00000000  DCD 0x0
L_str1:
 107f9d098 0x10000000  .quad 0x10
 107f9d09c 0x00000000  ; (upper half)
L_str1_plus_8:
 107f9d0a0 0x68000000  DCD 0x68
 107f9d0a4 0x65000000  DCD 0x65
 107f9d0a8 0x6c000000  DCD 0x6c
 107f9d0ac 0x6c000000  DCD 0x6c
 107f9d0b0 0x6f000000  DCD 0x6f
 107f9d0b4 0x20000000  DCD 0x20
 107f9d0b8 0x77000000  DCD 0x77
 107f9d0bc 0x6f000000  DCD 0x6f
 107f9d0c0 0x72000000  DCD 0x72
 107f9d0c4 0x6c000000  DCD 0x6c
 107f9d0c8 0x64000000  DCD 0x64
 107f9d0cc 0x20000000  DCD 0x20
 107f9d0d0 0x74000000  DCD 0x74
 107f9d0d4 0x65000000  DCD 0x65
 107f9d0d8 0x73000000  DCD 0x73
 107f9d0dc 0x74000000  DCD 0x74
 107f9d0e0 0x00000000  DCD 0x0
 107f9d0e4 0x00000000  DCD 0x0
L_str2:
 107f9d0e8 0x11000000  .quad 0x11
 107f9d0ec 0x00000000  ; (upper half)
L_str2_plus_8:
 107f9d0f0 0x4f000000  DCD 0x4f
 107f9d0f4 0x72000000  DCD 0x72
 107f9d0f8 0x69000000  DCD 0x69
 107f9d0fc 0x67000000  DCD 0x67
 107f9d100 0x69000000  DCD 0x69
 107f9d104 0x6e000000  DCD 0x6e
 107f9d108 0x61000000  DCD 0x61
 107f9d10c 0x6c000000  DCD 0x6c
 107f9d110 0x20000000  DCD 0x20
 107f9d114 0x73000000  DCD 0x73
 107f9d118 0x74000000  DCD 0x74
 107f9d11c 0x72000000  DCD 0x72
 107f9d120 0x69000000  DCD 0x69
 107f9d124 0x6e000000  DCD 0x6e
 107f9d128 0x67000000  DCD 0x67
 107f9d12c 0x3a000000  DCD 0x3a
 107f9d130 0x20000000  DCD 0x20
 107f9d134 0x00000000  DCD 0x0
 107f9d138 0x00000000  DCD 0x0
L_str3:
 107f9d13c 0x10000000  .quad 0x1
 107f9d140 0x00000000  ; (upper half)
L_str3_plus_8:
 107f9d144 0xa0000000  DCD 0xa
 107f9d148 0x00000000  DCD 0x0
 107f9d14c 0x00000000  DCD 0x0
L_str4:
 107f9d150 0x11000000  .quad 0x11
 107f9d154 0x00000000  ; (upper half)
L_str4_plus_8:
 107f9d158 0x43000000  DCD 0x43
 107f9d15c 0x61000000  DCD 0x61
 107f9d160 0x6c000000  DCD 0x6c
 107f9d164 0x6c000000  DCD 0x6c
 107f9d168 0x69000000  DCD 0x69
 107f9d16c 0x6e000000  DCD 0x6e
 107f9d170 0x67000000  DCD 0x67
 107f9d174 0x20000000  DCD 0x20
 107f9d178 0x53000000  DCD 0x53
 107f9d17c 0x50000000  DCD 0x50
 107f9d180 0x4c000000  DCD 0x4c
 107f9d184 0x49000000  DCD 0x49
 107f9d188 0x54000000  DCD 0x54
 107f9d18c 0x2e000000  DCD 0x2e
 107f9d190 0x2e000000  DCD 0x2e
 107f9d194 0x2e000000  DCD 0x2e
 107f9d198 0xa0000000  DCD 0xa
 107f9d19c 0x00000000  DCD 0x0
 107f9d1a0 0x00000000  DCD 0x0
L_str5:
 107f9d1a4 0x10000000  .quad 0x1
 107f9d1a8 0x00000000  ; (upper half)
L_str5_plus_8:
 107f9d1ac 0x20000000  DCD 0x20
 107f9d1b0 0x00000000  DCD 0x0
 107f9d1b4 0x00000000  DCD 0x0
L_str6:
 107f9d1b8 0x10000000  .quad 0x10
 107f9d1bc 0x00000000  ; (upper half)
L_str6_plus_8:
 107f9d1c0 0x53000000  DCD 0x53
 107f9d1c4 0x50000000  DCD 0x50
 107f9d1c8 0x4c000000  DCD 0x4c
 107f9d1cc 0x49000000  DCD 0x49
 107f9d1d0 0x54000000  DCD 0x54
 107f9d1d4 0x20000000  DCD 0x20
 107f9d1d8 0x63000000  DCD 0x63
 107f9d1dc 0x6f000000  DCD 0x6f
 107f9d1e0 0x6d000000  DCD 0x6d
 107f9d1e4 0x70000000  DCD 0x70
 107f9d1e8 0x6c000000  DCD 0x6c
 107f9d1ec 0x65000000  DCD 0x65
 107f9d1f0 0x74000000  DCD 0x74
 107f9d1f4 0x65000000  DCD 0x65
 107f9d1f8 0x64000000  DCD 0x64
 107f9d1fc 0xa0000000  DCD 0xa
 107f9d200 0x00000000  DCD 0x0
 107f9d204 0x00000000  DCD 0x0
L_str7:
 107f9d208 0x2b000000  .quad 0x2b
 107f9d20c 0x00000000  ; (upper half)
L_str7_plus_8:
 107f9d210 0x53000000  DCD 0x53
 107f9d214 0x50000000  DCD 0x50
 107f9d218 0x4c000000  DCD 0x4c
 107f9d21c 0x49000000  DCD 0x49
 107f9d220 0x54000000  DCD 0x54
 107f9d224 0x20000000  DCD 0x20
 107f9d228 0x72000000  DCD 0x72
 107f9d22c 0x65000000  DCD 0x65
 107f9d230 0x74000000  DCD 0x74
 107f9d234 0x75000000  DCD 0x75
 107f9d238 0x72000000  DCD 0x72
 107f9d23c 0x6e000000  DCD 0x6e
 107f9d240 0x65000000  DCD 0x65
 107f9d244 0x64000000  DCD 0x64
 107f9d248 0x20000000  DCD 0x20
 107f9d24c 0x61000000  DCD 0x61
 107f9d250 0x20000000  DCD 0x20
 107f9d254 0x6c000000  DCD 0x6c
 107f9d258 0x69000000  DCD 0x69
 107f9d25c 0x73000000  DCD 0x73
 107f9d260 0x74000000  DCD 0x74
 107f9d264 0x2c000000  DCD 0x2c
 107f9d268 0x20000000  DCD 0x20
 107f9d26c 0x6e000000  DCD 0x6e
 107f9d270 0x6f000000  DCD 0x6f
 107f9d274 0x77000000  DCD 0x77
 107f9d278 0x20000000  DCD 0x20
 107f9d27c 0x63000000  DCD 0x63
 107f9d280 0x61000000  DCD 0x61
 107f9d284 0x6c000000  DCD 0x6c
 107f9d288 0x6c000000  DCD 0x6c
 107f9d28c 0x69000000  DCD 0x69
 107f9d290 0x6e000000  DCD 0x6e
 107f9d294 0x67000000  DCD 0x67
 107f9d298 0x20000000  DCD 0x20
 107f9d29c 0x4a000000  DCD 0x4a
 107f9d2a0 0x4f000000  DCD 0x4f
 107f9d2a4 0x49000000  DCD 0x49
 107f9d2a8 0x4e000000  DCD 0x4e
 107f9d2ac 0x2e000000  DCD 0x2e
 107f9d2b0 0x2e000000  DCD 0x2e
 107f9d2b4 0x2e000000  DCD 0x2e
 107f9d2b8 0xa0000000  DCD 0xa
 107f9d2bc 0x00000000  DCD 0x0
 107f9d2c0 0x00000000  DCD 0x0
L_str8:
 107f9d2c4 0x10000000  .quad 0x1
 107f9d2c8 0x00000000  ; (upper half)
L_str8_plus_8:
 107f9d2cc 0x2d000000  DCD 0x2d
 107f9d2d0 0x00000000  DCD 0x0
 107f9d2d4 0x00000000  DCD 0x0
L_str9:
 107f9d2d8 0xf0000000  .quad 0xf
 107f9d2dc 0x00000000  ; (upper half)
L_str9_plus_8:
 107f9d2e0 0x4a000000  DCD 0x4a
 107f9d2e4 0x4f000000  DCD 0x4f
 107f9d2e8 0x49000000  DCD 0x49
 107f9d2ec 0x4e000000  DCD 0x4e
 107f9d2f0 0x20000000  DCD 0x20
 107f9d2f4 0x63000000  DCD 0x63
 107f9d2f8 0x6f000000  DCD 0x6f
 107f9d2fc 0x6d000000  DCD 0x6d
 107f9d300 0x70000000  DCD 0x70
 107f9d304 0x6c000000  DCD 0x6c
 107f9d308 0x65000000  DCD 0x65
 107f9d30c 0x74000000  DCD 0x74
 107f9d310 0x65000000  DCD 0x65
 107f9d314 0x64000000  DCD 0x64
 107f9d318 0xa0000000  DCD 0xa
 107f9d31c 0x00000000  DCD 0x0
 107f9d320 0x00000000  DCD 0x0
L_str10:
 107f9d324 0xd0000000  .quad 0xd
 107f9d328 0x00000000  ; (upper half)
L_str10_plus_8:
 107f9d32c 0x4a000000  DCD 0x4a
 107f9d330 0x4f000000  DCD 0x4f
 107f9d334 0x49000000  DCD 0x49
 107f9d338 0x4e000000  DCD 0x4e
 107f9d33c 0x20000000  DCD 0x20
 107f9d340 0x72000000  DCD 0x72
 107f9d344 0x65000000  DCD 0x65
 107f9d348 0x73000000  DCD 0x73
 107f9d34c 0x75000000  DCD 0x75
 107f9d350 0x6c000000  DCD 0x6c
 107f9d354 0x74000000  DCD 0x74
 107f9d358 0x3a000000  DCD 0x3a
 107f9d35c 0x20000000  DCD 0x20
 107f9d360 0x00000000  DCD 0x0
 107f9d364 0x00000000  DCD 0x0
L_str11:
 107f9d368 0x1b000000  .quad 0x1b
 107f9d36c 0x00000000  ; (upper half)
L_str11_plus_8:
 107f9d370 0x45000000  DCD 0x45
 107f9d374 0x52000000  DCD 0x52
 107f9d378 0x52000000  DCD 0x52
 107f9d37c 0x4f000000  DCD 0x4f
 107f9d380 0x52000000  DCD 0x52
 107f9d384 0x3a000000  DCD 0x3a
 107f9d388 0x20000000  DCD 0x20
 107f9d38c 0x53000000  DCD 0x53
 107f9d390 0x50000000  DCD 0x50
 107f9d394 0x4c000000  DCD 0x4c
 107f9d398 0x49000000  DCD 0x49
 107f9d39c 0x54000000  DCD 0x54
 107f9d3a0 0x20000000  DCD 0x20
 107f9d3a4 0x72000000  DCD 0x72
 107f9d3a8 0x65000000  DCD 0x65
 107f9d3ac 0x74000000  DCD 0x74
 107f9d3b0 0x75000000  DCD 0x75
 107f9d3b4 0x72000000  DCD 0x72
 107f9d3b8 0x6e000000  DCD 0x6e
 107f9d3bc 0x65000000  DCD 0x65
 107f9d3c0 0x64000000  DCD 0x64
 107f9d3c4 0x20000000  DCD 0x20
 107f9d3c8 0x6e000000  DCD 0x6e
 107f9d3cc 0x75000000  DCD 0x75
 107f9d3d0 0x6c000000  DCD 0x6c
 107f9d3d4 0x6c000000  DCD 0x6c
 107f9d3d8 0xa0000000  DCD 0xa
 107f9d3dc 0x00000000  DCD 0x0
 107f9d3e0 0x00000000  DCD 0x0
L_str12:
 107f9d3e4 0x1a000000  .quad 0x1a
 107f9d3e8 0x00000000  ; (upper half)
L_str12_plus_8:
 107f9d3ec 0x45000000  DCD 0x45
 107f9d3f0 0x52000000  DCD 0x52
 107f9d3f4 0x52000000  DCD 0x52
 107f9d3f8 0x4f000000  DCD 0x4f
 107f9d3fc 0x52000000  DCD 0x52
 107f9d400 0x3a000000  DCD 0x3a
 107f9d404 0x20000000  DCD 0x20
 107f9d408 0x4a000000  DCD 0x4a
 107f9d40c 0x4f000000  DCD 0x4f
 107f9d410 0x49000000  DCD 0x49
 107f9d414 0x4e000000  DCD 0x4e
 107f9d418 0x20000000  DCD 0x20
 107f9d41c 0x72000000  DCD 0x72
 107f9d420 0x65000000  DCD 0x65
 107f9d424 0x74000000  DCD 0x74
 107f9d428 0x75000000  DCD 0x75
 107f9d42c 0x72000000  DCD 0x72
 107f9d430 0x6e000000  DCD 0x6e
 107f9d434 0x65000000  DCD 0x65
 107f9d438 0x64000000  DCD 0x64
 107f9d43c 0x20000000  DCD 0x20
 107f9d440 0x6e000000  DCD 0x6e
 107f9d444 0x75000000  DCD 0x75
 107f9d448 0x6c000000  DCD 0x6c
 107f9d44c 0x6c000000  DCD 0x6c
 107f9d450 0xa0000000  DCD 0xa
 107f9d454 0x00000000  DCD 0x0
 107f9d458 0x00000000  DCD 0x0

--------------------------

JIT runtime table populated with 125 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x107f98058
[JITExecutor] Starting execution of JIT-compiled function at address: 0x107f98058
Testing SPLIT->JOIN round-trip...
Original string: hello world test
Calling SPLIT...
SAMM: Tracked freelist allocation 0x74d019000 in scope (depth: 1, scope size: 1)
SAMM: Tracked list allocation 0x74d019000 in scope (depth: 1, scope size: 2)
BCPL String Optimizations: Initialized (pool + SIMD)
SAMM: Tracked string pool allocation 0x74d0b37dc in scope (depth: 1, scope size: 3)
SAMM: Tracked string pool allocation 0x74d0b37a0 in scope (depth: 1, scope size: 4)
SPLIT completed
SPLIT returned a list, now calling JOIN...
