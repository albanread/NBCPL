Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=tests/bcl_tests/class1.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.1612
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/tests/bcl_tests/class1.bcl"
// class1.bcl - Test for class member variable access
// This file demonstrates proper class member variable access with fixed offsets
// to avoid conflicts with the vtable pointer at offset 0.

CLASS Point $(
    DECL x, y  // These will be placed at offsets 8 and 16, after the vtable pointer

    // Constructor
    ROUTINE CREATE(initialX, initialY) BE $(
        x := initialX
        y := initialY
        WRITES("Point created at (")
        WRITEN(x)
        WRITES(", ")
        WRITEN(y)
        WRITES(")*N")
    $)

    // Accessor methods
    FUNCTION getX() = VALOF $(
        RESULTIS x
    $)

    FUNCTION getY() = VALOF $(
        RESULTIS y
    $)

    // Setter method
    ROUTINE set(newX, newY) BE $(
        x := newX
        y := newY
        WRITES("Point moved to (")
        WRITEN(x)
        WRITES(", ")
        WRITEN(y)
        WRITES(")*N")
    $)
$)

LET START() BE $(

    WRITES("Creating point...*N")

    LET p = NEW Point(50,75)

    WRITES("Reading values: x=")
    WRITEN(p.getX())
    WRITES(", y=")
    WRITEN(p.getY())
    WRITES("*N*N")

    WRITES("Setting new values...*N")
    p.set(100, 200)

    WRITES("Reading new values: x=")
    WRITEN(p.getX())
    WRITES(", y=")
    WRITEN(p.getY())
    WRITES("*N")
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x102b54e40
Registered 91 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x102b53b74 | args: 0 | table_offset: 712
  FINISH           | address: 0x102b52924 | args: 0 | table_offset: 704
  FABS             | address: 0x102b52cd4 | args: 1 | table_offset: 672
  FSIN             | address: 0x102b52c98 | args: 1 | table_offset: 648
  FILE_EOF         | address: 0x102b55f8c | args: 1 | table_offset: 616
  RAND             | address: 0x102b52b24 | args: 1 | table_offset: 624
  FILE_TELL        | address: 0x102b55f34 | args: 1 | table_offset: 608
  FILE_SEEK        | address: 0x102b55e70 | args: 3 | table_offset: 600
  FILE_WRITE       | address: 0x102b55d58 | args: 3 | table_offset: 592
  FIX              | address: 0x102b52d14 | args: 1 | table_offset: 696
  FILE_READS       | address: 0x102b557a4 | args: 1 | table_offset: 576
  FILE_WRITES      | address: 0x102b554c8 | args: 2 | table_offset: 568
  FEXP             | address: 0x102b52d00 | args: 1 | table_offset: 688
  FILE_CLOSE       | address: 0x102b5545c | args: 1 | table_offset: 560
  FILE_OPEN_APPEND | address: 0x102b553cc | args: 1 | table_offset: 552
  SLURP            | address: 0x102b533fc | args: 1 | table_offset: 520
  PACKSTRING       | address: 0x102b52d2c | args: 1 | table_offset: 504
  STRLEN           | address: 0x102b52934 | args: 1 | table_offset: 496
  FCOS             | address: 0x102b52cac | args: 1 | table_offset: 656
  STRCMP           | address: 0x102b52994 | args: 2 | table_offset: 488
  STRCOPY          | address: 0x102b52a78 | args: 2 | table_offset: 480
  FIND             | address: 0x102b594b4 | args: 3 | table_offset: 448
  DEEPCOPYLITERALLIST | address: 0x102b5912c | args: 1 | table_offset: 432
  DEEPCOPYLIST     | address: 0x102b58f94 | args: 1 | table_offset: 424
  COPYLIST         | address: 0x102b58e94 | args: 1 | table_offset: 416
  CONCAT           | address: 0x102b592cc | args: 2 | table_offset: 408
  BCPL_CONCAT_LISTS | address: 0x102b592cc | args: 2 | table_offset: 400
  SPIT             | address: 0x102b53928 | args: 2 | table_offset: 528
  JOIN             | address: 0x102b58530 | args: 2 | table_offset: 472
  LPND             | address: 0x102b58a40 | args: 2 | table_offset: 392
  SPND             | address: 0x102b58970 | args: 2 | table_offset: 384
  FPND             | address: 0x102b588a0 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x102b59984 | args: 1 | table_offset: 720
  BCPL_LIST_APPEND_INT | address: 0x102b587d0 | args: 2 | table_offset: 344
  GETVEC           | address: 0x102b54f04 | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x102a439c0 | args: 0 | table_offset: 312
  APND             | address: 0x102b587d0 | args: 2 | table_offset: 368
  HEAPMANAGER_ENTER_SCOPE | address: 0x102a438f8 | args: 0 | table_offset: 280
  HEAPMANAGER_SETSAMMENABLED | address: 0x102a438a4 | args: 1 | table_offset: 296
  HEAPMANAGER_EXIT_SCOPE | address: 0x102a43924 | args: 0 | table_offset: 288
  PIC_RUNTIME_HELPER | address: 0x102b54fb8 | args: 0 | table_offset: 272
  OBJECT_HEAP_FREE | address: 0x102b54f7c | args: 1 | table_offset: 256
  OBJECT_HEAP_ALLOC | address: 0x102b54f58 | args: 1 | table_offset: 248
  BCPL_LIST_GET_REST | address: 0x102b58cfc | args: 1 | table_offset: 216
  FRND             | address: 0x102b52bb0 | args: 0 | table_offset: 640
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x102b58c44 | args: 1 | table_offset: 200
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x102b58be0 | args: 1 | table_offset: 192
  RUNTIME_METHOD_LOOKUP | address: 0x102b54fa0 | args: 2 | table_offset: 264
  FREEVEC          | address: 0x102b54e40 | args: 1 | table_offset: 136
  BCPL_BOUNDS_ERROR | address: 0x102b50e04 | args: 3 | table_offset: 184
  WRITEF4          | address: 0x102b52458 | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x102b59658 | args: 1 | table_offset: 144
  BCPL_ALLOC_CHARS | address: 0x102b54de8 | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x102b588a0 | args: 2 | table_offset: 352
  GET_FREE_LIST_HEAD_ADDR | address: 0x102b59978 | args: 0 | table_offset: 328
  BCPL_GET_ATOM_TYPE | address: 0x102b58d60 | args: 1 | table_offset: 224
  FWRITE           | address: 0x102b51e34 | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x102b58770 | args: 0 | table_offset: 336
  SPLIT            | address: 0x102b581c4 | args: 2 | table_offset: 464
  BCPL_FREE_CELLS  | address: 0x102b59974 | args: 0 | table_offset: 320
  RND              | address: 0x102b52c04 | args: 1 | table_offset: 632
  HEAPMANAGER_ISSAMMENABLED | address: 0x102a438d4 | args: 0 | table_offset: 304
  WRITEC           | address: 0x102b52714 | args: 1 | table_offset: 88
  MALLOC           | address: 0x102b54d88 | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x102b54d88 | args: 3 | table_offset: 104
  FTAN             | address: 0x102b52cc0 | args: 1 | table_offset: 664
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 240
  BCPL_GET_LAST_ERROR | address: 0x102b50c84 | args: 1 | table_offset: 160
  RDCH             | address: 0x102b528d8 | args: 0 | table_offset: 96
  FILE_READ        | address: 0x102b55c44 | args: 3 | table_offset: 584
  UNPACKSTRING     | address: 0x102b53064 | args: 1 | table_offset: 512
  WRITEF5          | address: 0x102b524e4 | args: 6 | table_offset: 64
  FILTER           | address: 0x102b595a8 | args: 2 | table_offset: 456
  BCPL_FREE_LIST_SAFE | address: 0x102b59760 | args: 1 | table_offset: 152
  FILE_OPEN_WRITE  | address: 0x102b5533c | args: 1 | table_offset: 544
  FILE_OPEN_READ   | address: 0x102b54fbc | args: 1 | table_offset: 536
  BCPL_LIST_GET_NTH | address: 0x102b58dc8 | args: 2 | table_offset: 232
  WRITEF7          | address: 0x102b52620 | args: 8 | table_offset: 80
  WRITEF3          | address: 0x102b523d8 | args: 4 | table_offset: 48
  WRITEF6          | address: 0x102b5257c | args: 7 | table_offset: 72
  REVERSE          | address: 0x102b593cc | args: 1 | table_offset: 440
  WRITEF2          | address: 0x102b52364 | args: 3 | table_offset: 40
  WRITEF1          | address: 0x102b522fc | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x102b58cac | args: 1 | table_offset: 208
  BCPL_CLEAR_ERRORS | address: 0x102b50d34 | args: 0 | table_offset: 168
  WRITEF           | address: 0x102b51e78 | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x102b58970 | args: 2 | table_offset: 360
  WRITES           | address: 0x102b51bc4 | args: 1 | table_offset: 0
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x102b599cc | args: 0 | table_offset: 176
  FLOG             | address: 0x102b52cec | args: 1 | table_offset: 680
  WRITEN           | address: 0x102b526d0 | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point moved to ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        RoutineDeclaration: RELEASE
          Body:
            CompoundStatement:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Creating point...
"
            AssignmentStatement:
              LHS:
                VariableAccess: p
              RHS:
                NewExpression: Point
                  Arguments:
                    NumberLiteral: 50
                    NumberLiteral: 75
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Reading values: x="
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEN
              Arguments:
                FunctionCall:
                  Callee:
                    MemberAccess: getX
                      Object:
                        VariableAccess: p
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: ", y="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getY
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "

"
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Setting new values...
"
                RoutineCallStatement:
                  Callee:
                    MemberAccess: set
                      Object:
                        VariableAccess: p
                    Arguments:
                      NumberLiteral: 100
                      NumberLiteral: 200
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Reading new values: x="
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITEN
                    Arguments:
                      FunctionCall:
                        Callee:
                          MemberAccess: getX
                            Object:
                              VariableAccess: p
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: ", y="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getY
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: "
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point moved to ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        RoutineDeclaration: RELEASE
          Body:
            CompoundStatement:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Creating point...
"
            AssignmentStatement:
              LHS:
                VariableAccess: p
              RHS:
                NewExpression: Point
                  Arguments:
                    NumberLiteral: 50
                    NumberLiteral: 75
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Reading values: x="
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITEN
              Arguments:
                FunctionCall:
                  Callee:
                    MemberAccess: getX
                      Object:
                        VariableAccess: p
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: ", y="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  FunctionCall:
                    Callee:
                      MemberAccess: getY
                        Object:
                          VariableAccess: p
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "

"
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Setting new values...
"
                RoutineCallStatement:
                  Callee:
                    MemberAccess: set
                      Object:
                        VariableAccess: p
                    Arguments:
                      NumberLiteral: 100
                      NumberLiteral: 200
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITES
                    Arguments:
                      StringLiteral: "Reading new values: x="
                  RoutineCallStatement:
                    Callee:
                      VariableAccess: WRITEN
                    Arguments:
                      FunctionCall:
                        Callee:
                          MemberAccess: getX
                            Object:
                              VariableAccess: p
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: ", y="
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITEN
                      Arguments:
                        FunctionCall:
                          Callee:
                            MemberAccess: getY
                              Object:
                                VariableAccess: p
                      RoutineCallStatement:
                        Callee:
                          VariableAccess: WRITES
                        Arguments:
                          StringLiteral: "
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing class declaration: Point
[SymbolDiscoveryPass] Processing member variable declaration in class: Point
[SymbolDiscoveryPass] Added member variable: x to class Point
[SymbolDiscoveryPass] Added member variable: y to class Point
[SymbolDiscoveryPass] Added class method routine: Point::CREATE
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::CREATE
[SymbolDiscoveryPass] Added parameter: _this in method Point::CREATE
[SymbolDiscoveryPass] Added parameter: initialX in method Point::CREATE
[SymbolDiscoveryPass] Added parameter: initialY in method Point::CREATE
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method function: Point::getX
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::getX
[SymbolDiscoveryPass] Added parameter: _this in method Point::getX
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method function: Point::getY
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::getY
[SymbolDiscoveryPass] Added parameter: _this in method Point::getY
[SymbolDiscoveryPass] Entering ValofExpression block
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method routine: Point::set
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::set
[SymbolDiscoveryPass] Added parameter: _this in method Point::set
[SymbolDiscoveryPass] Added parameter: newX in method Point::set
[SymbolDiscoveryPass] Added parameter: newY in method Point::set
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Added class method routine: Point::RELEASE
[SymbolDiscoveryPass] Added implicit _this parameter for method: Point::RELEASE
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: p as INTEGER (default INTEGER)

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'x' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'y' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'Point::CREATE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'Point::getX' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol 'Point::getY' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol 'Point::set' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::set')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'Point::RELEASE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::RELEASE')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting ClassDeclaration: Point
[ANALYZER TRACE] Visiting class.
[ANALYZER TRACE] Visiting RoutineDeclaration: CREATE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::CREATE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Set parameter type: initialX in Point::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialX in Point::CREATE set to 0
[ANALYZER] Set parameter type: initialY in Point::CREATE to 0
[ANALYZER TRACE] Early parameter type for initialY in Point::CREATE set to 0
[ANALYZER] Starting parameter type inference for function: Point::CREATE
[ANALYZER] Analyzing parameter: initialX
[ANALYZER] Parameter 'initialX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: initialY
[ANALYZER] Parameter 'initialY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in Point::CREATE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::CREATE to 1056768 after inference
[ANALYZER] Set parameter type: initialX in Point::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialX in Point::CREATE to 0 after inference
[ANALYZER] Set parameter type: initialY in Point::CREATE to 0
[ANALYZER TRACE] Updated parameter type for initialY in Point::CREATE to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: CREATE
[ANALYZER TRACE] Entering block scope: Point::CREATE_block_3 (Function scope remains: Point::CREATE)
[ANALYZER TRACE] BlockStatement: Traversing 7 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialX
[DEBUG get_effective_variable_name] Called with: 'initialX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialX'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: initialY
[DEBUG get_effective_variable_name] Called with: 'initialY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'initialY'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x10388bc00
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x10388bcf0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x10388bd90
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c000
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c030
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: Point::CREATE
[ANALYZER TRACE] Visiting FunctionDeclaration: getX
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::getX
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::getX
[ANALYZER] Set parameter type: _this in Point::getX to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::getX to 1056768 after inference
[ANALYZER TRACE] Entering block scope: Point::getX_block_3 (Function scope remains: Point::getX)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[DEBUG get_variable_type] Looking for 'x' in function 'Point::getX'
[DEBUG get_variable_type] Found function metrics for 'Point::getX'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'x' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::getX')
[DEBUG get_variable_type] Found in symbol table: x -> 1
[ANALYZER TRACE] Exiting block scope, returning to: Point::getX
[DEBUG get_variable_type] Looking for 'x' in function 'Point::getX'
[DEBUG get_variable_type] Found function metrics for 'Point::getX'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'x' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::getX')
[DEBUG get_variable_type] Found in symbol table: x -> 1
[ANALYZER TRACE] Detected trivial accessor method: Point::getX (accesses: x)
[ANALYZER TRACE] Visiting FunctionDeclaration: getY
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::getY
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::getY
[ANALYZER] Set parameter type: _this in Point::getY to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::getY to 1056768 after inference
[ANALYZER TRACE] Entering block scope: Point::getY_block_3 (Function scope remains: Point::getY)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 60
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[DEBUG get_variable_type] Looking for 'y' in function 'Point::getY'
[DEBUG get_variable_type] Found function metrics for 'Point::getY'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'y' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::getY')
[DEBUG get_variable_type] Found in symbol table: y -> 1
[ANALYZER TRACE] Exiting block scope, returning to: Point::getY
[DEBUG get_variable_type] Looking for 'y' in function 'Point::getY'
[DEBUG get_variable_type] Found function metrics for 'Point::getY'
[DEBUG get_variable_type] Parameter types count: 1
[DEBUG get_variable_type] Variable types count: 1
[DEBUG get_variable_type] Variable 'y' not found in function metrics
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::getY')
[DEBUG get_variable_type] Found in symbol table: y -> 1
[ANALYZER TRACE] Detected trivial accessor method: Point::getY (accesses: y)
[ANALYZER TRACE] Visiting RoutineDeclaration: set
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::set
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Set parameter type: newX in Point::set to 0
[ANALYZER TRACE] Early parameter type for newX in Point::set set to 0
[ANALYZER] Set parameter type: newY in Point::set to 0
[ANALYZER TRACE] Early parameter type for newY in Point::set set to 0
[ANALYZER] Starting parameter type inference for function: Point::set
[ANALYZER] Analyzing parameter: newX
[ANALYZER] Parameter 'newX' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Analyzing parameter: newY
[ANALYZER] Parameter 'newY' already has type from Pass 1: 0. Preserving it.
[ANALYZER] Set parameter type: _this in Point::set to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::set to 1056768 after inference
[ANALYZER] Set parameter type: newX in Point::set to 0
[ANALYZER TRACE] Updated parameter type for newX in Point::set to 0 after inference
[ANALYZER] Set parameter type: newY in Point::set to 0
[ANALYZER TRACE] Updated parameter type for newY in Point::set to 0 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: set
[ANALYZER TRACE] Entering block scope: Point::set_block_5 (Function scope remains: Point::set)
[ANALYZER TRACE] BlockStatement: Traversing 7 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 43
[ANALYZER TRACE] Visiting VariableAccess: newX
[DEBUG get_effective_variable_name] Called with: 'newX'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'newX'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: newY
[DEBUG get_effective_variable_name] Called with: 'newY'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'newY'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c060
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c090
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: x
[DEBUG get_effective_variable_name] Called with: 'x'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'x'
[ANALYZER TRACE] Identified 'x' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c0c0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c0f0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: y
[DEBUG get_effective_variable_name] Called with: 'y'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'y'
[ANALYZER TRACE] Identified 'y' as class member of 'Point'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c120
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: Point::set
[ANALYZER TRACE] Visiting RoutineDeclaration: RELEASE

[ANALYZER IMPORTANT] === Adding _this parameter to method: Point::RELEASE ===
[ANALYZER TRACE]   Injected '_this' parameter for method: Point::RELEASE
[ANALYZER IMPORTANT] Setting _this parameter type to POINTER_TO_OBJECT for Point::RELEASE
[ANALYZER IMPORTANT] Added _this symbol to symbol table with class_name: Point
[ANALYZER] Starting parameter type inference for function: Point::RELEASE
[ANALYZER] Set parameter type: _this in Point::RELEASE to 1056768
[ANALYZER TRACE] Updated parameter type for _this in Point::RELEASE to 1056768 after inference
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: RELEASE
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_5 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 14 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c150
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 43
[ANALYZER TRACE] Visiting VariableAccess: p
[DEBUG get_effective_variable_name] Called with: 'p'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'p'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c180
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c1b0
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c1e0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c210
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c240
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c270
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c2a0
[ANALYZER TRACE] BlockStatement: Calling accept on statement 9 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c2d0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 10 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c300
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 11 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c330
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 12 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c360
[ANALYZER TRACE]   Detected call to runtime function: WRITEN, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 13 of type 44
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x84901c390
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 6
  Allocation-free functions: 5
  Allocation-free leaf functions: 3
  Allocation-free non-leaf functions: 2
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: Point::CREATE
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::RELEASE
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getX
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getY
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::set
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 2
  Float Locals: 0
  Runtime Calls: 12
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
[CSE DEBUG] Starting LocalOptimizationPass::run() on AST
[CSE DEBUG] Processing routine: START
[CSE DEBUG] ANALYSIS: Counting subexpressions in routine START
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=62
[CSE DEBUG] Processing BlockStatement with 14 statements
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=1
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=43
[CSE DEBUG] Processing AssignmentStatement with 1 RHS expressions
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=27
[CSE DEBUG] Found expression: type=27 key='(EXPR)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=2
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 22
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=22
[CSE DEBUG] Found expression: type=22 key='(EXPR)' (FunctionCallExpr)
[CSE DEBUG] COUNTED expression: type=22 key='(EXPR)' count=3
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=28
[CSE DEBUG] Found expression: type=28 key='(EXPR)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=4
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 22
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=22
[CSE DEBUG] Found expression: type=22 key='(EXPR)' (FunctionCallExpr)
[CSE DEBUG] COUNTED expression: type=22 key='(EXPR)' count=5
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=28
[CSE DEBUG] Found expression: type=28 key='(EXPR)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=6
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=7
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 2 arguments
[CSE DEBUG]   Argument 0 type: 11
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=11
[CSE DEBUG] Found expression: type=11 key='(INT 100)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG]   Argument 1 type: 11
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=11
[CSE DEBUG] Found expression: type=11 key='(INT 200)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=8
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 22
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=22
[CSE DEBUG] Found expression: type=22 key='(EXPR)' (FunctionCallExpr)
[CSE DEBUG] COUNTED expression: type=22 key='(EXPR)' count=9
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=28
[CSE DEBUG] Found expression: type=28 key='(EXPR)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=10
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 22
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=22
[CSE DEBUG] Found expression: type=22 key='(EXPR)' (FunctionCallExpr)
[CSE DEBUG] COUNTED expression: type=22 key='(EXPR)' count=11
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=28
[CSE DEBUG] Found expression: type=28 key='(EXPR)' (Other)
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=44
[CSE DEBUG] Processing RoutineCallStatement with 1 arguments
[CSE DEBUG]   Argument 0 type: 12
[CSE DEBUG] count_subexpressions: ENTRY
[CSE DEBUG] count_subexpressions: examining node type=12
[CSE DEBUG] Found expression: type=12 key='(EXPR)' (StringLit)
[CSE DEBUG] COUNTED expression: type=12 key='(EXPR)' count=12
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] count_subexpressions: EXIT
[CSE DEBUG] Expression counts after analysis:
[CSE DEBUG]   '(EXPR)' appears 12 times
[CSE DEBUG] TRANSFORMATION: Optimizing routine START
[CSE DEBUG] TRANSFORMATION: Starting optimization of statement list with 14 statements
[CSE DEBUG] TRANSFORMATION: Processing statement 0
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x10388d3d0
[CSE DEBUG] TRANSFORMATION: Processing statement 1
[CSE DEBUG] Processing expression: type=27 key='(EXPR)' ptr=0x84901a8e0
[CSE DEBUG] TRANSFORMATION: Processing statement 2
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x10388d540
[CSE DEBUG] TRANSFORMATION: Processing statement 3
[CSE DEBUG] Processing expression: type=22 key='(EXPR)' ptr=0x10388d5c0
[CSE DEBUG] Creating new temp var for common subexpression (count=12)
[CSE DEBUG] Replacing expression (old ptr=0x10388d5c0)
[CSE DEBUG] Replacement complete (new ptr=0x8490244c0)
[CSE DEBUG] TRANSFORMATION: Processing statement 5
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x10388d600
[CSE DEBUG] TRANSFORMATION: Processing statement 6
[CSE DEBUG] Processing expression: type=22 key='(EXPR)' ptr=0x10388d670
[CSE DEBUG] Creating new temp var for common subexpression (count=12)
[CSE DEBUG] Found available expression, replacing with temp var: _cse_temp_0 (old ptr=0x10388d670)
[CSE DEBUG] Replacement complete (new ptr=0x849024500)
[CSE DEBUG] TRANSFORMATION: Processing statement 7
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x10388d6b0
[CSE DEBUG] TRANSFORMATION: Processing statement 8
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x849028000
[CSE DEBUG] TRANSFORMATION: Processing statement 9
[CSE DEBUG] Processing expression: type=11 key='(INT 100)' ptr=0x849020000
[CSE DEBUG] Processing expression: type=11 key='(INT 200)' ptr=0x849020080
[CSE DEBUG] TRANSFORMATION: Processing statement 10
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x849028060
[CSE DEBUG] TRANSFORMATION: Processing statement 11
[CSE DEBUG] Processing expression: type=22 key='(EXPR)' ptr=0x10388d7d0
[CSE DEBUG] Creating new temp var for common subexpression (count=12)
[CSE DEBUG] Found available expression, replacing with temp var: _cse_temp_0 (old ptr=0x10388d7d0)
[CSE DEBUG] Replacement complete (new ptr=0x849024240)
[CSE DEBUG] TRANSFORMATION: Processing statement 12
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x8490280c0
[CSE DEBUG] TRANSFORMATION: Processing statement 13
[CSE DEBUG] Processing expression: type=22 key='(EXPR)' ptr=0x10388d830
[CSE DEBUG] Creating new temp var for common subexpression (count=12)
[CSE DEBUG] Found available expression, replacing with temp var: _cse_temp_0 (old ptr=0x10388d830)
[CSE DEBUG] Replacement complete (new ptr=0x849024380)
[CSE DEBUG] TRANSFORMATION: Processing statement 14
[CSE DEBUG] Processing expression: type=12 key='(EXPR)' ptr=0x849028120
[CSE DEBUG] TRANSFORMATION: Finished optimization of statement list
[CSE DEBUG] LocalOptimizationPass::run() completed
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting ClassDeclaration: Point
[CreateMethodReorderPass] Visiting RoutineDeclaration: CREATE
[CreateMethodReorderPass] Found CREATE method in class Point
[CreateMethodReorderPass] Analyzing CREATE method body (BlockStatement)...
[CreateMethodReorderPass] Analyzing BlockStatement body with 7 statements
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: x
[CreateMethodReorderPass] Variable x is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 0
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Found AssignmentStatement
[CreateMethodReorderPass] Found VariableAccess: y
[CreateMethodReorderPass] Variable y is a member variable - treating as _this member assignment
[CreateMethodReorderPass] Found _this assignment at index 1
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] Checking if statement is _this member assignment...
[CreateMethodReorderPass] Statement is not an AssignmentStatement
[CreateMethodReorderPass] Checking if statement is SUPER.CREATE call...
[CreateMethodReorderPass] Found RoutineCallStatement
[CreateMethodReorderPass] RoutineCall is not a SUPER call
[CreateMethodReorderPass] No reordering needed - missing _this assignments or SUPER.CREATE calls
[CreateMethodReorderPass] No reordering needed for CREATE method in class Point
[CreateMethodReorderPass] Visiting RoutineDeclaration: set
[CreateMethodReorderPass] Visiting RoutineDeclaration: RELEASE
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found ClassDecl at index 0
[CFGBuilderPass] Processing class: Point
[CFGBuilderPass] Found routine method 'CREATE' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::CREATE
[CFGBuilderPass] Creating CFG for routine: Point::CREATE
[CFGBuilderPass] Created CFG for routine: Point::CREATE
[CFGBuilderPass] Created new basic block: Point::CREATE_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::CREATE (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Created new basic block: Point::CREATE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found function method 'getX' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::getX
[CFGBuilderPass] visit(FunctionDeclaration) for function: Point::getX
[CFGBuilderPass] Created CFG for function: Point::getX
[CFGBuilderPass] Created new basic block: Point::getX_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::getX (leaf)
[CFGBuilderPass] Starting optimized block 2 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: Point::getX_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getX
[CFGBuilderPass] Found function method 'getY' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::getY
[CFGBuilderPass] visit(FunctionDeclaration) for function: Point::getY
[CFGBuilderPass] Created CFG for function: Point::getY
[CFGBuilderPass] Created new basic block: Point::getY_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::getY (leaf)
[CFGBuilderPass] Starting optimized block 3 variable tracking
[CFGBuilderPass] SAMM: Visiting ResultisStatement - SAMM disabled, no scope exit call injected.
[CFGBuilderPass] Visiting ResultisStatement - injecting scope cleanup.
[CFGBuilderPass] Created new basic block: Point::getY_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(FunctionDeclaration) complete for function: getY
[CFGBuilderPass] Found routine method 'set' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::set
[CFGBuilderPass] Creating CFG for routine: Point::set
[CFGBuilderPass] Created CFG for routine: Point::set
[CFGBuilderPass] Created new basic block: Point::set_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: Point::set (call tree)
[CFGBuilderPass] Starting optimized block 4 variable tracking
[CFGBuilderPass] Created new basic block: Point::set_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Found routine method 'RELEASE' in class 'Point'
[CFGBuilderPass] Using qualified name for method: Point::RELEASE
[CFGBuilderPass] Creating CFG for routine: Point::RELEASE
[CFGBuilderPass] Created CFG for routine: Point::RELEASE
[CFGBuilderPass] Created new basic block: Point::RELEASE_Entry_0
[CFGBuilderPass] Created new basic block: Point::RELEASE_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] Processing declaration #1
[CFGBuilderPass] Found RoutineDecl at index 1
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[CFGBuilderPass] SAMM: Injecting HeapManager_enter_scope() call at block start
[ANALYZER DEBUG] Registered call site at instruction 64 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_enter_scope call site at instruction 64 for function 'START'
[CFGBuilderPass] Starting block 5 variable tracking
[CFGBuilderPass] Tracking variable 'p' in current block
[CFGBuilderPass] Generating normal block-end cleanup for 1 variables
[CFGBuilderPass] Generating block-end cleanup for: p
[CFGBuilderPass] Skipping legacy cleanup for p - SAMM is active
[CFGBuilderPass] SAMM: Injecting HeapManager_exit_scope() call for normal block exit
[ANALYZER DEBUG] Registered call site at instruction 65 for function 'START'
[CFGBuilderPass] CFGBuilderPass: Registered HeapManager_exit_scope call site at instruction 65 for function 'START'
[CFGBuilderPass] Created new basic block: START_Exit_1
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] CFG found for: Point::getY
[CFGBuilderPass] CFG found for: Point::RELEASE
[CFGBuilderPass] CFG found for: Point::getX
[CFGBuilderPass] CFG found for: Point::set
[CFGBuilderPass] CFG found for: Point::CREATE
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::getY
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::RELEASE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::getX
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::set
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations
[CFGSimplificationPass] Processing function: Point::CREATE
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]   Simplification completed after 1 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 6
  Blocks eliminated: 0
  Edges redirected: 0
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 17 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: _cse_temp_0 
[LivenessAnalysisPass] Variables used after call: _cse_temp_0 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Intra-block call interval detected in START_Entry_0 - variables live across calls: _cse_temp_0 
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] CFG #2 for function 'Point::getY' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::getY_Exit_1) in function 'Point::getY'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getY_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::getY_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getY_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::getY_Entry_0) in function 'Point::getY'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getY_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::getY_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getY_Entry_0
[LivenessAnalysisPass] CFG #3 for function 'Point::RELEASE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::RELEASE_Exit_1) in function 'Point::RELEASE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::RELEASE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::RELEASE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::RELEASE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::RELEASE_Entry_0) in function 'Point::RELEASE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::RELEASE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::RELEASE_Entry_0 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::RELEASE_Entry_0
[LivenessAnalysisPass] CFG #4 for function 'Point::getX' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::getX_Exit_1) in function 'Point::getX'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getX_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::getX_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getX_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::getX_Entry_0) in function 'Point::getX'
[LivenessAnalysisPass] Entering analyze_block for block: Point::getX_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::getX_Entry_0 with 1 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::getX_Entry_0
[LivenessAnalysisPass] CFG #5 for function 'Point::set' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::set_Exit_1) in function 'Point::set'
[LivenessAnalysisPass] Entering analyze_block for block: Point::set_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::set_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::set_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::set_Entry_0) in function 'Point::set'
[LivenessAnalysisPass] Entering analyze_block for block: Point::set_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::set_Entry_0 with 7 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: newY 
[LivenessAnalysisPass] Variables used after call: newY 
[LivenessAnalysisPass] Statement uses variables: newX 
[LivenessAnalysisPass] Variables used after call: newX 
[LivenessAnalysisPass] Intra-block call interval detected in Point::set_Entry_0 - variables live across calls: newX newY 
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::set_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: Point::set_Entry_0
[LivenessAnalysisPass] CFG #6 for function 'Point::CREATE' has 2 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=Point::CREATE_Exit_1) in function 'Point::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::CREATE_Exit_1
[LivenessAnalysisPass] Starting intra-block analysis for Point::CREATE_Exit_1 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: Point::CREATE_Exit_1
[LivenessAnalysisPass] Analyzing block #2 (id=Point::CREATE_Entry_0) in function 'Point::CREATE'
[LivenessAnalysisPass] Entering analyze_block for block: Point::CREATE_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for Point::CREATE_Entry_0 with 7 statements
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Found call in statement
[LivenessAnalysisPass] Statement uses variables: initialY 
[LivenessAnalysisPass] Variables used after call: initialY 
[LivenessAnalysisPass] Statement uses variables: initialX 
[LivenessAnalysisPass] Variables used after call: initialX 
[LivenessAnalysisPass] Intra-block call interval detected in Point::CREATE_Entry_0 - variables live across calls: initialX initialY 
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block Point::CREATE_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: Point::CREATE_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getY_Exit_1 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::getY_Entry_0 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::RELEASE_Exit_1 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::RELEASE_Entry_0 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::getX_Exit_1 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::getX_Entry_0 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::set_Exit_1 in function: Point::set
[LivenessAnalysisPass] Processing block: Point::set_Entry_0 in function: Point::set
[LivenessAnalysisPass] Applying call interval fix to block Point::set_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::CREATE_Exit_1 in function: Point::CREATE
[LivenessAnalysisPass] Processing block: Point::CREATE_Entry_0 in function: Point::CREATE
[LivenessAnalysisPass] Applying call interval fix to block Point::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_1 in function: START
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::getY_Exit_1 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::getY_Entry_0 in function: Point::getY
[LivenessAnalysisPass] Processing block: Point::RELEASE_Exit_1 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::RELEASE_Entry_0 in function: Point::RELEASE
[LivenessAnalysisPass] Processing block: Point::getX_Exit_1 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::getX_Entry_0 in function: Point::getX
[LivenessAnalysisPass] Processing block: Point::set_Exit_1 in function: Point::set
[LivenessAnalysisPass] Processing block: Point::set_Entry_0 in function: Point::set
[LivenessAnalysisPass] Applying call interval fix to block Point::set_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: Point::CREATE_Exit_1 in function: Point::CREATE
[LivenessAnalysisPass] Processing block: Point::CREATE_Entry_0 in function: Point::CREATE
[LivenessAnalysisPass] Applying call interval fix to block Point::CREATE_Entry_0 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Entry_0
  Use: { _cse_temp_0 }
  Def: { _cse_temp_0 p }
  In : { _cse_temp_0 }
  Out: { }

Liveness Analysis for function: Point::getY
-------------------------------------------
Block ID: Point::getY_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::getY_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::RELEASE
-------------------------------------------
Block ID: Point::RELEASE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::RELEASE_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::getX
-------------------------------------------
Block ID: Point::getX_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::getX_Entry_0
  Use: { }
  Def: { }
  In : { }
  Out: { }

Liveness Analysis for function: Point::set
-------------------------------------------
Block ID: Point::set_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::set_Entry_0
  Use: { newX newY }
  Def: { x y }
  In : { newX newY }
  Out: { }

Liveness Analysis for function: Point::CREATE
-------------------------------------------
Block ID: Point::CREATE_Exit_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: Point::CREATE_Entry_0
  Use: { initialX initialY }
  Def: { x y }
  In : { initialX initialY }
  Out: { }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_1 (conceptual)

Block ID: START_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::getY
----------------------------------------
Entry Block: Point::getY_Entry_0
Exit Block: Point::getY_Exit_1 (conceptual)

Block ID: Point::getY_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::getY_Entry_0

Block ID: Point::getY_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: Point::getY_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::RELEASE
----------------------------------------
Entry Block: Point::RELEASE_Entry_0
Exit Block: Point::RELEASE_Exit_1 (conceptual)

Block ID: Point::RELEASE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::RELEASE_Entry_0

Block ID: Point::RELEASE_Entry_0 (Entry)
  Statements:
    (empty)
  Successors: Point::RELEASE_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::getX
----------------------------------------
Entry Block: Point::getX_Entry_0
Exit Block: Point::getX_Exit_1 (conceptual)

Block ID: Point::getX_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::getX_Entry_0

Block ID: Point::getX_Entry_0 (Entry)
  Statements:
    - ResultisStmt
  Successors: Point::getX_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::set
----------------------------------------
Entry Block: Point::set_Entry_0
Exit Block: Point::set_Exit_1 (conceptual)

Block ID: Point::set_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::set_Entry_0

Block ID: Point::set_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: Point::set_Exit_1
  Predecessors: (none)
----------------------------------------

CFG for function: Point::CREATE
----------------------------------------
Entry Block: Point::CREATE_Entry_0
Exit Block: Point::CREATE_Exit_1 (conceptual)

Block ID: Point::CREATE_Exit_1 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: Point::CREATE_Entry_0

Block ID: Point::CREATE_Entry_0 (Entry)
  Statements:
    - AssignmentStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: Point::CREATE_Exit_1
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    ClassDeclaration: Point
      Members:
        LetDeclaration:
          Name: x
          Name: y
        RoutineDeclaration: CREATE
          Parameters: _this initialX initialY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: initialX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: initialY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point created at ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        FunctionDeclaration: getX
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: x
        FunctionDeclaration: getY
          Parameters: _this 
          Body:
            ValofExpression:
              BlockStatement:
                Statements:
                  ResultisStatement:
                    VariableAccess: y
        RoutineDeclaration: set
          Parameters: _this newX newY 
          Body:
            BlockStatement:
              Statements:
                AssignmentStatement:
                  LHS:
                    VariableAccess: x
                  RHS:
                    VariableAccess: newX
                AssignmentStatement:
                  LHS:
                    VariableAccess: y
                  RHS:
                    VariableAccess: newY
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Point moved to ("
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: x
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", "
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: y
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ")
"
        RoutineDeclaration: RELEASE
          Parameters: _this 
          Body:
            CompoundStatement:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Creating point...
"
            AssignmentStatement:
              LHS:
                VariableAccess: p
              RHS:
                NewExpression: Point
                  Arguments:
                    NumberLiteral: 50
                    NumberLiteral: 75
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Reading values: x="
            AssignmentStatement:
              LHS:
                VariableAccess: _cse_temp_0
              RHS:
                FunctionCall:
                  Callee:
                    MemberAccess: getX
                      Object:
                        VariableAccess: p
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  VariableAccess: _cse_temp_0
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: ", y="
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITEN
                Arguments:
                  VariableAccess: _cse_temp_0
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "

"
              RoutineCallStatement:
                Callee:
                  VariableAccess: WRITES
                Arguments:
                  StringLiteral: "Setting new values...
"
              RoutineCallStatement:
                Callee:
                  MemberAccess: set
                    Object:
                      VariableAccess: p
                  Arguments:
                    NumberLiteral: 100
                    NumberLiteral: 200
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "Reading new values: x="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: _cse_temp_0
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: ", y="
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITEN
                  Arguments:
                    VariableAccess: _cse_temp_0
                RoutineCallStatement:
                  Callee:
                    VariableAccess: WRITES
                  Arguments:
                    StringLiteral: "
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[LiveIntervalPass] Created 2 intervals for function: START
  _cse_temp_0: [0-14]
  p: [2-4]
[LiveIntervalPass] Building intervals for function: Point::getY
[LiveIntervalPass] Injected _this interval for class method: Point::getY [0-3]
[LiveIntervalPass] Created 1 intervals for function: Point::getY
  _this: [0-3]
[LiveIntervalPass] Building intervals for function: Point::RELEASE
[LiveIntervalPass] Injected _this interval for class method: Point::RELEASE [0-2]
[LiveIntervalPass] Created 1 intervals for function: Point::RELEASE
  _this: [0-2]
[LiveIntervalPass] Building intervals for function: Point::getX
[LiveIntervalPass] Injected _this interval for class method: Point::getX [0-3]
[LiveIntervalPass] Created 1 intervals for function: Point::getX
  _this: [0-3]
[LiveIntervalPass] Building intervals for function: Point::set
[LiveIntervalPass] Injected _this interval for class method: Point::set [0-9]
[LiveIntervalPass] Created 3 intervals for function: Point::set
  _this: [0-9]
  newX: [0-0]
  newY: [0-1]
[LiveIntervalPass] Building intervals for function: Point::CREATE
[LiveIntervalPass] Injected _this interval for class method: Point::CREATE [0-9]
[LiveIntervalPass] Created 3 intervals for function: Point::CREATE
  _this: [0-9]
  initialX: [0-0]
  initialY: [0-1]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 18 call sites at: 0 4 8 9 15 19 20 26 30 38 42 43 49 53 54 60 64 65 
[Allocator] Partitioned: 2 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _cse_temp_0 [0-14]
  Assigned callee-saved register X27 to _cse_temp_0
[ALLOC] Updated allocations for _cse_temp_0: spilled=0, register='X27'
[Allocator] Allocating call-crossing p [2-4]
  Assigned callee-saved register X26 to p
[ALLOC] Updated allocations for p: spilled=0, register='X26'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 2
  Free integer registers: 11
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _cse_temp_0: reg X27 (callee-saved) [call-crossing]
  p: reg X26 (callee-saved) [call-crossing]
[Allocator] Starting partitioned linear scan for function: Point::getY
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for Point::getY
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::RELEASE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-2]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for Point::RELEASE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::getX
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 0 call sites at: 
[Allocator] Partitioned: 0 call-crossing, 1 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Allocating local-only _this [0-3]
  Assigned register X15 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X15'
[Allocator] Partitioned allocation complete for Point::getX
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 1
  Free integer registers: 12
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X15 (caller-saved) [local-only]
[Allocator] Starting partitioned linear scan for function: Point::set
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 4 8 12 16 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-9]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Allocating call-crossing newX [0-0]
  Assigned callee-saved register X26 to newX
[ALLOC] Updated allocations for newX: spilled=0, register='X26'
[Allocator] Allocating call-crossing newY [0-1]
  Assigned callee-saved register X25 to newY
[ALLOC] Updated allocations for newY: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for Point::set
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
  newX: reg X26 (callee-saved) [call-crossing]
  newY: reg X25 (callee-saved) [call-crossing]
[Allocator] Starting partitioned linear scan for function: Point::CREATE
[Allocator] Available integer registers: 16, float registers: 24
[Allocator] Function has 5 call sites at: 0 4 8 12 16 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 4, Reserved scratch INT: 3
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 16
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing _this [0-9]
  Assigned callee-saved register X27 to _this
[ALLOC] Updated allocations for _this: spilled=0, register='X27'
[Allocator] Allocating call-crossing initialX [0-0]
  Assigned callee-saved register X26 to initialX
[ALLOC] Updated allocations for initialX: spilled=0, register='X26'
[Allocator] Allocating call-crossing initialY [0-1]
  Assigned callee-saved register X25 to initialY
[ALLOC] Updated allocations for initialY: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for Point::CREATE
[Allocator] Reserved 3 scratch registers for code generation: X9 X10 X11 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 10
  Free float registers: 24
  ✓ No register conflicts detected
[Allocator] Results:
  _this: reg X27 (callee-saved) [call-crossing]
  initialX: reg X26 (callee-saved) [call-crossing]
  initialY: reg X25 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: Point::CREATE
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 2
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::RELEASE
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getX
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::getY
  Type: int
  Parameters: 1
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 0
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: no
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: Point::set
  Type: int
  Parameters: 3
  Integer Locals: 0
  Float Locals: 0
  Runtime Calls: 5
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 2
  Required Callee-Saved Temps: 0
--------------------------------------------
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 3
  Float Locals: 0
  Runtime Calls: 12
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 1
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4426498048
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 2 unique external functions:
[DEBUG]   - WRITEN
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] Generating 4 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: WRITEN_veneer for function: WRITEN
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 4 veneers, estimated total size: 80 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Visiting ClassDeclaration for 'Point'. Setting class context.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: CREATE).
[DEBUG] Using qualified name for method: Point::CREATE
[DEBUG] Name 'Point::CREATE' is already qualified. Using unqualified part 'CREATE' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::CREATE
[DEBUG] DEBUG: generate_function_like_code called for: Point::CREATE
[DEBUG] Generating function-like code for: Point::CREATE
[DEBUG] Clearing local value tracking for function: Point::CREATE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: CREATE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: CREATE
[DEBUG] Using name as-is for lookup: Point::CREATE
[DEBUG] Generating code for method. Using mangled label from symbol: Point::CREATE
Call Frame Layout for function: Point::CREATE
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::CREATE')
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::CREATE')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::CREATE'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::CREATE': 3
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['initialX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['initialY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialX' type from metrics: UNKNOWN
Added local variable 'initialX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'initialY' type from metrics: UNKNOWN
Added local variable 'initialY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::CREATE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'initialX' to CallFrameManager locals.
[DEBUG] Added parameter 'initialY' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::CREATE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::CREATE'.
--- Call Frame Layout for function: Point::CREATE (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X25                        | UNKNOWN
+64      | Saved Reg: X26                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #56] ; Saved Reg: X25 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #64] ; Saved Reg: X26 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG]   Moving 'initialX' from arg reg X1 to home reg X26.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X1    // Move parameter 'initialX' from X1 to X26
[DEBUG]   Moving 'initialY' from arg reg X2 to home reg X25.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X2    // Move parameter 'initialY' from X2 to X25
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::CREATE (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: initialX                       | UNKNOWN
+32      | Local: initialY                       | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X25                        | UNKNOWN
+64      | Saved Reg: X26                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::CREATE
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialX' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'initialX' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialX' lives in register X26
[DEBUG] Variable 'initialX' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Registering canonical address: x = VARIABLE:initialX
[DEBUG] Registered canonical address: x = VARIABLE:initialX
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: x
[DEBUG] Handling assignment for class member: x
[DEBUG] Member variable 'x' found in class 'Point' with offset 8
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X27, #8] ; Store to member x
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'initialY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'initialY' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'initialY' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'initialY' lives in register X25
[DEBUG] Variable 'initialY' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] Registering canonical address: y = VARIABLE:initialY
[DEBUG] Registered canonical address: y = VARIABLE:initialY
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: y
[DEBUG] Handling assignment for class member: y
[DEBUG] Member variable 'y' found in class 'Point' with offset 16
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X27, #16] ; Store to member y
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Point created at ('.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'x' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'Point::CREATE'
[DEBUG] get_variable_register for: 'y' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::CREATE')
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::CREATE'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ')
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B Point::CREATE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L0
[DEBUG] Performing end-of-function scope cleanup for 'Point::CREATE'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'Point::CREATE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getX).
[DEBUG] Function metrics for getX not found.
[DEBUG] Using qualified name for method: Point::getX
[DEBUG] Name 'Point::getX' is already qualified. Using unqualified part 'getX' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::getX
[DEBUG] DEBUG: generate_function_like_code called for: Point::getX
[DEBUG] Generating function-like code for: Point::getX
[DEBUG] Clearing local value tracking for function: Point::getX
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getX
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getX
[DEBUG] Using name as-is for lookup: Point::getX
[DEBUG] Generating code for method. Using mangled label from symbol: Point::getX
[DEBUG] ✅ Detected TRIVIAL ACCESSOR method: 'Point::getX'. Generating optimized code.
[DEBUG LEVEL 5] Emitting instruction: LDR X0, [X0, #8] ; Optimized accessor load (int/ptr)
[DEBUG LEVEL 5] Emitting instruction: RET
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] Visiting FunctionDeclaration node (Name: getY).
[DEBUG] Function metrics for getY not found.
[DEBUG] Using qualified name for method: Point::getY
[DEBUG] Name 'Point::getY' is already qualified. Using unqualified part 'getY' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::getY
[DEBUG] DEBUG: generate_function_like_code called for: Point::getY
[DEBUG] Generating function-like code for: Point::getY
[DEBUG] Clearing local value tracking for function: Point::getY
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: getY
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: getY
[DEBUG] Using name as-is for lookup: Point::getY
[DEBUG] Generating code for method. Using mangled label from symbol: Point::getY
[DEBUG] ✅ Detected TRIVIAL ACCESSOR method: 'Point::getY'. Generating optimized code.
[DEBUG LEVEL 5] Emitting instruction: LDR X0, [X0, #16] ; Optimized accessor load (int/ptr)
[DEBUG LEVEL 5] Emitting instruction: RET
[DEBUG] Finished visiting FunctionDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: set).
[DEBUG] Using qualified name for method: Point::set
[DEBUG] Name 'Point::set' is already qualified. Using unqualified part 'set' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::set
[DEBUG] DEBUG: generate_function_like_code called for: Point::set
[DEBUG] Generating function-like code for: Point::set
[DEBUG] Clearing local value tracking for function: Point::set
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: set
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: set
[DEBUG] Using name as-is for lookup: Point::set
[DEBUG] Generating code for method. Using mangled label from symbol: Point::set
Call Frame Layout for function: Point::set
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::set')
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::set')
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::set'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::set': 3
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: variable_types['newX'] = UNKNOWN
[DEBUG] DEBUG: variable_types['newY'] = UNKNOWN
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'newX' type from metrics: UNKNOWN
Added local variable 'newX' of type 0 at offset 24 (size 8)
[DEBUG] Added parameter 'newX' to CallFrameManager locals.
[DEBUG] DEBUG: Parameter 'newY' type from metrics: UNKNOWN
Added local variable 'newY' of type 0 at offset 32 (size 8)
[DEBUG] Added parameter 'newY' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::set'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Added parameter 'newX' to CallFrameManager locals.
[DEBUG] Added parameter 'newY' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::set'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::set'.
--- Call Frame Layout for function: Point::set (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: newX                           | UNKNOWN
+32      | Local: newY                           | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X25                        | UNKNOWN
+64      | Saved Reg: X26                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #56] ; Saved Reg: X25 @ FP+56
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #64] ; Saved Reg: X26 @ FP+64
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X27.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0    // Move parameter '_this' from X0 to X27
[DEBUG]   Moving 'newX' from arg reg X1 to home reg X26.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X1    // Move parameter 'newX' from X1 to X26
[DEBUG]   Moving 'newY' from arg reg X2 to home reg X25.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X2    // Move parameter 'newY' from X2 to X25
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::set (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Local: newX                           | UNKNOWN
+32      | Local: newY                           | UNKNOWN
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X25                        | UNKNOWN
+64      | Saved Reg: X26                        | UNKNOWN
+72      | Saved Reg: X27                        | UNKNOWN
+80      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::set
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'newX'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'newX' in function 'Point::set'
[DEBUG] get_variable_register for: 'newX' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'newX' lives in register X26
[DEBUG] Variable 'newX' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Registering canonical address: x = VARIABLE:newX
[DEBUG] Registered canonical address: x = VARIABLE:newX
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: x
[DEBUG] Handling assignment for class member: x
[DEBUG] Member variable 'x' found in class 'Point' with offset 8
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X27, #8] ; Store to member x
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting VariableAccess node for 'newY'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'newY' in function 'Point::set'
[DEBUG] get_variable_register for: 'newY' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'newY' lives in register X25
[DEBUG] Variable 'newY' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] Registering canonical address: y = VARIABLE:newY
[DEBUG] Registered canonical address: y = VARIABLE:newY
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: y
[DEBUG] Handling assignment for class member: y
[DEBUG] Member variable 'y' found in class 'Point' with offset 16
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X27, #16] ; Store to member y
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Point moved to ('.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'x'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'x' in function 'Point::set'
[DEBUG] get_variable_register for: 'x' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'x' in different context 'Point' (requested context was 'Point::set')
[DEBUG]   ✅ CLASS MEMBER: Variable 'x' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 8 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #8] ; x
[DEBUG] Generated LDR for class member x at offset 8
[DEBUG] Variable 'x' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'y'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'y' in function 'Point::set'
[DEBUG] get_variable_register for: 'y' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[SYMBOL TABLE TRACE] Warning: Found symbol 'y' in different context 'Point' (requested context was 'Point::set')
[DEBUG]   ✅ CLASS MEMBER: Variable 'y' is a class member. Generating member access via _this.
[DEBUG] get_variable_register for: '_this' in function 'Point::set'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_this' lives in register X27
[DEBUG]   Member offset: 16 bytes
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X27, #16] ; y
[DEBUG] Generated LDR for class member y at offset 16
[DEBUG] Variable 'y' value loaded into X9
[DEBUG]   [DEBUG] get_variable_register returned: 'X9'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=INTEGER expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ')
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B Point::set_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L3
[DEBUG] Performing end-of-function scope cleanup for 'Point::set'.
[DEBUG] Defining epilogue label: .L3
[DEBUG] Attempting to generate epilogue for 'Point::set'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: RELEASE).
[DEBUG] Using qualified name for method: Point::RELEASE
[DEBUG] Name 'Point::RELEASE' is already qualified. Using unqualified part 'RELEASE' for scope.
[DEBUG] Using name as-is for metrics lookup: Point::RELEASE
[DEBUG] DEBUG: generate_function_like_code called for: Point::RELEASE
[DEBUG] Generating function-like code for: Point::RELEASE
[DEBUG] Clearing local value tracking for function: Point::RELEASE
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] No allocations found for function: RELEASE
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: RELEASE
[DEBUG] Using name as-is for lookup: Point::RELEASE
[DEBUG] Generating code for method. Using mangled label from symbol: Point::RELEASE
Call Frame Layout for function: Point::RELEASE
[DEBUG] Registering all parameters as locals in CallFrameManager for 'Point::RELEASE'.
[DEBUG] DEBUG: metrics.variable_types size for 'Point::RELEASE': 1
[DEBUG] DEBUG: variable_types['_this'] = POINTER_TO|OBJECT
[DEBUG] DEBUG: Parameter '_this' type from metrics: POINTER_TO|OBJECT
Added local variable '_this' of type 1056768 at offset 16 (size 8)
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'Point::RELEASE'.
[DEBUG] Added parameter '_this' to CallFrameManager locals.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'Point::RELEASE'.
[DEBUG] No spills needed - all variables fit in registers.
Added X19 to callee_saved_registers_to_save list.
Added X28 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'Point::RELEASE'.
--- Call Frame Layout for function: Point::RELEASE (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-48]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG]   Moving '_this' from arg reg X0 to home reg X15.
[DEBUG LEVEL 5] Emitting instruction: MOV X15, X0    // Move parameter '_this' from X0 to X15
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: Point::RELEASE (Total Size: 48 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _this                          | POINTER_TO|OBJECT
+24      | Saved Reg: X19                        | UNKNOWN
+32      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+48 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: Point::RELEASE
[DEBUG LEVEL 5] Emitting instruction: B Point::RELEASE_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L4
[DEBUG] Performing end-of-function scope cleanup for 'Point::RELEASE'.
[DEBUG] Defining epilogue label: .L4
[DEBUG] Attempting to generate epilogue for 'Point::RELEASE'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Finished with ClassDeclaration for 'Point'. Restoring context.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Syncing RegisterManager with LinearScanAllocator for function: START
[SYNC] Found 2 variable allocations
[SYNC] Reserved register X27 for variable _cse_temp_0
[SYNC] Reserved register X26 for variable p
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 2
[DEBUG] DEBUG: variable_types['_cse_temp_0'] = UNKNOWN
[DEBUG] DEBUG: variable_types['p'] = POINTER_TO|OBJECT
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable '_cse_temp_0' of type 0 at offset 16 (size 8)
[DEBUG] Registered local '_cse_temp_0' from analyzer metrics.
Added local variable 'p' of type 1056768 at offset 24 (size 8)
[DEBUG] Registered local 'p' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _cse_temp_0                    | UNKNOWN
+24      | Local: p                              | POINTER_TO|OBJECT
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X26                        | UNKNOWN
+48      | Saved Reg: X27                        | UNKNOWN
+56      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-64]!
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #40] ; Saved Reg: X26 @ FP+40
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #48] ; Saved Reg: X27 @ FP+48
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #56] ; Saved Reg: X28 @ FP+56
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 64 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: _cse_temp_0                    | UNKNOWN
+24      | Local: p                              | POINTER_TO|OBJECT
+32      | Saved Reg: X19                        | UNKNOWN
+40      | Saved Reg: X26                        | UNKNOWN
+48      | Saved Reg: X27                        | UNKNOWN
+56      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+64 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG]   Available CFG: 'Point::getY'
[DEBUG]   Available CFG: 'Point::RELEASE'
[DEBUG]   Available CFG: 'Point::getX'
[DEBUG]   Available CFG: 'Point::set'
[DEBUG]   Available CFG: 'Point::CREATE'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_enter_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_enter_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Creating point...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting NewExpression node for class: Point
[DEBUG]   - Constructor arguments count: 2
[DEBUG]   - Assigned variable name: [empty]
[DEBUG LEVEL 5] Emitting instruction: BL OBJECT_HEAP_ALLOC
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X0
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, Point_vtable
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:Point_vtable
[DEBUG LEVEL 5] Emitting instruction: STR X9, [X20, #0] ; store vtable ptr
[DEBUG] Handling assignment for variable: p
[DEBUG] store_variable_register for 'p' from register 'X20'
[DEBUG]   [ALLOCATOR HIT] Variable 'p' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X20
[DEBUG]   Updating home register X26 for variable 'p' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X20
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str5
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str5
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG]   [CSE DEBUG] *** CSE-GENERATED ASSIGNMENT DETECTED: _cse_temp_0 ***
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X26
[DEBUG] Variable 'p' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: LDR X9, [X26, #0] ; Load vtable pointer
[DEBUG LEVEL 5] Emitting instruction: LDR X10, [X9, #16] ; Load method address
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[DEBUG LEVEL 5] Emitting instruction: BLR X10
[DEBUG] Handling assignment for variable: _cse_temp_0
[DEBUG] store_variable_register for '_cse_temp_0' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable '_cse_temp_0' lives in X27. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG]   Updating home register X27 for variable '_cse_temp_0' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str7
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str7
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '

'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str8
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str8
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Setting new values...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a method call to: set
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #100
[DEBUG] Loaded integer literal 100 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[DEBUG] Visiting NumberLiteral node.
[DEBUG LEVEL 5] Emitting instruction: MOVZ X9, #200
[DEBUG] Loaded integer literal 200 into X9 using MOVZ.
[DEBUG LEVEL 5] Emitting instruction: MOV X21, X9
[DEBUG] Visiting VariableAccess node for 'p'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'p' in function 'START'
[DEBUG] get_variable_register for: 'p' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'p' lives in register X26
[DEBUG] Variable 'p' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[DEBUG] Expression is a VariableAccess to: p
[DEBUG] Found symbol with class_name: Point
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X2, X21
[DEBUG LEVEL 5] Emitting instruction: BL Point::set
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str9
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str9
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal 'Reading new values: x='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str6
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal ', y='.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for '_cse_temp_0'.
[DEBUG]   [DEBUG] About to call get_variable_register for '_cse_temp_0' in function 'START'
[DEBUG]   [CSE DEBUG] *** PROCESSING CSE TEMP VARIABLE: _cse_temp_0 ***
[DEBUG] get_variable_register for: '_cse_temp_0' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable '_cse_temp_0' lives in register X27
[DEBUG] Variable '_cse_temp_0' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X27 expr_type=UNKNOWN expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X27
[DEBUG] Deferring release of source register: X27
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X27
[DEBUG] Executed MOV X0, X27
[DEBUG] Releasing source register: X27
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITEN_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #8
[DEBUG] Emitted ADRP/ADD sequence and offset adjustment for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'HeapManager_exit_scope'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 0
[DEBUG] Emitting 0 queued operations
[DEBUG] Final register usage: NGRN=0, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL HeapManager_exit_scope_veneer
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_1
[DEBUG LEVEL 5] Emitting instruction: B .L5
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L5
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_str5
[InstructionStream TRACE] Adding label definition: L_str6
[InstructionStream TRACE] Adding label definition: L_str7
[InstructionStream TRACE] Adding label definition: L_str8
[InstructionStream TRACE] Adding label definition: L_str9
[InstructionStream TRACE] Adding label definition: L_str10

[DataGenerator VTABLE] ===== Generating vtable in RODATA: Point_vtable =====
  Class: Point
  Vtable size: 5 method(s)
  Memory layout:
[InstructionStream TRACE] Adding label definition: Point_vtable
    [+0] Slot 0: Point::CREATE
    [+8] Slot 1: Point::RELEASE
    [+16] Slot 2: Point::getX
    [+24] Slot 3: Point::getY
    [+32] Slot 4: Point::set
  Total vtable size: 40 bytes
[DataGenerator VTABLE] ==========================================

[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Emitting string label: Reading new values: x= value: L_str9
Emitting string label: Setting new values...
 value: L_str8
Emitting string label: Reading values: x= value: L_str5
Emitting string label: 

 value: L_str7
Emitting string label: Point moved to ( value: L_str3
Emitting string label: Creating point...
 value: L_str4
Emitting string label: )
 value: L_str2
Emitting string label: ,  value: L_str1
Emitting string label: 
 value: L_str10
Emitting string label: , y= value: L_str6
Emitting string label: Point created at ( value: L_str0
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'x' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'y' (MEMBER_VAR, INTEGER, scope=0, block=0, class_name='', function_name='Point')
Symbol 'Point::CREATE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'initialY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::CREATE')
Symbol 'Point::getX' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getX')
Symbol 'Point::getY' (class: Point, FUNCTION, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::getY')
Symbol 'Point::set' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::set')
Symbol '_this' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newX' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'newY' (PARAMETER, UNKNOWN, scope=1, block=0, class_name='', function_name='Point::set')
Symbol 'Point::RELEASE' (class: Point, ROUTINE, INTEGER, scope=0, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_this' (PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='', function_name='Point::RELEASE')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'p' (class: Point, LOCAL_VAR, POINTER_TO|OBJECT, scope=2, block=0, class_name='Point', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::CREATE')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::getX')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::getY')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::set')
Symbol '_this' (class: Point, PARAMETER, POINTER_TO|OBJECT, scope=1, block=0, class_name='Point', function_name='Point::RELEASE')
Symbol '_cse_temp_0' (LOCAL_VAR, UNKNOWN, scope=0, block=0, class_name='', function_name='START')

Data sections generated.

=== Peephole Optimization ===
Analyzing 454 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 180
  Before:
    MOV X26, X20  [Opcode=1, Dest=26, Src1=20]
    MOV X26, X20  [Opcode=1, Dest=26, Src1=20]
  After:
    MOV X26, X20  [Opcode=1, Dest=26, Src1=20]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn)
  Position: 190
  Before:
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
  After:
    MOV X27, X0  [Opcode=1, Dest=27, Src1=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 454
  Instructions after:  452
  Total optimizations: 2
  Patterns matched:
    - Identical sequential move elimination (MOV Xd, Xn; MOV Xd, Xn): 2
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x107d70000) ---
Address Hex Code    Assembly
--------------------------------------------------
 107d70000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 107d70004 0xd2871f10  MOVZ X16, #14584
 107d70008 0xf2a05490  MOVK X16, #676, LSL #16
 107d7000c 0xf2c00030  MOVK X16, #1, LSL #32
 107d70010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 107d70014 0xd2872490  MOVZ X16, #14628
 107d70018 0xf2a05490  MOVK X16, #676, LSL #16
 107d7001c 0xf2c00030  MOVK X16, #1, LSL #32
 107d70020 0xd61f0200  BR X16
WRITEN_veneer:
 107d70024 0xd284da10  MOVZ X16, #9936
 107d70028 0xf2a056b0  MOVK X16, #693, LSL #16
 107d7002c 0xf2c00030  MOVK X16, #1, LSL #32
 107d70030 0xd61f0200  BR X16
WRITES_veneer:
 107d70034 0xd2837890  MOVZ X16, #7108
 107d70038 0xf2a056b0  MOVK X16, #693, LSL #16
 107d7003c 0xf2c00030  MOVK X16, #1, LSL #32
 107d70040 0xd61f0200  BR X16
 107d70044 0x00000000  ; --- End Veneer Section ---

Point::CREATE:
 107d70048 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 107d7004c 0x910003fd  MOV X29, SP
 107d70050 0xf90017b3  STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
 107d70054 0xf9001bb4  STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
 107d70058 0xf9001fb9  STR X25, [X29, #56] ; Saved Reg: X25 @ FP+56
 107d7005c 0xf90023ba  STR X26, [X29, #64] ; Saved Reg: X26 @ FP+64
 107d70060 0xf90027bb  STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
 107d70064 0xf9002bbc  STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
 107d70068 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 107d7006c 0xaa0103fa  MOV X26, X1    // Move parameter 'initialX' from X1 to X26
 107d70070 0xaa0203f9  MOV X25, X2    // Move parameter 'initialY' from X2 to X25
 107d70074 0xd280001c  MOVZ X28, #0
 107d70078 0xf2a0f8fc  MOVK X28, #1991, LSL #16
 107d7007c 0xf2c0003c  MOVK X28, #1, LSL #32
 107d70080 0xf2e0001c  MOVK X28, #0, LSL #48
Point::CREATE_Entry_0:
 107d70084 0xf900077a  STR X26, [X27, #8] ; Store to member x
 107d70088 0xf9000b79  STR X25, [X27, #16] ; Store to member y
 107d7008c 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x107d75000
 107d70090 0x91000129  ADD X9, X9, #:lo12:L_str0    ; Reloc -> 'L_str0' @ 0x107d75000
 107d70094 0x91002129  ADD X9, X9, #8
 107d70098 0xaa0903e0  MOV X0, X9
 107d7009c 0x97ffffe6  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d700a0 0xf9400769  LDR X9, [X27, #8] ; x
 107d700a4 0xaa0903e0  MOV X0, X9
 107d700a8 0x97ffffdf  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d700ac 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x107d75058
 107d700b0 0x91016129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x107d75058
 107d700b4 0x91002129  ADD X9, X9, #8
 107d700b8 0xaa0903e0  MOV X0, X9
 107d700bc 0x97ffffde  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d700c0 0xf9400b69  LDR X9, [X27, #16] ; y
 107d700c4 0xaa0903e0  MOV X0, X9
 107d700c8 0x97ffffd7  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d700cc 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x107d75070
 107d700d0 0x9101c129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x107d75070
 107d700d4 0x91002129  ADD X9, X9, #8
 107d700d8 0xaa0903e0  MOV X0, X9
 107d700dc 0x97ffffd6  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d700e0 0x14000001  B Point::CREATE_Exit_1    ; Reloc -> 'Point::CREATE_Exit_1' @ 0x107d700e4
Point::CREATE_Exit_1:
 107d700e4 0x14000001  B .L0    ; Reloc -> '.L0' @ 0x107d700e8
.L0:
 107d700e8 0xf94017b3  LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40
 107d700ec 0xf9401bb4  LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48
 107d700f0 0xf9401fb9  LDR X25, [X29, #56] ; Restored Reg: X25 @ FP+56
 107d700f4 0xf94023ba  LDR X26, [X29, #64] ; Restored Reg: X26 @ FP+64
 107d700f8 0xf94027bb  LDR X27, [X29, #72] ; Restored Reg: X27 @ FP+72
 107d700fc 0xf9402bbc  LDR X28, [X29, #80] ; Restored Reg: X28 @ FP+80
 107d70100 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 107d70104 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 107d70108 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 107d7010c 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 107d70110 0xd65f03c0  RET
Point::getX:
 107d70114 0xf9400400  LDR X0, [X0, #8] ; Optimized accessor load (int/ptr)
 107d70118 0xd65f03c0  RET
Point::getY:
 107d7011c 0xf9400800  LDR X0, [X0, #16] ; Optimized accessor load (int/ptr)
 107d70120 0xd65f03c0  RET
Point::set:
 107d70124 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 107d70128 0x910003fd  MOV X29, SP
 107d7012c 0xf90017b3  STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
 107d70130 0xf9001bb4  STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
 107d70134 0xf9001fb9  STR X25, [X29, #56] ; Saved Reg: X25 @ FP+56
 107d70138 0xf90023ba  STR X26, [X29, #64] ; Saved Reg: X26 @ FP+64
 107d7013c 0xf90027bb  STR X27, [X29, #72] ; Saved Reg: X27 @ FP+72
 107d70140 0xf9002bbc  STR X28, [X29, #80] ; Saved Reg: X28 @ FP+80
 107d70144 0xaa0003fb  MOV X27, X0    // Move parameter '_this' from X0 to X27
 107d70148 0xaa0103fa  MOV X26, X1    // Move parameter 'newX' from X1 to X26
 107d7014c 0xaa0203f9  MOV X25, X2    // Move parameter 'newY' from X2 to X25
 107d70150 0xd280001c  MOVZ X28, #0
 107d70154 0xf2a0f8fc  MOVK X28, #1991, LSL #16
 107d70158 0xf2c0003c  MOVK X28, #1, LSL #32
 107d7015c 0xf2e0001c  MOVK X28, #0, LSL #48
Point::set_Entry_0:
 107d70160 0xf900077a  STR X26, [X27, #8] ; Store to member x
 107d70164 0xf9000b79  STR X25, [X27, #16] ; Store to member y
 107d70168 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x107d75088
 107d7016c 0x91022129  ADD X9, X9, #:lo12:L_str3    ; Reloc -> 'L_str3' @ 0x107d75088
 107d70170 0x91002129  ADD X9, X9, #8
 107d70174 0xaa0903e0  MOV X0, X9
 107d70178 0x97ffffaf  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d7017c 0xf9400769  LDR X9, [X27, #8] ; x
 107d70180 0xaa0903e0  MOV X0, X9
 107d70184 0x97ffffa8  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d70188 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x107d75058
 107d7018c 0x91016129  ADD X9, X9, #:lo12:L_str1    ; Reloc -> 'L_str1' @ 0x107d75058
 107d70190 0x91002129  ADD X9, X9, #8
 107d70194 0xaa0903e0  MOV X0, X9
 107d70198 0x97ffffa7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d7019c 0xf9400b69  LDR X9, [X27, #16] ; y
 107d701a0 0xaa0903e0  MOV X0, X9
 107d701a4 0x97ffffa0  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d701a8 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x107d75070
 107d701ac 0x9101c129  ADD X9, X9, #:lo12:L_str2    ; Reloc -> 'L_str2' @ 0x107d75070
 107d701b0 0x91002129  ADD X9, X9, #8
 107d701b4 0xaa0903e0  MOV X0, X9
 107d701b8 0x97ffff9f  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d701bc 0x14000001  B Point::set_Exit_1    ; Reloc -> 'Point::set_Exit_1' @ 0x107d701c0
Point::set_Exit_1:
 107d701c0 0x14000001  B .L3    ; Reloc -> '.L3' @ 0x107d701c4
.L3:
 107d701c4 0xf94017b3  LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40
 107d701c8 0xf9401bb4  LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48
 107d701cc 0xf9401fb9  LDR X25, [X29, #56] ; Restored Reg: X25 @ FP+56
 107d701d0 0xf94023ba  LDR X26, [X29, #64] ; Restored Reg: X26 @ FP+64
 107d701d4 0xf94027bb  LDR X27, [X29, #72] ; Restored Reg: X27 @ FP+72
 107d701d8 0xf9402bbc  LDR X28, [X29, #80] ; Restored Reg: X28 @ FP+80
 107d701dc 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 107d701e0 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 107d701e4 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 107d701e8 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 107d701ec 0xd65f03c0  RET
Point::RELEASE:
 107d701f0 0xa9bd7bfd  STP X29, X30, [SP, #-48]!
 107d701f4 0x910003fd  MOV X29, SP
 107d701f8 0xf9000fb3  STR X19, [X29, #24] ; Saved Reg: X19 @ FP+24
 107d701fc 0xf90013bc  STR X28, [X29, #32] ; Saved Reg: X28 @ FP+32
 107d70200 0xaa0003ef  MOV X15, X0    // Move parameter '_this' from X0 to X15
Point::RELEASE_Entry_0:
 107d70204 0x14000001  B Point::RELEASE_Exit_1    ; Reloc -> 'Point::RELEASE_Exit_1' @ 0x107d70208
Point::RELEASE_Exit_1:
 107d70208 0x14000001  B .L4    ; Reloc -> '.L4' @ 0x107d7020c
.L4:
 107d7020c 0xf9400fb3  LDR X19, [X29, #24] ; Restored Reg: X19 @ FP+24
 107d70210 0xf94013bc  LDR X28, [X29, #32] ; Restored Reg: X28 @ FP+32
 107d70214 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 107d70218 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 107d7021c 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 107d70220 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 107d70224 0xd65f03c0  RET
START:
 107d70228 0xa9bc7bfd  STP X29, X30, [SP, #-64]!
 107d7022c 0x910003fd  MOV X29, SP
 107d70230 0xf90013b3  STR X19, [X29, #32] ; Saved Reg: X19 @ FP+32
 107d70234 0xf90017ba  STR X26, [X29, #40] ; Saved Reg: X26 @ FP+40
 107d70238 0xf9001bbb  STR X27, [X29, #48] ; Saved Reg: X27 @ FP+48
 107d7023c 0xf9001fbc  STR X28, [X29, #56] ; Saved Reg: X28 @ FP+56
 107d70240 0xd280001c  MOVZ X28, #0
 107d70244 0xf2a0f8fc  MOVK X28, #1991, LSL #16
 107d70248 0xf2c0003c  MOVK X28, #1, LSL #32
 107d7024c 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 107d70250 0x97ffff6d  BL HeapManager_enter_scope_veneer    ; Reloc -> 'HeapManager_enter_scope_veneer' @ 0x107d70004
 107d70254 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x107d750d8
 107d70258 0x91036129  ADD X9, X9, #:lo12:L_str4    ; Reloc -> 'L_str4' @ 0x107d750d8
 107d7025c 0x91002129  ADD X9, X9, #8
 107d70260 0xaa0903e0  MOV X0, X9
 107d70264 0x97ffff74  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d70268 0xd2800300  MOVZ X0, #24
 107d7026c 0x96b7933b  BL OBJECT_HEAP_ALLOC    ; Reloc -> 'OBJECT_HEAP_ALLOC' @ 0x102b54f58
 107d70270 0xaa0003f4  MOV X20, X0
 107d70274 0xb0000029  ADRP X9, Point_vtable    ; Reloc -> 'Point_vtable' @ 0x107d752a4
 107d70278 0x910a9129  ADD X9, X9, #:lo12:Point_vtable    ; Reloc -> 'Point_vtable' @ 0x107d752a4
 107d7027c 0xf9000289  STR X9, [X20, #0] ; store vtable ptr
 107d70280 0xaa1403fa  MOV X26, X20
 107d70284 0xb0000029  ADRP X9, L_str5    ; Reloc -> 'L_str5' @ 0x107d75130
 107d70288 0x9104c129  ADD X9, X9, #:lo12:L_str5    ; Reloc -> 'L_str5' @ 0x107d75130
 107d7028c 0x91002129  ADD X9, X9, #8
 107d70290 0xaa0903e0  MOV X0, X9
 107d70294 0x97ffff68  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d70298 0xf9400349  LDR X9, [X26, #0] ; Load vtable pointer
 107d7029c 0xf940092a  LDR X10, [X9, #16] ; Load method address
 107d702a0 0xaa1a03e0  MOV X0, X26
 107d702a4 0xd63f0140  BLR X10
 107d702a8 0xaa0003fb  MOV X27, X0
 107d702ac 0xaa1b03e0  MOV X0, X27
 107d702b0 0x97ffff5d  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d702b4 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x107d75188
 107d702b8 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x107d75188
 107d702bc 0x91002129  ADD X9, X9, #8
 107d702c0 0xaa0903e0  MOV X0, X9
 107d702c4 0x97ffff5c  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d702c8 0xaa1b03e0  MOV X0, X27
 107d702cc 0x97ffff56  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d702d0 0xb0000029  ADRP X9, L_str7    ; Reloc -> 'L_str7' @ 0x107d751a8
 107d702d4 0x9106a129  ADD X9, X9, #:lo12:L_str7    ; Reloc -> 'L_str7' @ 0x107d751a8
 107d702d8 0x91002129  ADD X9, X9, #8
 107d702dc 0xaa0903e0  MOV X0, X9
 107d702e0 0x97ffff55  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d702e4 0xb0000029  ADRP X9, L_str8    ; Reloc -> 'L_str8' @ 0x107d751c0
 107d702e8 0x91070129  ADD X9, X9, #:lo12:L_str8    ; Reloc -> 'L_str8' @ 0x107d751c0
 107d702ec 0x91002129  ADD X9, X9, #8
 107d702f0 0xaa0903e0  MOV X0, X9
 107d702f4 0x97ffff50  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d702f8 0xd2800c89  MOVZ X9, #100
 107d702fc 0xaa0903f4  MOV X20, X9
 107d70300 0xd2801909  MOVZ X9, #200
 107d70304 0xaa0903f5  MOV X21, X9
 107d70308 0xaa1a03e0  MOV X0, X26
 107d7030c 0xaa1403e1  MOV X1, X20
 107d70310 0xaa1503e2  MOV X2, X21
 107d70314 0x97ffff84  BL Point::set    ; Reloc -> 'Point::set' @ 0x107d70124
 107d70318 0xb0000029  ADRP X9, L_str9    ; Reloc -> 'L_str9' @ 0x107d75228
 107d7031c 0x9108a129  ADD X9, X9, #:lo12:L_str9    ; Reloc -> 'L_str9' @ 0x107d75228
 107d70320 0x91002129  ADD X9, X9, #8
 107d70324 0xaa0903e0  MOV X0, X9
 107d70328 0x97ffff43  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d7032c 0xaa1b03e0  MOV X0, X27
 107d70330 0x97ffff3d  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d70334 0xb0000029  ADRP X9, L_str6    ; Reloc -> 'L_str6' @ 0x107d75188
 107d70338 0x91062129  ADD X9, X9, #:lo12:L_str6    ; Reloc -> 'L_str6' @ 0x107d75188
 107d7033c 0x91002129  ADD X9, X9, #8
 107d70340 0xaa0903e0  MOV X0, X9
 107d70344 0x97ffff3c  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d70348 0xaa1b03e0  MOV X0, X27
 107d7034c 0x97ffff36  BL WRITEN_veneer    ; Reloc -> 'WRITEN_veneer' @ 0x107d70024
 107d70350 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x107d75290
 107d70354 0x910a4129  ADD X9, X9, #:lo12:L_str10    ; Reloc -> 'L_str10' @ 0x107d75290
 107d70358 0x91002129  ADD X9, X9, #8
 107d7035c 0xaa0903e0  MOV X0, X9
 107d70360 0x97ffff35  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x107d70034
 107d70364 0x97ffff2c  BL HeapManager_exit_scope_veneer    ; Reloc -> 'HeapManager_exit_scope_veneer' @ 0x107d70014
 107d70368 0x14000001  B START_Exit_1    ; Reloc -> 'START_Exit_1' @ 0x107d7036c
START_Exit_1:
 107d7036c 0x14000001  B .L5    ; Reloc -> '.L5' @ 0x107d70370
.L5:
 107d70370 0xf94013b3  LDR X19, [X29, #32] ; Restored Reg: X19 @ FP+32
 107d70374 0xf94017ba  LDR X26, [X29, #40] ; Restored Reg: X26 @ FP+40
 107d70378 0xf9401bbb  LDR X27, [X29, #48] ; Restored Reg: X27 @ FP+48
 107d7037c 0xf9401fbc  LDR X28, [X29, #56] ; Restored Reg: X28 @ FP+56
 107d70380 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 107d70384 0xf94003fd  LDR X29, [SP, #0] ; Restore caller's Frame Pointer
 107d70388 0xf94007fe  LDR X30, [SP, #8] ; Restore Link Register
 107d7038c 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 107d70390 0xd65f03c0  RET
L_str0:
 107d75000 0x12000000  .quad 0x12
 107d75004 0x00000000  ; (upper half)
 107d75008 0x50000000  DCD 0x50
 107d7500c 0x6f000000  DCD 0x6f
 107d75010 0x69000000  DCD 0x69
 107d75014 0x6e000000  DCD 0x6e
 107d75018 0x74000000  DCD 0x74
 107d7501c 0x20000000  DCD 0x20
 107d75020 0x63000000  DCD 0x63
 107d75024 0x72000000  DCD 0x72
 107d75028 0x65000000  DCD 0x65
 107d7502c 0x61000000  DCD 0x61
 107d75030 0x74000000  DCD 0x74
 107d75034 0x65000000  DCD 0x65
 107d75038 0x64000000  DCD 0x64
 107d7503c 0x20000000  DCD 0x20
 107d75040 0x61000000  DCD 0x61
 107d75044 0x74000000  DCD 0x74
 107d75048 0x20000000  DCD 0x20
 107d7504c 0x28000000  DCD 0x28
 107d75050 0x00000000  DCD 0x0
 107d75054 0x00000000  DCD 0x0
L_str1:
 107d75058 0x20000000  .quad 0x2
 107d7505c 0x00000000  ; (upper half)
 107d75060 0x2c000000  DCD 0x2c
 107d75064 0x20000000  DCD 0x20
 107d75068 0x00000000  DCD 0x0
 107d7506c 0x00000000  DCD 0x0
L_str2:
 107d75070 0x20000000  .quad 0x2
 107d75074 0x00000000  ; (upper half)
 107d75078 0x29000000  DCD 0x29
 107d7507c 0xa0000000  DCD 0xa
 107d75080 0x00000000  DCD 0x0
 107d75084 0x00000000  DCD 0x0
L_str3:
 107d75088 0x10000000  .quad 0x10
 107d7508c 0x00000000  ; (upper half)
 107d75090 0x50000000  DCD 0x50
 107d75094 0x6f000000  DCD 0x6f
 107d75098 0x69000000  DCD 0x69
 107d7509c 0x6e000000  DCD 0x6e
 107d750a0 0x74000000  DCD 0x74
 107d750a4 0x20000000  DCD 0x20
 107d750a8 0x6d000000  DCD 0x6d
 107d750ac 0x6f000000  DCD 0x6f
 107d750b0 0x76000000  DCD 0x76
 107d750b4 0x65000000  DCD 0x65
 107d750b8 0x64000000  DCD 0x64
 107d750bc 0x20000000  DCD 0x20
 107d750c0 0x74000000  DCD 0x74
 107d750c4 0x6f000000  DCD 0x6f
 107d750c8 0x20000000  DCD 0x20
 107d750cc 0x28000000  DCD 0x28
 107d750d0 0x00000000  DCD 0x0
 107d750d4 0x00000000  DCD 0x0
L_str4:
 107d750d8 0x12000000  .quad 0x12
 107d750dc 0x00000000  ; (upper half)
 107d750e0 0x43000000  DCD 0x43
 107d750e4 0x72000000  DCD 0x72
 107d750e8 0x65000000  DCD 0x65
 107d750ec 0x61000000  DCD 0x61
 107d750f0 0x74000000  DCD 0x74
 107d750f4 0x69000000  DCD 0x69
 107d750f8 0x6e000000  DCD 0x6e
 107d750fc 0x67000000  DCD 0x67
 107d75100 0x20000000  DCD 0x20
 107d75104 0x70000000  DCD 0x70
 107d75108 0x6f000000  DCD 0x6f
 107d7510c 0x69000000  DCD 0x69
 107d75110 0x6e000000  DCD 0x6e
 107d75114 0x74000000  DCD 0x74
 107d75118 0x2e000000  DCD 0x2e
 107d7511c 0x2e000000  DCD 0x2e
 107d75120 0x2e000000  DCD 0x2e
 107d75124 0xa0000000  DCD 0xa
 107d75128 0x00000000  DCD 0x0
 107d7512c 0x00000000  DCD 0x0
L_str5:
 107d75130 0x12000000  .quad 0x12
 107d75134 0x00000000  ; (upper half)
 107d75138 0x52000000  DCD 0x52
 107d7513c 0x65000000  DCD 0x65
 107d75140 0x61000000  DCD 0x61
 107d75144 0x64000000  DCD 0x64
 107d75148 0x69000000  DCD 0x69
 107d7514c 0x6e000000  DCD 0x6e
 107d75150 0x67000000  DCD 0x67
 107d75154 0x20000000  DCD 0x20
 107d75158 0x76000000  DCD 0x76
 107d7515c 0x61000000  DCD 0x61
 107d75160 0x6c000000  DCD 0x6c
 107d75164 0x75000000  DCD 0x75
 107d75168 0x65000000  DCD 0x65
 107d7516c 0x73000000  DCD 0x73
 107d75170 0x3a000000  DCD 0x3a
 107d75174 0x20000000  DCD 0x20
 107d75178 0x78000000  DCD 0x78
 107d7517c 0x3d000000  DCD 0x3d
 107d75180 0x00000000  DCD 0x0
 107d75184 0x00000000  DCD 0x0
L_str6:
 107d75188 0x40000000  .quad 0x4
 107d7518c 0x00000000  ; (upper half)
 107d75190 0x2c000000  DCD 0x2c
 107d75194 0x20000000  DCD 0x20
 107d75198 0x79000000  DCD 0x79
 107d7519c 0x3d000000  DCD 0x3d
 107d751a0 0x00000000  DCD 0x0
 107d751a4 0x00000000  DCD 0x0
L_str7:
 107d751a8 0x20000000  .quad 0x2
 107d751ac 0x00000000  ; (upper half)
 107d751b0 0xa0000000  DCD 0xa
 107d751b4 0xa0000000  DCD 0xa
 107d751b8 0x00000000  DCD 0x0
 107d751bc 0x00000000  DCD 0x0
L_str8:
 107d751c0 0x16000000  .quad 0x16
 107d751c4 0x00000000  ; (upper half)
 107d751c8 0x53000000  DCD 0x53
 107d751cc 0x65000000  DCD 0x65
 107d751d0 0x74000000  DCD 0x74
 107d751d4 0x74000000  DCD 0x74
 107d751d8 0x69000000  DCD 0x69
 107d751dc 0x6e000000  DCD 0x6e
 107d751e0 0x67000000  DCD 0x67
 107d751e4 0x20000000  DCD 0x20
 107d751e8 0x6e000000  DCD 0x6e
 107d751ec 0x65000000  DCD 0x65
 107d751f0 0x77000000  DCD 0x77
 107d751f4 0x20000000  DCD 0x20
 107d751f8 0x76000000  DCD 0x76
 107d751fc 0x61000000  DCD 0x61
 107d75200 0x6c000000  DCD 0x6c
 107d75204 0x75000000  DCD 0x75
 107d75208 0x65000000  DCD 0x65
 107d7520c 0x73000000  DCD 0x73
 107d75210 0x2e000000  DCD 0x2e
 107d75214 0x2e000000  DCD 0x2e
 107d75218 0x2e000000  DCD 0x2e
 107d7521c 0xa0000000  DCD 0xa
 107d75220 0x00000000  DCD 0x0
 107d75224 0x00000000  DCD 0x0
L_str9:
 107d75228 0x16000000  .quad 0x16
 107d7522c 0x00000000  ; (upper half)
 107d75230 0x52000000  DCD 0x52
 107d75234 0x65000000  DCD 0x65
 107d75238 0x61000000  DCD 0x61
 107d7523c 0x64000000  DCD 0x64
 107d75240 0x69000000  DCD 0x69
 107d75244 0x6e000000  DCD 0x6e
 107d75248 0x67000000  DCD 0x67
 107d7524c 0x20000000  DCD 0x20
 107d75250 0x6e000000  DCD 0x6e
 107d75254 0x65000000  DCD 0x65
 107d75258 0x77000000  DCD 0x77
 107d7525c 0x20000000  DCD 0x20
 107d75260 0x76000000  DCD 0x76
 107d75264 0x61000000  DCD 0x61
 107d75268 0x6c000000  DCD 0x6c
 107d7526c 0x75000000  DCD 0x75
 107d75270 0x65000000  DCD 0x65
 107d75274 0x73000000  DCD 0x73
 107d75278 0x3a000000  DCD 0x3a
 107d7527c 0x20000000  DCD 0x20
 107d75280 0x78000000  DCD 0x78
 107d75284 0x3d000000  DCD 0x3d
 107d75288 0x00000000  DCD 0x0
 107d7528c 0x00000000  DCD 0x0
L_str10:
 107d75290 0x10000000  .quad 0x1
 107d75294 0x00000000  ; (upper half)
 107d75298 0xa0000000  DCD 0xa
 107d7529c 0x00000000  DCD 0x0
 107d752a0 0x00000000  DCD 0x0
Point_vtable:
 107d752a4 0x7d700480  .quad Point::CREATE    ; Reloc -> 'Point::CREATE' @ 0x107d70048
 107d752ac 0x7d701f00  .quad Point::RELEASE    ; Reloc -> 'Point::RELEASE' @ 0x107d701f0
 107d752b4 0x7d701140  .quad Point::getX    ; Reloc -> 'Point::getX' @ 0x107d70114
 107d752bc 0x7d7011c0  .quad Point::getY    ; Reloc -> 'Point::getY' @ 0x107d7011c
 107d752c4 0x7d701240  .quad Point::set    ; Reloc -> 'Point::set' @ 0x107d70124

--------------------------

JIT runtime table populated with 123 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x107d70228
[JITExecutor] Starting execution of JIT-compiled function at address: 0x107d70228
SAMM: Entered scope (depth: 2)
Creating point...
SAMM: Tracked allocation 0x848cb0000 in scope (depth: 2, scope size: 1)
DEBUG: ListAtom allocated at 0x848cb0000 (total atoms: 1)
Reading values: x=0, y=0

Setting new values...
Point moved to (100, 200)
Reading new values: x=0, y=0
SAMM: Scope exit - found 1 objects to cleanup (remaining depth: 1)
SAMM: About to queue 1 objects for cleanup
SAMM: Queued objects for background cleanup (queue depth: 1)
SAMM: Notified background worker
JIT Execution completed with result: 4468440880
  Same value as double: 2.2077e-314
[JITExecutor] Execution completed. Result: 4468440880

--- JIT returned with result: 4468440880 ---
SAMM: Worker woke up, queue size: 1, running: YES
SAMM: Processing batch of 1 objects
SAMM: cleanupPointersImmediate called with 1 pointers
SAMM: Cleaning up pointer 0x848cb0000
DEBUG: HeapManager::free called with payload=0x848cb0000
DEBUG: Checking payload 0x848cb0000 in Bloom filter
DEBUG: Checking base address 0x848cafff8 in Bloom filter
DEBUG: Adding base address 0x848cb0000 to Bloom filter

--- BCPL Runtime Metrics ---
Memory allocations: 1 (24 bytes)
Memory frees: 1 (24 bytes)
Vector allocations: 0
String allocations: 0
Double-free attempts: 0
Current active allocations: 0 (0 bytes)
Bloom filter statistics:
  Items tracked: 1
  Memory usage: 12000000 bytes
  False positives: 0
DEBUG: Fixed Bloom filter (12MB) now has ~1 items (capacity: 10M, estimated false positive rate: 0.0000%)
SAMM: Successfully cleaned pointer 0x848cb0000
SAMM: cleanupPointersImmediate completed 1 items in 42.137 ms
SAMM: Background worker processed batch of 1 objects
SAMM: Worker waiting for cleanup queue (queue size: 0)
  Est. false positive rate: 0.0000%
File I/O operations:
  Files opened: 0
  Files closed: 0
  Bytes read: 0
  Bytes written: 0
  Open files: 0
--------------------------
SAMM: Processed all pending cleanup operations
SAMM: Worker woke up, queue size: 0, running: NO
SAMM: Background cleanup worker thread stopped (DEBUG)
SAMM: Background worker stopped
SAMM: cleanupPointersImmediate called with 0 pointers
SAMM: cleanupPointersImmediate completed 0 items in 0.000 ms
SAMM: Shutdown complete
