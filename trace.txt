NeonReducerRegistry: Registered 13 NEON reduction encoders
Found source file: test_split_join_simple.bcl
Debug: Processing argument 3: --trace-codegen
Debug: Processing argument 4: --run
Debug: parse_arguments successful, input_filepath=test_split_join_simple.bcl
Debug: Arguments parsed successfully
DEBUG: HeapManager constructor called
SAMM: Background worker thread created and started
SAMM: ENABLED and background worker started
SAMM (Scope Aware Memory Management): ENABLED
SAMM: Background cleanup worker thread started (DEBUG)
SAMM: Worker waiting for cleanup queue (queue size: 0)
NewBCPL Compiler Version 1.0.2417
Compiling this source Code:
//LINE 1 "/Users/oberon/projects/NewBCPL/test_split_join_simple.bcl"
LET START() BE
$(
   WRITES("Testing SPLIT->JOIN round-trip...*N")

   LET S1 = "hello world test"
   WRITES("Original string: ")
   WRITES(S1)
   WRITES("*N")

   WRITES("Calling SPLIT...*N")
   LET L = SPLIT(S1, " ")
   WRITES("SPLIT completed*N")

   TEST L = 0 THEN
   $(
       WRITES("ERROR: SPLIT returned null*N")
   $)
   ELSE
   $(
       WRITES("SPLIT returned a list, now calling JOIN...*N")
       LET S2 = JOIN(L, "-")
       WRITES("JOIN completed*N")

       TEST S2 = 0 THEN
       $(
           WRITES("ERROR: JOIN returned null*N")
       $)
       ELSE
       $(
           WRITES("JOIN result: ")
           WRITES(S2)
           WRITES("*N")
       $)
   $)
$)

BCPL Runtime v1.0.0 initialized
DEBUG: Registering FREEVEC with bcpl_free at address 0x10115f21c
Registered 92 runtime functions
=== Registered Runtime Functions ===
  NEWLINE          | address: 0x10115df50 | args: 0 | table_offset: 720
  FINISH           | address: 0x10115cd00 | args: 0 | table_offset: 712
  FABS             | address: 0x10115d0b0 | args: 1 | table_offset: 680
  FSIN             | address: 0x10115d074 | args: 1 | table_offset: 656
  FILE_EOF         | address: 0x101160460 | args: 1 | table_offset: 624
  RAND             | address: 0x10115cf00 | args: 1 | table_offset: 632
  FILE_TELL        | address: 0x101160408 | args: 1 | table_offset: 616
  FILE_SEEK        | address: 0x101160344 | args: 3 | table_offset: 608
  FILE_WRITE       | address: 0x10116022c | args: 3 | table_offset: 600
  FIX              | address: 0x10115d0f0 | args: 1 | table_offset: 704
  FILE_READS       | address: 0x10115fc78 | args: 1 | table_offset: 584
  FILE_WRITES      | address: 0x10115f99c | args: 2 | table_offset: 576
  FEXP             | address: 0x10115d0dc | args: 1 | table_offset: 696
  FILE_CLOSE       | address: 0x10115f930 | args: 1 | table_offset: 568
  FILE_OPEN_APPEND | address: 0x10115f8a0 | args: 1 | table_offset: 560
  PACKSTRING       | address: 0x10115d108 | args: 1 | table_offset: 512
  STRLEN           | address: 0x10115cd10 | args: 1 | table_offset: 504
  FCOS             | address: 0x10115d088 | args: 1 | table_offset: 664
  STRCMP           | address: 0x10115cd70 | args: 2 | table_offset: 496
  STRCOPY          | address: 0x10115ce54 | args: 2 | table_offset: 488
  FIND             | address: 0x101163b64 | args: 3 | table_offset: 456
  DEEPCOPYLITERALLIST | address: 0x1011637dc | args: 1 | table_offset: 440
  DEEPCOPYLIST     | address: 0x101163644 | args: 1 | table_offset: 432
  COPYLIST         | address: 0x101163544 | args: 1 | table_offset: 424
  CONCAT           | address: 0x10116397c | args: 2 | table_offset: 416
  BCPL_CONCAT_LISTS | address: 0x10116397c | args: 2 | table_offset: 408
  SPIT             | address: 0x10115dd04 | args: 2 | table_offset: 536
  JOIN             | address: 0x10115f438 | args: 2 | table_offset: 480
  LPND             | address: 0x1011630f0 | args: 2 | table_offset: 400
  SPND             | address: 0x101163020 | args: 2 | table_offset: 392
  FPND             | address: 0x101162f50 | args: 2 | table_offset: 384
  APND             | address: 0x101162e80 | args: 2 | table_offset: 376
  RETURNNODETOFREELIST | address: 0x101164034 | args: 1 | table_offset: 728
  BCPL_LIST_APPEND_INT | address: 0x101162e80 | args: 2 | table_offset: 352
  GETVEC           | address: 0x10115f2e0 | args: 1 | table_offset: 128
  HEAPMANAGER_WAITFORSAMM | address: 0x10111fe00 | args: 0 | table_offset: 320
  HEAPMANAGER_ENTER_SCOPE | address: 0x10111fd38 | args: 0 | table_offset: 288
  HEAPMANAGER_SETSAMMENABLED | address: 0x10111fce4 | args: 1 | table_offset: 304
  HEAPMANAGER_EXIT_SCOPE | address: 0x10111fd64 | args: 0 | table_offset: 296
  PIC_RUNTIME_HELPER | address: 0x10115f3c8 | args: 0 | table_offset: 280
  OBJECT_HEAP_FREE | address: 0x10115f38c | args: 1 | table_offset: 264
  OBJECT_HEAP_ALLOC | address: 0x10115f368 | args: 1 | table_offset: 256
  BCPL_LIST_GET_REST | address: 0x1011633ac | args: 1 | table_offset: 224
  FRND             | address: 0x10115cf8c | args: 0 | table_offset: 648
  BCPL_LIST_GET_HEAD_AS_FLOAT | address: 0x1011632f4 | args: 1 | table_offset: 208
  BCPL_LIST_GET_HEAD_AS_INT | address: 0x101163290 | args: 1 | table_offset: 200
  RUNTIME_METHOD_LOOKUP | address: 0x10115f3b0 | args: 2 | table_offset: 272
  FREEVEC          | address: 0x10115f21c | args: 1 | table_offset: 144
  BCPL_BOUNDS_ERROR | address: 0x10115ae58 | args: 3 | table_offset: 192
  BCPL_CHECK_AND_DISPLAY_ERRORS | address: 0x10116407c | args: 0 | table_offset: 184
  WRITEF4          | address: 0x10115c834 | args: 5 | table_offset: 56
  BCPL_FREE_LIST   | address: 0x101163d08 | args: 1 | table_offset: 152
  BCPL_ALLOC_CHARS | address: 0x10115f1c4 | args: 1 | table_offset: 112
  BCPL_LIST_APPEND_FLOAT | address: 0x101162f50 | args: 2 | table_offset: 360
  GET_FREE_LIST_HEAD_ADDR | address: 0x101164028 | args: 0 | table_offset: 336
  BCPL_GET_ATOM_TYPE | address: 0x101163410 | args: 1 | table_offset: 232
  FWRITE           | address: 0x10115c174 | args: 1 | table_offset: 16
  BCPL_LIST_CREATE_EMPTY | address: 0x101162e20 | args: 0 | table_offset: 344
  SPLIT            | address: 0x10115f464 | args: 2 | table_offset: 472
  BCPL_FREE_CELLS  | address: 0x101164024 | args: 0 | table_offset: 328
  RND              | address: 0x10115cfe0 | args: 1 | table_offset: 640
  HEAPMANAGER_ISSAMMENABLED | address: 0x10111fd14 | args: 0 | table_offset: 312
  WRITEC           | address: 0x10115caf0 | args: 1 | table_offset: 88
  MALLOC           | address: 0x10115f164 | args: 1 | table_offset: 120
  BCPL_ALLOC_WORDS | address: 0x10115f164 | args: 3 | table_offset: 104
  FTAN             | address: 0x10115d09c | args: 1 | table_offset: 672
  SETTYPE          | address: 0x0 | args: 2 | table_offset: 248
  BCPL_GET_LAST_ERROR | address: 0x10115acd8 | args: 1 | table_offset: 168
  RDCH             | address: 0x10115ccb4 | args: 0 | table_offset: 96
  FILE_READ        | address: 0x101160118 | args: 3 | table_offset: 592
  UNPACKSTRING     | address: 0x10115d440 | args: 1 | table_offset: 520
  WRITEF5          | address: 0x10115c8c0 | args: 6 | table_offset: 64
  FILTER           | address: 0x101163c58 | args: 2 | table_offset: 464
  BCPL_FREE_LIST_SAFE | address: 0x101163e10 | args: 1 | table_offset: 160
  FILE_OPEN_WRITE  | address: 0x10115f810 | args: 1 | table_offset: 552
  FILE_OPEN_READ   | address: 0x10115f490 | args: 1 | table_offset: 544
  BCPL_LIST_GET_NTH | address: 0x101163478 | args: 2 | table_offset: 240
  WRITEF7          | address: 0x10115c9fc | args: 8 | table_offset: 80
  WRITEF3          | address: 0x10115c7b4 | args: 4 | table_offset: 48
  WRITEF6          | address: 0x10115c958 | args: 7 | table_offset: 72
  REVERSE          | address: 0x101163a7c | args: 1 | table_offset: 448
  WRITEF2          | address: 0x10115c740 | args: 3 | table_offset: 40
  WRITEF1          | address: 0x10115c6d8 | args: 2 | table_offset: 32
  BCPL_LIST_GET_TAIL | address: 0x10116335c | args: 1 | table_offset: 216
  BCPL_CLEAR_ERRORS | address: 0x10115ad88 | args: 0 | table_offset: 176
  WRITEF           | address: 0x10115c1b8 | args: 1 | table_offset: 24
  BCPL_LIST_APPEND_STRING | address: 0x101163020 | args: 2 | table_offset: 368
  WRITES           | address: 0x10115bc18 | args: 1 | table_offset: 0
  SLURP            | address: 0x10115d7d8 | args: 1 | table_offset: 528
  FGETVEC          | address: 0x10115f314 | args: 1 | table_offset: 136
  FLOG             | address: 0x10115d0c8 | args: 1 | table_offset: 688
  WRITEN           | address: 0x10115caac | args: 1 | table_offset: 8
====================================
Core runtime registered. SDL2 registration will follow...
SDL2 runtime functions registered immediately
SDL2 runtime functions registered in unified runtime
Using BCPL Runtime v1.0.0
Parsing complete. AST built.

--- Initial Abstract Syntax Tree ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
----------------------------------

Applying Manifest Resolution Pass...
Applying Global Initializer Pass...

--- AST After Global Initializer Injection ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
------------------------------------------

Building symbol table...
[SymbolDiscoveryPass] Entering global scope
[SymbolDiscoveryPass] Processing routine declaration: START
[SymbolDiscoveryPass] Added routine: START
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: S1 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: L as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing FunctionCall
[SymbolDiscoveryPass] Processing test statement
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Processing let declaration
[SymbolDiscoveryPass] Added let variable: S2 as INTEGER (default INTEGER)
[SymbolDiscoveryPass] Processing FunctionCall
[SymbolDiscoveryPass] Processing test statement
[SymbolDiscoveryPass] Entering block scope
[SymbolDiscoveryPass] Entering block scope

=== SYMBOL TABLE DUMP AFTER SYMBOL DISCOVERY ===
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'S1' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, INTEGER, scope=2, block=0, class_name='', function_name='START')
Symbol 'S2' (LOCAL_VAR, INTEGER, scope=3, block=0, class_name='', function_name='START')

================================================

Registering runtime functions in symbol table...
SDL2 runtime functions registered immediately
Optimization enabled. Applying passes...
[FIX] Cleared FOR loop state before StrengthReductionPass to prevent corruption
SKIPPED: Boolean Short-Circuiting Pass (startup crash)...
Pass 1: Analyzing function signatures...
[SignatureAnalysis] Starting signature analysis pass...
[SignatureAnalysis] Analyzing program signatures...
[SignatureAnalysis] Analyzing routine signature: START
[SignatureAnalysis] Processing routine signature: START
[SignatureAnalysis] Signature analysis complete.
Debug: Checking function metrics after signature analysis...
Function: START
Pass 2: Full AST analysis...
Cleared FOR loop state before analysis to prevent corruption
[ANALYZER TRACE] Starting analysis...
[ANALYZER TRACE] Skipping reset - signature analysis already complete.
[ANALYZER TRACE] --- PASS 1: Discovering all function definitions ---
[ANALYZER TRACE] Visiting Program.
[ANALYZER TRACE] Visiting RoutineDeclaration: START
[ANALYZER] Starting parameter type inference for function: START
[ANALYZER TRACE] ASTAnalyzer::visit(RoutineDeclaration&) is traversing body for routine: START
[ANALYZER TRACE] Entering block scope: START_block_0 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 9 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102206e70
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102207b30
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102207c20
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 4 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102207d00
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 5 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102207e20
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 6 of type 52
[ANALYZER TRACE]   Detected call to runtime function: SPLIT, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S1
[DEBUG get_effective_variable_name] Called with: 'S1'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S1'
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 7 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102208090
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 8 of type 56
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Entering block scope: START_block_0_block_2 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1022081b0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Entering block scope: START_block_0_block_2 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 4 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102208260
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 52
[ANALYZER TRACE]   Detected call to runtime function: JOIN, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: L
[DEBUG get_effective_variable_name] Called with: 'L'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'L'
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1022083f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 3 of type 56
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] Entering block scope: START_block_0_block_2_block_3 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 1 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102208470
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0_block_2
[ANALYZER TRACE] Entering block scope: START_block_0_block_2_block_3 (Function scope remains: START)
[ANALYZER TRACE] BlockStatement: Traversing 3 statements.
[ANALYZER TRACE] BlockStatement: Calling accept on statement 0 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x1022084f0
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] BlockStatement: Calling accept on statement 1 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102208540
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Visiting VariableAccess: S2
[DEBUG get_effective_variable_name] Called with: 'S2'
[DEBUG get_effective_variable_name] Loop context stack size: 0
[DEBUG get_effective_variable_name] Active FOR loop scopes size: 0
[DEBUG get_effective_variable_name] FOR variable aliases size: 0
[DEBUG get_effective_variable_name] In FOR loop context: NO
[DEBUG get_effective_variable_name] Not in FOR loop context, returning original: 'S2'
[ANALYZER TRACE] BlockStatement: Calling accept on statement 2 of type 53
[ANALYZER TRACE] Entered ASTAnalyzer::visit(RoutineCallStatement&) for node at 0x102208580
[ANALYZER TRACE]   Detected call to runtime function: WRITES, Type: INTEGER
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0_block_2
[ANALYZER TRACE] Exiting block scope, returning to: START_block_0
[ANALYZER TRACE] Exiting block scope, returning to: START
[SAMM OPTIMIZATION] Starting heap allocation propagation...
[SAMM OPTIMIZATION] Propagation iteration 1
[SAMM OPTIMIZATION] Propagation completed after 1 iterations
[SAMM OPTIMIZATION] Results:
  Total functions: 1
  Allocation-free functions: 1
  Allocation-free leaf functions: 0
  Allocation-free non-leaf functions: 1
[ANALYZER TRACE] Analysis complete.
Initial AST analysis complete.
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 15
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 0
  Required Callee-Saved Temps: 0
--------------------------------------------
Running StringLiteralLiftingPass (string literal lifting)...
Optimization enabled. Applying passes...
Cleared FOR loop state before AST transformation to prevent corruption
[ANALYZER TRACE] Starting AST transformation...
[ANALYZER TRACE] AST transformation complete.
AST transformation complete.
Applying CREATE Method Reordering Pass...
[CreateMethodReorderPass] Starting CREATE method reordering pass
[CreateMethodReorderPass] Visiting Program node
[CreateMethodReorderPass] Visiting RoutineDeclaration: START
[CreateMethodReorderPass] No CREATE method reordering needed
CREATE Method Reordering Pass complete.
Running compile-time bounds checking...
Compile-time bounds checking complete.
Building Control Flow Graphs...
Cleared FOR loop state before CFGBuilderPass to prevent corruption
[CFGBuilderPass] build() called.
[CFGBuilderPass] About to accept(Program)
[CFGBuilderPass] visit(Program) called.
[CFGBuilderPass] Processing declaration #0
[CFGBuilderPass] Found RoutineDecl at index 0
[CFGBuilderPass] Creating CFG for routine: START
[CFGBuilderPass] Created CFG for routine: START
[CFGBuilderPass] Created new basic block: START_Entry_0
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 1 variable tracking
[CFGBuilderPass] Tracking variable 'S1' in current block
[CFGBuilderPass] Tracking variable 'L' in current block
[CFGBuilderPass] visit(TestStatement) entered.
[CFGBuilderPass] Created new basic block: START_Then_1
[CFGBuilderPass] Created new basic block: START_Else_2
[CFGBuilderPass] Created new basic block: START_Join_3
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 2 variable tracking
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 3 variable tracking
[CFGBuilderPass] Tracking variable 'S2' in current block
[CFGBuilderPass] visit(TestStatement) entered.
[CFGBuilderPass] Created new basic block: START_Then_4
[CFGBuilderPass] Created new basic block: START_Else_5
[CFGBuilderPass] Created new basic block: START_Join_6
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 4 variable tracking
[CFGBuilderPass] Visiting BlockStatement with SAMM scope management.
[SAMM OPTIMIZATION] Skipping scope calls for allocation-free function: START (call tree)
[CFGBuilderPass] Starting optimized block 5 variable tracking
[CFGBuilderPass] visit(TestStatement) exiting.
[CFGBuilderPass] visit(TestStatement) exiting.
[CFGBuilderPass] Created new basic block: START_Exit_7
[CFGBuilderPass] Resolving 0 GOTO statements...
[CFGBuilderPass] visit(Program) complete.
[CFGBuilderPass] Finished accept(Program)
[CFGBuilderPass] build() complete.

[CFGBuilderPass] --- DUMPING ALL CFGs ---
[CFGBuilderPass] CFG found for: START
[CFGBuilderPass] --- END CFG DUMP ---
Applying CFG Simplification Pass (Branch Chaining)...
[CFGSimplificationPass] Starting CFG Simplification Pass
[CFGSimplificationPass] Processing function: START
[CFGSimplificationPass]   Iteration 1
[CFGSimplificationPass]     Found jump-only block: START_Join_3 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Then_1 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Join_6 -> START_Exit_7
[CFGSimplificationPass]     Eliminated block: START_Join_3
[CFGSimplificationPass]     Found jump-only block: START_Join_6 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Then_4 -> START_Exit_7
[CFGSimplificationPass]       Redirected edge: START_Else_5 -> START_Exit_7
[CFGSimplificationPass]     Eliminated block: START_Join_6
[CFGSimplificationPass]     Removing unreachable block: START_Join_3
[CFGSimplificationPass]     Removing unreachable block: START_Join_6
[CFGSimplificationPass]   Iteration 2
[CFGSimplificationPass]   Simplification completed after 2 iterations

[CFGSimplificationPass] Statistics:
  Functions processed: 1
  Blocks eliminated: 2
  Edges redirected: 4
  Unnecessary jumps removed: 0
[CFGSimplificationPass] CFG Simplification Pass completed

[INFO] Re-running Liveness Analysis on modified CFG...
--- Running Liveness Analysis ---
[LivenessAnalysisPass] Calling compute_use_def_sets()
[LivenessAnalysisPass] Entering compute_use_def_sets()
[LivenessAnalysisPass] CFG #1 for function 'START' has 6 blocks.
[LivenessAnalysisPass] Analyzing block #1 (id=START_Exit_7) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Exit_7
[LivenessAnalysisPass] Starting intra-block analysis for START_Exit_7 with 0 statements
[LivenessAnalysisPass] Exiting analyze_block for block: START_Exit_7
[LivenessAnalysisPass] Analyzing block #2 (id=START_Else_5) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Else_5
[LivenessAnalysisPass] Starting intra-block analysis for START_Else_5 with 3 statements
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S2
[LivenessAnalysisPass] Reverse scan - Statement 1 uses variables: S2 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S2 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 1
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Else_5 - variables live across calls: S2 
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_5 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Else_5
[LivenessAnalysisPass] Analyzing block #3 (id=START_Then_1) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Then_1
[LivenessAnalysisPass] Starting intra-block analysis for START_Then_1 with 1 statements
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Then_1 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Then_1
[LivenessAnalysisPass] Analyzing block #4 (id=START_Then_4) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Then_4
[LivenessAnalysisPass] Starting intra-block analysis for START_Then_4 with 1 statements
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Block START_Then_4 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Then_4
[LivenessAnalysisPass] Analyzing block #5 (id=START_Else_2) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Else_2
[LivenessAnalysisPass] Starting intra-block analysis for START_Else_2 with 4 statements
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 13TestStatement
[LivenessAnalysisPass] Reverse scan - Statement 3 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 12FunctionCall
[LivenessAnalysisPass] Found FunctionCall with 2 arguments
[LivenessAnalysisPass] Function name: JOIN
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: L
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 1 uses variables: L 
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: L 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 1
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Else_2 - variables live across calls: L 
[LivenessAnalysisPass] Block START_Else_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Else_2 contains function call - marked for call interval fix
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN'
[LivenessAnalysisPass] Block START_Else_2 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Else_2
[LivenessAnalysisPass] Analyzing block #6 (id=START_Entry_0) in function 'START'
[LivenessAnalysisPass] Entering analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Starting intra-block analysis for START_Entry_0 with 9 statements
[LivenessAnalysisPass] Reverse scan - processing statement 8 type: 13TestStatement
[LivenessAnalysisPass] Reverse scan - Statement 8 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 8 contains call: NO
[LivenessAnalysisPass] Reverse scan - processing statement 7 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 7 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 7 contains call: YES
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 7
[LivenessAnalysisPass] Reverse scan - processing statement 6 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 12FunctionCall
[LivenessAnalysisPass] Found FunctionCall with 2 arguments
[LivenessAnalysisPass] Function name: SPLIT
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S1
[LivenessAnalysisPass] Processing function argument...
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 6 uses variables: S1 
[LivenessAnalysisPass] Reverse scan - Statement 6 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S1 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 6
[LivenessAnalysisPass] Reverse scan - processing statement 5 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 5 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 5 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 5
[LivenessAnalysisPass] Reverse scan - processing statement 4 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 4 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 4 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 4
[LivenessAnalysisPass] Reverse scan - processing statement 3 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 14VariableAccess
[LivenessAnalysisPass] Found variable use: S1
[LivenessAnalysisPass] Reverse scan - Statement 3 uses variables: S1 
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 3 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 1 variables used after previous calls: S1 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 3
[LivenessAnalysisPass] Reverse scan - processing statement 2 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 2 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 2 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 2
[LivenessAnalysisPass] Reverse scan - processing statement 1 type: 19AssignmentStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 1 uses no variables
[LivenessAnalysisPass] Reverse scan - Statement 1 contains call: NO
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - processing statement 0 type: 20RoutineCallStatement
[LivenessAnalysisPass] Collecting uses from node type: 13StringLiteral
[LivenessAnalysisPass] Testing dynamic_cast<LaneAccessExpression*>: FAILED
[LivenessAnalysisPass] Unhandled node type in collect_variable_uses: 13StringLiteral
[LivenessAnalysisPass] Reverse scan - Statement 0 uses no variables
[LivenessAnalysisPass] Found RoutineCallStatement
[LivenessAnalysisPass] Reverse scan - Statement 0 contains call: YES
[LivenessAnalysisPass] Reverse scan - Found 0 variables used after previous calls: 
[LivenessAnalysisPass] Reverse scan - Marking found_call=true at statement 0
[LivenessAnalysisPass] Intra-block call interval detected in START_Entry_0 - variables live across calls: S1 
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains function call - marked for call interval fix
[LivenessAnalysisPass] Block START_Entry_0 contains routine call - marked for call interval fix
[LivenessAnalysisPass] Exiting analyze_block for block: START_Entry_0
[LivenessAnalysisPass] Exiting compute_use_def_sets()
[LivenessAnalysisPass] Finished compute_use_def_sets()
[LivenessAnalysisPass] Calling run_data_flow_analysis()
[LivenessAnalysisPass] Entering run_data_flow_analysis()
[LivenessAnalysisPass] Data-flow iteration 1
[LivenessAnalysisPass] Processing block: START_Exit_7 in function: START
[LivenessAnalysisPass] Processing block: START_Then_1 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_1 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Then_4 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_4 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Else_5 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_5 - adding 0 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Else_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_2 - adding 1 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Data-flow iteration 2
[LivenessAnalysisPass] Processing block: START_Exit_7 in function: START
[LivenessAnalysisPass] Processing block: START_Then_1 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_1 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Then_4 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Then_4 - adding 0 live-out variables to use set
[LivenessAnalysisPass] Processing block: START_Else_5 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_5 - adding 0 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Else_2 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Else_2 - adding 1 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Processing block: START_Entry_0 in function: START
[LivenessAnalysisPass] Applying call interval fix to block START_Entry_0 - adding 2 live-out variables and 1 intra-statement call variables to use set
[LivenessAnalysisPass] Exiting run_data_flow_analysis()
[LivenessAnalysisPass] Finished run_data_flow_analysis()
--- Liveness Analysis Complete ---

Liveness Analysis for function: START
-------------------------------------------
Block ID: START_Exit_7
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Else_5
  Use: { S2 }
  Def: { }
  In : { S2 }
  Out: { }
Block ID: START_Then_1
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Then_4
  Use: { }
  Def: { }
  In : { }
  Out: { }
Block ID: START_Else_2
  Use: { L }
  Def: { S2 }
  In : { L S2 }
  Out: { S2 }
Block ID: START_Entry_0
  Use: { S1 }
  Def: { L S1 }
  In : { L S1 S2 }
  Out: { L S2 }

CFG for function: START
----------------------------------------
Entry Block: START_Entry_0
Exit Block: START_Exit_7 (conceptual)

Block ID: START_Exit_7 (Exit)
  Statements:
    (empty)
  Successors: (none)
  Predecessors: START_Then_1, START_Then_4, START_Else_5

Block ID: START_Else_5
  Statements:
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Else_2

Block ID: START_Then_1
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Entry_0

Block ID: START_Then_4
  Statements:
    - RoutineCallStmt
  Successors: START_Exit_7
  Predecessors: START_Else_2

Block ID: START_Else_2
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - TestStmt
  Successors: START_Then_4, START_Else_5
  Predecessors: START_Entry_0

Block ID: START_Entry_0 (Entry)
  Statements:
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - RoutineCallStmt
    - AssignmentStmt
    - RoutineCallStmt
    - TestStmt
  Successors: START_Then_1, START_Else_2
  Predecessors: (none)
----------------------------------------

--- AST Dump Immediately Before Code Generation ---
Program:
  Declarations:
    RoutineDeclaration: START
      Body:
        BlockStatement:
          Statements:
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Testing SPLIT->JOIN round-trip...
"
            AssignmentStatement:
              LHS:
                VariableAccess: S1
              RHS:
                StringLiteral: "hello world test"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Original string: "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                VariableAccess: S1
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "
"
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "Calling SPLIT...
"
            AssignmentStatement:
              LHS:
                VariableAccess: L
              RHS:
                FunctionCall:
                  Callee:
                    VariableAccess: SPLIT
                  Arguments:
                    VariableAccess: S1
                    StringLiteral: " "
            RoutineCallStatement:
              Callee:
                VariableAccess: WRITES
              Arguments:
                StringLiteral: "SPLIT completed
"
            TestStatement:
              Condition:
                BinaryOp: Equal
                  VariableAccess: L
                  NumberLiteral: 0
              Then:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "ERROR: SPLIT returned null
"
              Else:
                BlockStatement:
                  Statements:
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "SPLIT returned a list, now calling JOIN...
"
                    AssignmentStatement:
                      LHS:
                        VariableAccess: S2
                      RHS:
                        FunctionCall:
                          Callee:
                            VariableAccess: JOIN
                          Arguments:
                            VariableAccess: L
                            StringLiteral: "-"
                    RoutineCallStatement:
                      Callee:
                        VariableAccess: WRITES
                      Arguments:
                        StringLiteral: "JOIN completed
"
                    TestStatement:
                      Condition:
                        BinaryOp: Equal
                          VariableAccess: S2
                          NumberLiteral: 0
                      Then:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "ERROR: JOIN returned null
"
                      Else:
                        BlockStatement:
                          Statements:
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "JOIN result: "
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                VariableAccess: S2
                            RoutineCallStatement:
                              Callee:
                                VariableAccess: WRITES
                              Arguments:
                                StringLiteral: "
"
----------------------------------

Updating register pressure from liveness data...

[INFO] Building Live Intervals for all functions...
[LiveIntervalPass] Building intervals for function: START
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN'
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN'
[LiveIntervalPass] Created 3 intervals for function: START
  L: [0-11]
  S1: [0-6]
  S2: [0-16]

[INFO] Performing Linear Scan Register Allocation for ALL functions...
[Allocator] Starting partitioned linear scan for function: START
[Allocator] Available integer registers: 9, float registers: 8
[Allocator] Function has 15 call sites at: 0 4 8 12 16 20 25 29 33 37 42 46 50 54 58 
[Allocator] Partitioned: 3 call-crossing, 0 local-only intervals
[Allocator] Register pools - Callee-saved INT: 9, Caller-saved INT: 0, Reserved scratch INT: 0
[Allocator] Register pools - Callee-saved FP: 8, Caller-saved FP: 0
[Allocator] Stage 1: Allocating call-crossing intervals
[Allocator] Allocating call-crossing L [0-11]
  Assigned callee-saved register X27 to L
[ALLOC] Updated allocations for L: spilled=0, register='X27'
[Allocator] Allocating call-crossing S1 [0-6]
  Assigned callee-saved register X26 to S1
[ALLOC] Updated allocations for S1: spilled=0, register='X26'
[Allocator] Allocating call-crossing S2 [0-16]
  Assigned callee-saved register X25 to S2
[ALLOC] Updated allocations for S2: spilled=0, register='X25'
[Allocator] Stage 2: Allocating local-only intervals
[Allocator] Partitioned allocation complete for START
[Allocator] Reserved 0 scratch registers for code generation: 
[Allocator] Final state validation:
  Active intervals remaining: 3
  Free integer registers: 6
  Free float registers: 8
  ✓ No register conflicts detected
[Allocator] Results:
  L: reg X27 (callee-saved) [call-crossing]
  S1: reg X26 (callee-saved) [call-crossing]
  S2: reg X25 (callee-saved) [call-crossing]

[INFO] Synchronizing RegisterManager with LinearScanAllocator decisions...

--- Final Metrics State Before Code Generation ---
==== ASTAnalyzer Function Metrics Report ====
Function: START
  Type: int
  Parameters: 0
  Integer Locals: 6
  Float Locals: 0
  Runtime Calls: 15
  Local Function Calls: 0
  Local Routine Calls: 0
  Vector Allocations: no
  Accesses Globals: yes
  Max Live Variables (Register Pressure): 3
  Required Callee-Saved Temps: 0
--------------------------------------------
--------------------------------------------------

[DEBUG] Initialized veneer manager with base address: 0x4402888704
[DEBUG] Starting code generation for program.
[DEBUG] Step 1: Performing pre-analysis scan for external functions...
[DEBUG] Found 3 unique external functions:
[DEBUG]   - JOIN
[DEBUG]   - SPLIT
[DEBUG]   - WRITES
[DEBUG] Step 2: Generating veneer section using standard pipeline...
[VeneerManager] Generating 5 veneers (including function families) using standard pipeline...
[VeneerManager] Created veneer: HeapManager_enter_scope_veneer for function: HeapManager_enter_scope
[VeneerManager] Created veneer: HeapManager_exit_scope_veneer for function: HeapManager_exit_scope
[VeneerManager] Created veneer: JOIN_veneer for function: JOIN
[VeneerManager] Created veneer: SPLIT_veneer for function: SPLIT
[VeneerManager] Created veneer: WRITES_veneer for function: WRITES
[VeneerManager] Generated 5 veneers, estimated total size: 100 bytes
[DEBUG] Step 3: Generating main function code...
[DEBUG] Visiting Program node.
[DEBUG] Moving 'START' routine to the end of the generation queue for JIT compatibility.
[DEBUG] Code Generator: Registering global data declarations.
[DEBUG] Code Generator: Global data offsets calculated.
[DEBUG] Code Generator: Generating code for functions and routines.
[DEBUG] DEBUG: Visiting RoutineDeclaration node (Name: START).
[DEBUG] Using name as-is for metrics lookup: START
[DEBUG] DEBUG: generate_function_like_code called for: START
[DEBUG] Generating function-like code for: START
[DEBUG] Clearing local value tracking for function: START
[SYNC] Resetting all LinearScanAllocator reservations
[SYNC] Caching live intervals for function: START
[SYNC] Found 3 variable allocations
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Synced RegisterManager with LinearScanAllocator for function: START
[DEBUG] Using name as-is for lookup: START
Call Frame Layout for function: START
[SYMBOL TABLE TRACE] Warning: Found symbol 'SPLIT' in different context '' (requested context was 'START')
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN' in function context 'START'
[SYMBOL TABLE TRACE]   Symbol 'JOIN' not found in ANY context
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN' in function context 'Global'
[SYMBOL TABLE TRACE]   Symbol 'JOIN' not found in ANY context
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN'
[DEBUG] Registering all parameters as locals in CallFrameManager for 'START'.
[DEBUG] DEBUG: metrics.variable_types size for 'START': 3
[DEBUG] DEBUG: variable_types['L'] = POINTER_TO|LIST|STRING
[DEBUG] DEBUG: variable_types['S1'] = POINTER_TO|STRING
[DEBUG] DEBUG: variable_types['S2'] = POINTER_TO|STRING
[DEBUG] Registering all local variables from ASTAnalyzer metrics for 'START'.
Added local variable 'L' of type 1081348 at offset 16 (size 8)
[DEBUG] Registered local 'L' from analyzer metrics.
Added local variable 'S1' of type 1048580 at offset 24 (size 8)
[DEBUG] Registered local 'S1' from analyzer metrics.
Added local variable 'S2' of type 1048580 at offset 32 (size 8)
[DEBUG] Registered local 'S2' from analyzer metrics.
[DEBUG] Entered new scope. Scope stack size: 1
[DEBUG] Using pre-computed register allocation for 'START'.
[DEBUG] No spills needed - all variables fit in registers.
Added X25 to callee_saved_registers_to_save list.
Added X26 to callee_saved_registers_to_save list.
Added X27 to callee_saved_registers_to_save list.
[DEBUG] Attempting to generate prologue for 'START'.
--- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S1                             | POINTER_TO|STRING
+32      | Local: S2                             | POINTER_TO|STRING
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG LEVEL 5] Emitting instruction: STP X29, X30, [SP, #-96]!
[LIVE] Updating live intervals at instruction point -1
[LIVE] Freed register X25 (no active variables)
[LIVE] Freed register X27 (no active variables)
[LIVE] Freed register X26 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: MOV X29, SP
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80
[LIVE] Updating live intervals at instruction point -1
[DEBUG LEVEL 5] Emitting instruction: STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
[LIVE] Updating live intervals at instruction point -1
[DEBUG] Mapping incoming parameters to home registers or stack slots as per allocation plan.
[DEBUG] Registered local variable 'X28' with the allocation system (spilled)
[DEBUG] Registered local variable 'X25' with the allocation system (spilled)
[DEBUG] Registered local variable 'X21' with the allocation system (spilled)
[DEBUG] Registered local variable 'X20' with the allocation system (spilled)
[DEBUG] Registered local variable 'X19' with the allocation system (spilled)
[DEBUG] Registered local variable 'X27' with the allocation system (spilled)
[DEBUG] Registered local variable 'X26' with the allocation system (spilled)
[DEBUG] Emitted JIT address load sequence for global base pointer (X28).
[DEBUG] Skipping duplicate parameter storage
[DEBUG] --- Call Frame Layout for function: START (Total Size: 96 bytes) ---
Offset   | Content                               | Type
------------------------------------------------------
+0       | Old Frame Pointer (x29)     <-- FP (x29) points here
+8       | Return Address (Caller's PC)
+16      | Local: L                              | POINTER_TO|LIST|STRING
+24      | Local: S1                             | POINTER_TO|STRING
+32      | Local: S2                             | POINTER_TO|STRING
+40      | Saved Reg: X19                        | UNKNOWN
+48      | Saved Reg: X20                        | UNKNOWN
+56      | Saved Reg: X21                        | UNKNOWN
+64      | Saved Reg: X25                        | UNKNOWN
+72      | Saved Reg: X26                        | UNKNOWN
+80      | Saved Reg: X27                        | UNKNOWN
+88      | Saved Reg: X28                        | UNKNOWN
------------------------------------------------------
                                     <-- SP (+96 from FP)

[DEBUG] --- DEBUG: Available CFGs in the map ---
[DEBUG]   Available CFG: 'START'
[DEBUG] --- End of CFG list ---
[DEBUG] Found CFG using lookup_name: START
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str0
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str0_plus_8
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Testing SPLIT->JOIN round-trip...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 0
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str1
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str1_plus_8
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'hello world test'.
[DEBUG] Registering canonical address: S1 = STRING_LITERAL:"hello world test"
[DEBUG] Registered canonical address: S1 = STRING_LITERAL:"hello world test"
[DEBUG]   [CSE INTEGRATION] This variable now holds a known address
[DEBUG] Handling assignment for variable: S1
[DEBUG] store_variable_register for 'S1' from register 'X9'
[DEBUG]   [ALLOCATOR HIT] Variable 'S1' lives in X26. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[LIVE] Updating live intervals at instruction point 1
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X26 for variable 'S1' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X26, X9
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X26, X9
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str2
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str2_plus_8
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Original string: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 2
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S1' in function 'START'
[DEBUG] get_variable_register for: 'S1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S1' lives in register X26
[DEBUG] Variable 'S1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X26 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X26
[DEBUG] Deferring release of source register: X26
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X26
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X26
[DEBUG] Releasing source register: X26
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 3
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3_plus_8
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 4
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str4
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str4_plus_8
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'Calling SPLIT...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 5
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'S1'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S1' in function 'START'
[DEBUG] get_variable_register for: 'S1' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S1' lives in register X26
[DEBUG] Variable 'S1' value loaded into X26
[DEBUG]   [DEBUG] get_variable_register returned: 'X26'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X26
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str5
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str5_plus_8
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal ' '.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Found function symbol: SPLIT with 2 parameters
[DEBUG]   Parameter 0 type: STRING
[DEBUG]   Parameter 1 type: STRING
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X20 expr_type=POINTER_TO|STRING expected=STRING target=STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Arg 1: src=X20 expr_type=POINTER_TO|STRING expected=STRING target=STRING
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X1, X20
[DEBUG] Releasing source register: X20
[DEBUG] Releasing source register: X20
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL SPLIT_veneer
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Handling assignment for variable: L
[DEBUG] store_variable_register for 'L' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'L' lives in X27. Emitting MOV.
[DEBUG]   [LOOP VAR PROTECTION] Extra protection for loop variable: L
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[LIVE] Updating live intervals at instruction point 6
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Register X26 active for variable S1 [0-6]
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X27 for variable 'L' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X27, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X27, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X10 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X10, L_str6
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X26 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: ADD X10, X10, #:lo12:L_str6_plus_8
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'SPLIT completed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X10 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X10
[DEBUG] Deferring release of source register: X10
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X10
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X10
[DEBUG] Releasing source register: X10
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 7
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting TestStatement node (NOTE: branching is handled by block epilogue).
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1081348, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X27
[DEBUG] Variable 'L' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG] LEFT side evaluation complete. left_reg = 'X27'
[DEBUG] OPTIMIZATION: Right operand is constant: 0
[DEBUG] Checking type promotion: left_reg=X27, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X27
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: CMP X9, #0
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: CSET X10, EQ
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X10
[DEBUG LEVEL 5] Emitting instruction: CMP X10, XZR
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_Else_2
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B START_Then_1
[LIVE] Updating live intervals at instruction point 8
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str7
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str7_plus_8
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'SPLIT returned a list, now calling JOIN...
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 9
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting AssignmentStatement node.
[DEBUG]   [CSE DEBUG] *** PROCESSING ASSIGNMENT STATEMENT ***
[DEBUG]   [CSE DEBUG] LHS count: 1, RHS count: 1
[DEBUG] Visiting FunctionCall node (Refactored Dispatcher).
[DEBUG] Visiting VariableAccess node for 'L'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'L' in function 'START'
[DEBUG] get_variable_register for: 'L' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'L' lives in register X27
[DEBUG] Variable 'L' value loaded into X27
[DEBUG]   [DEBUG] get_variable_register returned: 'X27'
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X27
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str8
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str8_plus_8
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '-'.
[DEBUG LEVEL 5] Emitting instruction: MOV X20, X9
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X20 (no active variables)
[SYMBOL TABLE TRACE] Lookup FAILED for symbol: 'JOIN'
[DEBUG] Function symbol not found for: JOIN
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 2
[DEBUG] Arg 0: src=X20 expr_type=POINTER_TO|LIST|STRING expected=UNKNOWN target=POINTER_TO|LIST|STRING
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Arg 1: src=X20 expr_type=POINTER_TO|STRING expected=UNKNOWN target=POINTER_TO|STRING
[DEBUG] Integer arg 1 -> X1 (NGRN=1)
[DEBUG] Queued MOV X1, X20
[DEBUG] Deferring release of source register: X20
[DEBUG] Emitting 2 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X20
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X20
[DEBUG LEVEL 5] Emitting instruction: MOV X1, X20
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X1, X20
[DEBUG] Releasing source register: X20
[DEBUG] Releasing source register: X20
[DEBUG] Final register usage: NGRN=2, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL JOIN_veneer
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Handling assignment for variable: S2
[DEBUG] store_variable_register for 'S2' from register 'X0'
[DEBUG]   [ALLOCATOR HIT] Variable 'S2' lives in X25. Emitting MOV.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X0
[LIVE] Updating live intervals at instruction point 10
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG]   Updating home register X25 for variable 'S2' after store.
[DEBUG LEVEL 5] Emitting instruction: MOV X25, X0
[DEBUG LEVEL 3] Skipping duplicate MOV instruction: MOV X25, X0
[DEBUG] Finished visiting AssignmentStatement node.
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X10 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X10, L_str9
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X10, X10, #:lo12:L_str9_plus_8
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'JOIN completed
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X10 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X10
[DEBUG] Deferring release of source register: X10
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X10
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X10
[DEBUG] Releasing source register: X10
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 11
[LIVE] Register X27 active for variable L [0-11]
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] Visiting TestStatement node (NOTE: branching is handled by block epilogue).
[DEBUG] Visiting BinaryOp node.
[DEBUG] BinaryOp type inference: left_type=1048580, right_type=1
[DEBUG] About to evaluate LEFT side of binary operation
[DEBUG] Visiting VariableAccess node for 'S2'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S2' in function 'START'
[DEBUG] get_variable_register for: 'S2' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S2' lives in register X25
[DEBUG] Variable 'S2' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] LEFT side evaluation complete. left_reg = 'X25'
[DEBUG] OPTIMIZATION: Right operand is constant: 0
[DEBUG] Checking type promotion: left_reg=X25, right_reg=
[DEBUG] NO PROMOTION NEEDED or both same type or constant operand
[DEBUG LEVEL 5] Emitting instruction: MOV X9, X25
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[LIVE] Freed register X27 (no active variables)
[DEBUG] Protected variable home register by copying to scratch register.
[DEBUG LEVEL 5] Emitting instruction: CMP X9, #0
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: CSET X10, EQ
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] OPTIMIZATION: No right register to release (used immediate value)
[DEBUG] Finished visiting BinaryOp node. Result in X10
[DEBUG LEVEL 5] Emitting instruction: CMP X10, XZR
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B.EQ START_Else_5
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B START_Then_4
[LIVE] Updating live intervals at instruction point 12
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str10
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str10_plus_8
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'JOIN result: '.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 13
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Visiting VariableAccess node for 'S2'.
[DEBUG]   [DEBUG] About to call get_variable_register for 'S2' in function 'START'
[DEBUG] get_variable_register for: 'S2' in function 'START'
[DEBUG]   [DEBUG] Current function allocations exist: YES
[DEBUG]   ✅ REGISTER ALLOCATED: Variable 'S2' lives in register X25
[DEBUG] Variable 'S2' value loaded into X25
[DEBUG]   [DEBUG] get_variable_register returned: 'X25'
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X25 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X25
[DEBUG] Deferring release of source register: X25
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X25
[LIVE] Updating live intervals at instruction point 14
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X25
[DEBUG] Releasing source register: X25
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 14
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str3
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str3_plus_8
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal '
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: B .L0
[LIVE] Updating live intervals at instruction point 15
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str11
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str11_plus_8
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'ERROR: SPLIT returned null
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 16
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Register X25 active for variable S2 [0-16]
[DEBUG] --- Entering NewCodeGenerator::visit(RoutineCallStatement& node) [ARM64 ABI COMPLIANT] ---
[DEBUG] Detected a regular function/routine call.
[DEBUG] Generating code for StringLiteral.
[DEBUG] Allocated register X9 for the string address.
[DEBUG LEVEL 5] Emitting instruction: ADRP X9, L_str12
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[LIVE] Freed register X25 (no active variables)
[DEBUG LEVEL 5] Emitting instruction: ADD X9, X9, #:lo12:L_str12_plus_8
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Emitted optimized ADRP/ADD+offset sequence for string literal 'ERROR: JOIN returned null
'.
[DEBUG] === ARM64 ABI Argument Coercion ===
[DEBUG] Total arguments: 1
[DEBUG] Arg 0: src=X9 expr_type=POINTER_TO|STRING expected=INTEGER target=INTEGER
[DEBUG] Integer arg 0 -> X0 (NGRN=0)
[DEBUG] Queued MOV X0, X9
[DEBUG] Deferring release of source register: X9
[DEBUG] Emitting 1 queued operations
[DEBUG LEVEL 5] Emitting instruction: MOV X0, X9
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Executed MOV X0, X9
[DEBUG] Releasing source register: X9
[DEBUG] Final register usage: NGRN=1, NSRN=0
[DEBUG] === END ARM64 ABI Argument Coercion ===
[DEBUG LEVEL 5] Emitting instruction: BL WRITES_veneer
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] --- Exiting NewCodeGenerator::visit(RoutineCallStatement& node) ---
[DEBUG LEVEL 5] Emitting instruction: B START_Exit_7
[LIVE] Updating live intervals at instruction point 17
[LIVE] Variable L expired from register X27
[LIVE] Variable S1 expired from register X26
[LIVE] Variable S2 expired from register X25
[DEBUG] Performing end-of-function scope cleanup for 'START'.
[DEBUG] Defining epilogue label: .L0
[DEBUG] Attempting to generate epilogue for 'START'.
[DEBUG] Exited scope. Scope stack size: 0
[DEBUG] Finished visiting RoutineDeclaration node.
[DEBUG] Code Generator: Generating code for top-level statements.
[DEBUG] Finished visiting Program node.
[InstructionStream TRACE] Adding label definition: L_str0
[InstructionStream TRACE] Adding label definition: L_str0_plus_8
[InstructionStream TRACE] Adding label definition: L_str1
[InstructionStream TRACE] Adding label definition: L_str1_plus_8
[InstructionStream TRACE] Adding label definition: L_str2
[InstructionStream TRACE] Adding label definition: L_str2_plus_8
[InstructionStream TRACE] Adding label definition: L_str3
[InstructionStream TRACE] Adding label definition: L_str3_plus_8
[InstructionStream TRACE] Adding label definition: L_str4
[InstructionStream TRACE] Adding label definition: L_str4_plus_8
[InstructionStream TRACE] Adding label definition: L_str5
[InstructionStream TRACE] Adding label definition: L_str5_plus_8
[InstructionStream TRACE] Adding label definition: L_str6
[InstructionStream TRACE] Adding label definition: L_str6_plus_8
[InstructionStream TRACE] Adding label definition: L_str7
[InstructionStream TRACE] Adding label definition: L_str7_plus_8
[InstructionStream TRACE] Adding label definition: L_str8
[InstructionStream TRACE] Adding label definition: L_str8_plus_8
[InstructionStream TRACE] Adding label definition: L_str9
[InstructionStream TRACE] Adding label definition: L_str9_plus_8
[InstructionStream TRACE] Adding label definition: L_str10
[InstructionStream TRACE] Adding label definition: L_str10_plus_8
[InstructionStream TRACE] Adding label definition: L_str11
[InstructionStream TRACE] Adding label definition: L_str11_plus_8
[InstructionStream TRACE] Adding label definition: L_str12
[InstructionStream TRACE] Adding label definition: L_str12_plus_8
[DataGenerator TRACE] Entering generate_rodata_section.
[DataGenerator TRACE] Size of list_literals_ vector is: 0
[InstructionStream TRACE] Adding label definition: L__data_segment_base
[DEBUG] Code generation finished.
Code generation complete.

--- Symbol Table After Code Generation ---
Symbol Table (Persistent, All Symbols)
==================================================
Symbol 'HeapManager_enter_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'HeapManager_exit_scope' (FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='Global')
Symbol 'START' (ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='START')
Symbol 'S1' (LOCAL_VAR, POINTER_TO|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'L' (LOCAL_VAR, POINTER_TO|LIST|STRING, scope=2, block=0, class_name='', function_name='START')
Symbol 'S2' (LOCAL_VAR, POINTER_TO|STRING, scope=3, block=0, class_name='', function_name='START')
Symbol 'READN' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'RND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'RAND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'LENGTH' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'GETBYTE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'GETWORD' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'READF' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'FLTOFX' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FSIN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FCOS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FTAN' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FABS' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FLOG' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FEXP' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'FRND' (RUNTIME_FLOAT_FUNCTION, FLOAT, scope=0, block=0, class_name='', function_name='')
Symbol 'WRITES' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'WRITEN' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FWRITE' (RUNTIME_FLOAT_ROUTINE, FLOAT, scope=0, block=0, class_name='', function_name='', parameters=[FLOAT])
Symbol 'WRITEF' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'PUTBYTE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'PUTWORD' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'EXIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'NEWLINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'NEWPAGE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SPLIT' (RUNTIME_LIST_FUNCTION, POINTER_TO|LIST|STRING, scope=0, block=0, class_name='', function_name='', parameters=[STRING, STRING])
Symbol 'FILE_OPEN_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_OPEN_APPEND' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'FILE_CLOSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_WRITES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'FILE_READS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_READ' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_WRITE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_SEEK' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'FILE_TELL' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'FILE_EOF' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_INIT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_INIT_SUBSYSTEMS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_QUIT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CREATE_WINDOW' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING])
Symbol 'SDL2_CREATE_WINDOW_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[STRING, INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_WINDOW' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_WINDOW_TITLE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, STRING])
Symbol 'SDL2_SET_WINDOW_SIZE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CREATE_RENDERER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_CREATE_RENDERER_EX' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_DESTROY_RENDERER' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_SET_DRAW_COLOR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_CLEAR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_PRESENT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_DRAW_POINT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_LINE' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_DRAW_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_FILL_RECT' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER, INTEGER, INTEGER, INTEGER])
Symbol 'SDL2_POLL_EVENT' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_KEY' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_EVENT_MOUSE' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER, INTEGER])
Symbol 'SDL2_GET_EVENT_BUTTON' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_DELAY' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='', parameters=[INTEGER])
Symbol 'SDL2_GET_TICKS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_ERROR' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_CLEAR_ERROR' (RUNTIME_ROUTINE, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VERSION' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_VIDEO_DRIVERS' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_CURRENT_VIDEO_DRIVER' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_GET_DISPLAY_MODES' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')
Symbol 'SDL2_TEST_BASIC' (RUNTIME_FUNCTION, INTEGER, scope=0, block=0, class_name='', function_name='')

Data sections generated.

=== Peephole Optimization ===
Analyzing 459 ARM64 instructions...
Maximum optimization passes: 5

[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 30
  Before:
    STR X19, [X29, #40] ; Saved Reg: X19 @ FP+40  [Opcode=26, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
    STR X20, [X29, #48] ; Saved Reg: X20 @ FP+48  [Opcode=26, Dest=-1, Src1=20, Imm=48, Base=29, Offset=48]
  After:
    STP x19, x20, [x29, #40]  [Opcode=30, Dest=-1, Src1=19, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 31
  Before:
    STR X21, [X29, #56] ; Saved Reg: X21 @ FP+56  [Opcode=26, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
    STR X25, [X29, #64] ; Saved Reg: X25 @ FP+64  [Opcode=26, Dest=-1, Src1=25, Imm=64, Base=29, Offset=64]
  After:
    STP x21, x25, [x29, #56]  [Opcode=30, Dest=-1, Src1=21, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register STRs into STP
  Position: 32
  Before:
    STR X26, [X29, #72] ; Saved Reg: X26 @ FP+72  [Opcode=26, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
    STR X27, [X29, #80] ; Saved Reg: X27 @ FP+80  [Opcode=26, Dest=-1, Src1=27, Imm=80, Base=29, Offset=80]
  After:
    STP x26, x27, [x29, #72]  [Opcode=30, Dest=-1, Src1=26, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: In-place comparison optimization (MOV-CMP -> CMP)
  Position: 72
  Before:
    MOV X9, X27  [Opcode=1, Dest=9, Src1=27]
    CMP X9, #0  [Opcode=24, Dest=-1, Src1=9, Imm=0]
  After:
    CMP x27, #0  [Opcode=24, Dest=-1, Src1=27, Imm=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: In-place comparison optimization (MOV-CMP -> CMP)
  Position: 94
  Before:
    MOV X9, X25  [Opcode=1, Dest=9, Src1=25]
    CMP X9, #0  [Opcode=24, Dest=-1, Src1=9, Imm=0]
  After:
    CMP x25, #0  [Opcode=24, Dest=-1, Src1=25, Imm=0]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 126
  Before:
    LDR X19, [X29, #40] ; Restored Reg: X19 @ FP+40  [Opcode=27, Dest=19, Src1=-1, Imm=40, Base=29, Offset=40]
    LDR X20, [X29, #48] ; Restored Reg: X20 @ FP+48  [Opcode=27, Dest=20, Src1=-1, Imm=48, Base=29, Offset=48]
  After:
    LDP x19, x20, [x29, #40]  [Opcode=31, Dest=19, Src1=20, Imm=40, Base=29, Offset=40]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 127
  Before:
    LDR X21, [X29, #56] ; Restored Reg: X21 @ FP+56  [Opcode=27, Dest=21, Src1=-1, Imm=56, Base=29, Offset=56]
    LDR X25, [X29, #64] ; Restored Reg: X25 @ FP+64  [Opcode=27, Dest=25, Src1=-1, Imm=64, Base=29, Offset=64]
  After:
    LDP x21, x25, [x29, #56]  [Opcode=31, Dest=21, Src1=25, Imm=56, Base=29, Offset=56]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 128
  Before:
    LDR X26, [X29, #72] ; Restored Reg: X26 @ FP+72  [Opcode=27, Dest=26, Src1=-1, Imm=72, Base=29, Offset=72]
    LDR X27, [X29, #80] ; Restored Reg: X27 @ FP+80  [Opcode=27, Dest=27, Src1=-1, Imm=80, Base=29, Offset=80]
  After:
    LDP x26, x27, [x29, #72]  [Opcode=31, Dest=26, Src1=27, Imm=72, Base=29, Offset=72]
  Instruction count: 2 -> 1


[Peephole Optimizer] Applied: Combine adjacent X-register LDRs into LDP
  Position: 131
  Before:
    LDR X29, [SP, #0] ; Restore caller's Frame Pointer  [Opcode=27, Dest=29, Src1=-1, Imm=0, Base=31, Offset=0]
    LDR X30, [SP, #8] ; Restore Link Register  [Opcode=27, Dest=30, Src1=-1, Imm=8, Base=31, Offset=8]
  After:
    LDP x29, x30, [SP, #0]  [Opcode=31, Dest=29, Src1=30, Imm=0, Base=31, Offset=0]
  Instruction count: 2 -> 1

[Peephole Optimizer] Completed pass 1/5, changes made: yes
Peephole optimization completed 2 
  Passes with changes: 1
Peephole optimization completed 2 passes:
  Instructions before: 459
  Instructions after:  450
  Total optimizations: 9
  Patterns matched:
    - Combine adjacent X-register LDRs into LDP: 4
    - In-place comparison optimization (MOV-CMP -> CMP): 2
    - Combine adjacent X-register STRs into STP: 3
==============================
[Peephole Optimizer] Detailed peephole optimization trace complete
Populating JIT memory according to linker layout...

--- CodeBuffer JIT Listing ------ Code Section Listing (Base Address: 0x1066ec000) ---
Address Hex Code    Assembly
--------------------------------------------------
 1066ec000 0x00000000  
; --- Veneer Section ---
HeapManager_enter_scope_veneer:
 1066ec004 0xd29fa710  MOVZ X16, #64824
 1066ec008 0xf2a02230  MOVK X16, #273, LSL #16
 1066ec00c 0xf2c00030  MOVK X16, #1, LSL #32
 1066ec010 0xd61f0200  BR X16
HeapManager_exit_scope_veneer:
 1066ec014 0xd29fac90  MOVZ X16, #64868
 1066ec018 0xf2a02230  MOVK X16, #273, LSL #16
 1066ec01c 0xf2c00030  MOVK X16, #1, LSL #32
 1066ec020 0xd61f0200  BR X16
JOIN_veneer:
 1066ec024 0xd29e8710  MOVZ X16, #62520
 1066ec028 0xf2a022b0  MOVK X16, #277, LSL #16
 1066ec02c 0xf2c00030  MOVK X16, #1, LSL #32
 1066ec030 0xd61f0200  BR X16
SPLIT_veneer:
 1066ec034 0xd29e8c90  MOVZ X16, #62564
 1066ec038 0xf2a022b0  MOVK X16, #277, LSL #16
 1066ec03c 0xf2c00030  MOVK X16, #1, LSL #32
 1066ec040 0xd61f0200  BR X16
WRITES_veneer:
 1066ec044 0xd2978310  MOVZ X16, #48152
 1066ec048 0xf2a022b0  MOVK X16, #277, LSL #16
 1066ec04c 0xf2c00030  MOVK X16, #1, LSL #32
 1066ec050 0xd61f0200  BR X16
 1066ec054 0x00000000  ; --- End Veneer Section ---

START:
 1066ec058 0xa9ba7bfd  STP X29, X30, [SP, #-96]!
 1066ec05c 0x910003fd  MOV X29, SP
 1066ec060 0xa902d3b3  STP x19, x20, [x29, #40]
 1066ec064 0xa903e7b5  STP x21, x25, [x29, #56]
 1066ec068 0xa904efba  STP x26, x27, [x29, #72]
 1066ec06c 0xf9002fbc  STR X28, [X29, #88] ; Saved Reg: X28 @ FP+88
 1066ec070 0xd298001c  MOVZ X28, #49152
 1066ec074 0xf2a0cbdc  MOVK X28, #1630, LSL #16
 1066ec078 0xf2c0003c  MOVK X28, #1, LSL #32
 1066ec07c 0xf2e0001c  MOVK X28, #0, LSL #48
START_Entry_0:
 1066ec080 0xb0000029  ADRP X9, L_str0    ; Reloc -> 'L_str0' @ 0x1066f1000
 1066ec084 0x91002129  ADD X9, X9, #:lo12:L_str0_plus_8    ; Reloc -> 'L_str0' @ 0x1066f1000
 1066ec088 0xaa0903e0  MOV X0, X9
 1066ec08c 0x97ffffee  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec090 0xb0000029  ADRP X9, L_str1    ; Reloc -> 'L_str1' @ 0x1066f1098
 1066ec094 0x91028129  ADD X9, X9, #:lo12:L_str1_plus_8    ; Reloc -> 'L_str1' @ 0x1066f1098
 1066ec098 0xaa0903fa  MOV X26, X9
 1066ec09c 0xb0000029  ADRP X9, L_str2    ; Reloc -> 'L_str2' @ 0x1066f10e8
 1066ec0a0 0x9103c129  ADD X9, X9, #:lo12:L_str2_plus_8    ; Reloc -> 'L_str2' @ 0x1066f10e8
 1066ec0a4 0xaa0903e0  MOV X0, X9
 1066ec0a8 0x97ffffe7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec0ac 0xaa1a03e0  MOV X0, X26
 1066ec0b0 0x97ffffe5  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec0b4 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x1066f113c
 1066ec0b8 0x91051129  ADD X9, X9, #:lo12:L_str3_plus_8    ; Reloc -> 'L_str3' @ 0x1066f113c
 1066ec0bc 0xaa0903e0  MOV X0, X9
 1066ec0c0 0x97ffffe1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec0c4 0xb0000029  ADRP X9, L_str4    ; Reloc -> 'L_str4' @ 0x1066f1150
 1066ec0c8 0x91056129  ADD X9, X9, #:lo12:L_str4_plus_8    ; Reloc -> 'L_str4' @ 0x1066f1150
 1066ec0cc 0xaa0903e0  MOV X0, X9
 1066ec0d0 0x97ffffdd  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec0d4 0xaa1a03f4  MOV X20, X26
 1066ec0d8 0xb0000029  ADRP X9, L_str5    ; Reloc -> 'L_str5' @ 0x1066f11a4
 1066ec0dc 0x9106b129  ADD X9, X9, #:lo12:L_str5_plus_8    ; Reloc -> 'L_str5' @ 0x1066f11a4
 1066ec0e0 0xaa0903f4  MOV X20, X9
 1066ec0e4 0xaa1403e0  MOV X0, X20
 1066ec0e8 0xaa1403e1  MOV X1, X20
 1066ec0ec 0x97ffffd2  BL SPLIT_veneer    ; Reloc -> 'SPLIT_veneer' @ 0x1066ec034
 1066ec0f0 0xaa0003fb  MOV X27, X0
 1066ec0f4 0xb000002a  ADRP X10, L_str6    ; Reloc -> 'L_str6' @ 0x1066f11b8
 1066ec0f8 0x9107014a  ADD X10, X10, #:lo12:L_str6_plus_8    ; Reloc -> 'L_str6' @ 0x1066f11b8
 1066ec0fc 0xaa0a03e0  MOV X0, X10
 1066ec100 0x97ffffd1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec104 0xf100037f  CMP x27, #0
 1066ec108 0x9a9f17ea  CSET X10, EQ
 1066ec10c 0xeb1f015f  CMP X10, XZR
 1066ec110 0x54000040  B.EQ START_Else_2    ; Reloc -> 'START_Else_2' @ 0x1066ec118
 1066ec114 0x14000022  B START_Then_1    ; Reloc -> 'START_Then_1' @ 0x1066ec19c
START_Else_2:
 1066ec118 0xb0000029  ADRP X9, L_str7    ; Reloc -> 'L_str7' @ 0x1066f1208
 1066ec11c 0x91084129  ADD X9, X9, #:lo12:L_str7_plus_8    ; Reloc -> 'L_str7' @ 0x1066f1208
 1066ec120 0xaa0903e0  MOV X0, X9
 1066ec124 0x97ffffc8  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec128 0xaa1b03f4  MOV X20, X27
 1066ec12c 0xb0000029  ADRP X9, L_str8    ; Reloc -> 'L_str8' @ 0x1066f12c4
 1066ec130 0x910b3129  ADD X9, X9, #:lo12:L_str8_plus_8    ; Reloc -> 'L_str8' @ 0x1066f12c4
 1066ec134 0xaa0903f4  MOV X20, X9
 1066ec138 0xaa1403e0  MOV X0, X20
 1066ec13c 0xaa1403e1  MOV X1, X20
 1066ec140 0x97ffffb9  BL JOIN_veneer    ; Reloc -> 'JOIN_veneer' @ 0x1066ec024
 1066ec144 0xaa0003f9  MOV X25, X0
 1066ec148 0xb000002a  ADRP X10, L_str9    ; Reloc -> 'L_str9' @ 0x1066f12d8
 1066ec14c 0x910b814a  ADD X10, X10, #:lo12:L_str9_plus_8    ; Reloc -> 'L_str9' @ 0x1066f12d8
 1066ec150 0xaa0a03e0  MOV X0, X10
 1066ec154 0x97ffffbc  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec158 0xf100033f  CMP x25, #0
 1066ec15c 0x9a9f17ea  CSET X10, EQ
 1066ec160 0xeb1f015f  CMP X10, XZR
 1066ec164 0x54000040  B.EQ START_Else_5    ; Reloc -> 'START_Else_5' @ 0x1066ec16c
 1066ec168 0x14000012  B START_Then_4    ; Reloc -> 'START_Then_4' @ 0x1066ec1b0
START_Else_5:
 1066ec16c 0xb0000029  ADRP X9, L_str10    ; Reloc -> 'L_str10' @ 0x1066f1324
 1066ec170 0x910cb129  ADD X9, X9, #:lo12:L_str10_plus_8    ; Reloc -> 'L_str10' @ 0x1066f1324
 1066ec174 0xaa0903e0  MOV X0, X9
 1066ec178 0x97ffffb3  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec17c 0xaa1903e0  MOV X0, X25
 1066ec180 0x97ffffb1  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec184 0xb0000029  ADRP X9, L_str3    ; Reloc -> 'L_str3' @ 0x1066f113c
 1066ec188 0x91051129  ADD X9, X9, #:lo12:L_str3_plus_8    ; Reloc -> 'L_str3' @ 0x1066f113c
 1066ec18c 0xaa0903e0  MOV X0, X9
 1066ec190 0x97ffffad  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec194 0x14000001  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x1066ec198
START_Exit_7:
 1066ec198 0x1400000b  B .L0    ; Reloc -> '.L0' @ 0x1066ec1c4
START_Then_1:
 1066ec19c 0xb0000029  ADRP X9, L_str11    ; Reloc -> 'L_str11' @ 0x1066f1368
 1066ec1a0 0x910dc129  ADD X9, X9, #:lo12:L_str11_plus_8    ; Reloc -> 'L_str11' @ 0x1066f1368
 1066ec1a4 0xaa0903e0  MOV X0, X9
 1066ec1a8 0x97ffffa7  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec1ac 0x17fffffb  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x1066ec198
START_Then_4:
 1066ec1b0 0xb0000029  ADRP X9, L_str12    ; Reloc -> 'L_str12' @ 0x1066f13e4
 1066ec1b4 0x910fb129  ADD X9, X9, #:lo12:L_str12_plus_8    ; Reloc -> 'L_str12' @ 0x1066f13e4
 1066ec1b8 0xaa0903e0  MOV X0, X9
 1066ec1bc 0x97ffffa2  BL WRITES_veneer    ; Reloc -> 'WRITES_veneer' @ 0x1066ec044
 1066ec1c0 0x17fffff6  B START_Exit_7    ; Reloc -> 'START_Exit_7' @ 0x1066ec198
.L0:
 1066ec1c4 0xa942d3b3  LDP x19, x20, [x29, #40]
 1066ec1c8 0xa943e7b5  LDP x21, x25, [x29, #56]
 1066ec1cc 0xa944efba  LDP x26, x27, [x29, #72]
 1066ec1d0 0xf9402fbc  LDR X28, [X29, #88] ; Restored Reg: X28 @ FP+88
 1066ec1d4 0x910003bf  MOV SP, X29 ; Deallocate frame by moving FP to SP
 1066ec1d8 0xa9407bfd  LDP x29, x30, [SP, #0]
 1066ec1dc 0x910043ff  ADD SP, SP, #16 ; Deallocate space for saved FP/LR
 1066ec1e0 0xd65f03c0  RET
L_str0:
 1066f1000 0x22000000  .quad 0x22
 1066f1004 0x00000000  ; (upper half)
L_str0_plus_8:
 1066f1008 0x54000000  DCD 0x54
 1066f100c 0x65000000  DCD 0x65
 1066f1010 0x73000000  DCD 0x73
 1066f1014 0x74000000  DCD 0x74
 1066f1018 0x69000000  DCD 0x69
 1066f101c 0x6e000000  DCD 0x6e
 1066f1020 0x67000000  DCD 0x67
 1066f1024 0x20000000  DCD 0x20
 1066f1028 0x53000000  DCD 0x53
 1066f102c 0x50000000  DCD 0x50
 1066f1030 0x4c000000  DCD 0x4c
 1066f1034 0x49000000  DCD 0x49
 1066f1038 0x54000000  DCD 0x54
 1066f103c 0x2d000000  DCD 0x2d
 1066f1040 0x3e000000  DCD 0x3e
 1066f1044 0x4a000000  DCD 0x4a
 1066f1048 0x4f000000  DCD 0x4f
 1066f104c 0x49000000  DCD 0x49
 1066f1050 0x4e000000  DCD 0x4e
 1066f1054 0x20000000  DCD 0x20
 1066f1058 0x72000000  DCD 0x72
 1066f105c 0x6f000000  DCD 0x6f
 1066f1060 0x75000000  DCD 0x75
 1066f1064 0x6e000000  DCD 0x6e
 1066f1068 0x64000000  DCD 0x64
 1066f106c 0x2d000000  DCD 0x2d
 1066f1070 0x74000000  DCD 0x74
 1066f1074 0x72000000  DCD 0x72
 1066f1078 0x69000000  DCD 0x69
 1066f107c 0x70000000  DCD 0x70
 1066f1080 0x2e000000  DCD 0x2e
 1066f1084 0x2e000000  DCD 0x2e
 1066f1088 0x2e000000  DCD 0x2e
 1066f108c 0xa0000000  DCD 0xa
 1066f1090 0x00000000  DCD 0x0
 1066f1094 0x00000000  DCD 0x0
L_str1:
 1066f1098 0x10000000  .quad 0x10
 1066f109c 0x00000000  ; (upper half)
L_str1_plus_8:
 1066f10a0 0x68000000  DCD 0x68
 1066f10a4 0x65000000  DCD 0x65
 1066f10a8 0x6c000000  DCD 0x6c
 1066f10ac 0x6c000000  DCD 0x6c
 1066f10b0 0x6f000000  DCD 0x6f
 1066f10b4 0x20000000  DCD 0x20
 1066f10b8 0x77000000  DCD 0x77
 1066f10bc 0x6f000000  DCD 0x6f
 1066f10c0 0x72000000  DCD 0x72
 1066f10c4 0x6c000000  DCD 0x6c
 1066f10c8 0x64000000  DCD 0x64
 1066f10cc 0x20000000  DCD 0x20
 1066f10d0 0x74000000  DCD 0x74
 1066f10d4 0x65000000  DCD 0x65
 1066f10d8 0x73000000  DCD 0x73
 1066f10dc 0x74000000  DCD 0x74
 1066f10e0 0x00000000  DCD 0x0
 1066f10e4 0x00000000  DCD 0x0
L_str2:
 1066f10e8 0x11000000  .quad 0x11
 1066f10ec 0x00000000  ; (upper half)
L_str2_plus_8:
 1066f10f0 0x4f000000  DCD 0x4f
 1066f10f4 0x72000000  DCD 0x72
 1066f10f8 0x69000000  DCD 0x69
 1066f10fc 0x67000000  DCD 0x67
 1066f1100 0x69000000  DCD 0x69
 1066f1104 0x6e000000  DCD 0x6e
 1066f1108 0x61000000  DCD 0x61
 1066f110c 0x6c000000  DCD 0x6c
 1066f1110 0x20000000  DCD 0x20
 1066f1114 0x73000000  DCD 0x73
 1066f1118 0x74000000  DCD 0x74
 1066f111c 0x72000000  DCD 0x72
 1066f1120 0x69000000  DCD 0x69
 1066f1124 0x6e000000  DCD 0x6e
 1066f1128 0x67000000  DCD 0x67
 1066f112c 0x3a000000  DCD 0x3a
 1066f1130 0x20000000  DCD 0x20
 1066f1134 0x00000000  DCD 0x0
 1066f1138 0x00000000  DCD 0x0
L_str3:
 1066f113c 0x10000000  .quad 0x1
 1066f1140 0x00000000  ; (upper half)
L_str3_plus_8:
 1066f1144 0xa0000000  DCD 0xa
 1066f1148 0x00000000  DCD 0x0
 1066f114c 0x00000000  DCD 0x0
L_str4:
 1066f1150 0x11000000  .quad 0x11
 1066f1154 0x00000000  ; (upper half)
L_str4_plus_8:
 1066f1158 0x43000000  DCD 0x43
 1066f115c 0x61000000  DCD 0x61
 1066f1160 0x6c000000  DCD 0x6c
 1066f1164 0x6c000000  DCD 0x6c
 1066f1168 0x69000000  DCD 0x69
 1066f116c 0x6e000000  DCD 0x6e
 1066f1170 0x67000000  DCD 0x67
 1066f1174 0x20000000  DCD 0x20
 1066f1178 0x53000000  DCD 0x53
 1066f117c 0x50000000  DCD 0x50
 1066f1180 0x4c000000  DCD 0x4c
 1066f1184 0x49000000  DCD 0x49
 1066f1188 0x54000000  DCD 0x54
 1066f118c 0x2e000000  DCD 0x2e
 1066f1190 0x2e000000  DCD 0x2e
 1066f1194 0x2e000000  DCD 0x2e
 1066f1198 0xa0000000  DCD 0xa
 1066f119c 0x00000000  DCD 0x0
 1066f11a0 0x00000000  DCD 0x0
L_str5:
 1066f11a4 0x10000000  .quad 0x1
 1066f11a8 0x00000000  ; (upper half)
L_str5_plus_8:
 1066f11ac 0x20000000  DCD 0x20
 1066f11b0 0x00000000  DCD 0x0
 1066f11b4 0x00000000  DCD 0x0
L_str6:
 1066f11b8 0x10000000  .quad 0x10
 1066f11bc 0x00000000  ; (upper half)
L_str6_plus_8:
 1066f11c0 0x53000000  DCD 0x53
 1066f11c4 0x50000000  DCD 0x50
 1066f11c8 0x4c000000  DCD 0x4c
 1066f11cc 0x49000000  DCD 0x49
 1066f11d0 0x54000000  DCD 0x54
 1066f11d4 0x20000000  DCD 0x20
 1066f11d8 0x63000000  DCD 0x63
 1066f11dc 0x6f000000  DCD 0x6f
 1066f11e0 0x6d000000  DCD 0x6d
 1066f11e4 0x70000000  DCD 0x70
 1066f11e8 0x6c000000  DCD 0x6c
 1066f11ec 0x65000000  DCD 0x65
 1066f11f0 0x74000000  DCD 0x74
 1066f11f4 0x65000000  DCD 0x65
 1066f11f8 0x64000000  DCD 0x64
 1066f11fc 0xa0000000  DCD 0xa
 1066f1200 0x00000000  DCD 0x0
 1066f1204 0x00000000  DCD 0x0
L_str7:
 1066f1208 0x2b000000  .quad 0x2b
 1066f120c 0x00000000  ; (upper half)
L_str7_plus_8:
 1066f1210 0x53000000  DCD 0x53
 1066f1214 0x50000000  DCD 0x50
 1066f1218 0x4c000000  DCD 0x4c
 1066f121c 0x49000000  DCD 0x49
 1066f1220 0x54000000  DCD 0x54
 1066f1224 0x20000000  DCD 0x20
 1066f1228 0x72000000  DCD 0x72
 1066f122c 0x65000000  DCD 0x65
 1066f1230 0x74000000  DCD 0x74
 1066f1234 0x75000000  DCD 0x75
 1066f1238 0x72000000  DCD 0x72
 1066f123c 0x6e000000  DCD 0x6e
 1066f1240 0x65000000  DCD 0x65
 1066f1244 0x64000000  DCD 0x64
 1066f1248 0x20000000  DCD 0x20
 1066f124c 0x61000000  DCD 0x61
 1066f1250 0x20000000  DCD 0x20
 1066f1254 0x6c000000  DCD 0x6c
 1066f1258 0x69000000  DCD 0x69
 1066f125c 0x73000000  DCD 0x73
 1066f1260 0x74000000  DCD 0x74
 1066f1264 0x2c000000  DCD 0x2c
 1066f1268 0x20000000  DCD 0x20
 1066f126c 0x6e000000  DCD 0x6e
 1066f1270 0x6f000000  DCD 0x6f
 1066f1274 0x77000000  DCD 0x77
 1066f1278 0x20000000  DCD 0x20
 1066f127c 0x63000000  DCD 0x63
 1066f1280 0x61000000  DCD 0x61
 1066f1284 0x6c000000  DCD 0x6c
 1066f1288 0x6c000000  DCD 0x6c
 1066f128c 0x69000000  DCD 0x69
 1066f1290 0x6e000000  DCD 0x6e
 1066f1294 0x67000000  DCD 0x67
 1066f1298 0x20000000  DCD 0x20
 1066f129c 0x4a000000  DCD 0x4a
 1066f12a0 0x4f000000  DCD 0x4f
 1066f12a4 0x49000000  DCD 0x49
 1066f12a8 0x4e000000  DCD 0x4e
 1066f12ac 0x2e000000  DCD 0x2e
 1066f12b0 0x2e000000  DCD 0x2e
 1066f12b4 0x2e000000  DCD 0x2e
 1066f12b8 0xa0000000  DCD 0xa
 1066f12bc 0x00000000  DCD 0x0
 1066f12c0 0x00000000  DCD 0x0
L_str8:
 1066f12c4 0x10000000  .quad 0x1
 1066f12c8 0x00000000  ; (upper half)
L_str8_plus_8:
 1066f12cc 0x2d000000  DCD 0x2d
 1066f12d0 0x00000000  DCD 0x0
 1066f12d4 0x00000000  DCD 0x0
L_str9:
 1066f12d8 0xf0000000  .quad 0xf
 1066f12dc 0x00000000  ; (upper half)
L_str9_plus_8:
 1066f12e0 0x4a000000  DCD 0x4a
 1066f12e4 0x4f000000  DCD 0x4f
 1066f12e8 0x49000000  DCD 0x49
 1066f12ec 0x4e000000  DCD 0x4e
 1066f12f0 0x20000000  DCD 0x20
 1066f12f4 0x63000000  DCD 0x63
 1066f12f8 0x6f000000  DCD 0x6f
 1066f12fc 0x6d000000  DCD 0x6d
 1066f1300 0x70000000  DCD 0x70
 1066f1304 0x6c000000  DCD 0x6c
 1066f1308 0x65000000  DCD 0x65
 1066f130c 0x74000000  DCD 0x74
 1066f1310 0x65000000  DCD 0x65
 1066f1314 0x64000000  DCD 0x64
 1066f1318 0xa0000000  DCD 0xa
 1066f131c 0x00000000  DCD 0x0
 1066f1320 0x00000000  DCD 0x0
L_str10:
 1066f1324 0xd0000000  .quad 0xd
 1066f1328 0x00000000  ; (upper half)
L_str10_plus_8:
 1066f132c 0x4a000000  DCD 0x4a
 1066f1330 0x4f000000  DCD 0x4f
 1066f1334 0x49000000  DCD 0x49
 1066f1338 0x4e000000  DCD 0x4e
 1066f133c 0x20000000  DCD 0x20
 1066f1340 0x72000000  DCD 0x72
 1066f1344 0x65000000  DCD 0x65
 1066f1348 0x73000000  DCD 0x73
 1066f134c 0x75000000  DCD 0x75
 1066f1350 0x6c000000  DCD 0x6c
 1066f1354 0x74000000  DCD 0x74
 1066f1358 0x3a000000  DCD 0x3a
 1066f135c 0x20000000  DCD 0x20
 1066f1360 0x00000000  DCD 0x0
 1066f1364 0x00000000  DCD 0x0
L_str11:
 1066f1368 0x1b000000  .quad 0x1b
 1066f136c 0x00000000  ; (upper half)
L_str11_plus_8:
 1066f1370 0x45000000  DCD 0x45
 1066f1374 0x52000000  DCD 0x52
 1066f1378 0x52000000  DCD 0x52
 1066f137c 0x4f000000  DCD 0x4f
 1066f1380 0x52000000  DCD 0x52
 1066f1384 0x3a000000  DCD 0x3a
 1066f1388 0x20000000  DCD 0x20
 1066f138c 0x53000000  DCD 0x53
 1066f1390 0x50000000  DCD 0x50
 1066f1394 0x4c000000  DCD 0x4c
 1066f1398 0x49000000  DCD 0x49
 1066f139c 0x54000000  DCD 0x54
 1066f13a0 0x20000000  DCD 0x20
 1066f13a4 0x72000000  DCD 0x72
 1066f13a8 0x65000000  DCD 0x65
 1066f13ac 0x74000000  DCD 0x74
 1066f13b0 0x75000000  DCD 0x75
 1066f13b4 0x72000000  DCD 0x72
 1066f13b8 0x6e000000  DCD 0x6e
 1066f13bc 0x65000000  DCD 0x65
 1066f13c0 0x64000000  DCD 0x64
 1066f13c4 0x20000000  DCD 0x20
 1066f13c8 0x6e000000  DCD 0x6e
 1066f13cc 0x75000000  DCD 0x75
 1066f13d0 0x6c000000  DCD 0x6c
 1066f13d4 0x6c000000  DCD 0x6c
 1066f13d8 0xa0000000  DCD 0xa
 1066f13dc 0x00000000  DCD 0x0
 1066f13e0 0x00000000  DCD 0x0
L_str12:
 1066f13e4 0x1a000000  .quad 0x1a
 1066f13e8 0x00000000  ; (upper half)
L_str12_plus_8:
 1066f13ec 0x45000000  DCD 0x45
 1066f13f0 0x52000000  DCD 0x52
 1066f13f4 0x52000000  DCD 0x52
 1066f13f8 0x4f000000  DCD 0x4f
 1066f13fc 0x52000000  DCD 0x52
 1066f1400 0x3a000000  DCD 0x3a
 1066f1404 0x20000000  DCD 0x20
 1066f1408 0x4a000000  DCD 0x4a
 1066f140c 0x4f000000  DCD 0x4f
 1066f1410 0x49000000  DCD 0x49
 1066f1414 0x4e000000  DCD 0x4e
 1066f1418 0x20000000  DCD 0x20
 1066f141c 0x72000000  DCD 0x72
 1066f1420 0x65000000  DCD 0x65
 1066f1424 0x74000000  DCD 0x74
 1066f1428 0x75000000  DCD 0x75
 1066f142c 0x72000000  DCD 0x72
 1066f1430 0x6e000000  DCD 0x6e
 1066f1434 0x65000000  DCD 0x65
 1066f1438 0x64000000  DCD 0x64
 1066f143c 0x20000000  DCD 0x20
 1066f1440 0x6e000000  DCD 0x6e
 1066f1444 0x75000000  DCD 0x75
 1066f1448 0x6c000000  DCD 0x6c
 1066f144c 0x6c000000  DCD 0x6c
 1066f1450 0xa0000000  DCD 0xa
 1066f1454 0x00000000  DCD 0x0
 1066f1458 0x00000000  DCD 0x0

--------------------------

JIT runtime table populated with 124 function pointers.
Set runtime function table memory to read-only.

--- JIT Execution ---
JIT execution enabled. Entry point 'START' at 0x1066ec058
[JITExecutor] Starting execution of JIT-compiled function at address: 0x1066ec058
Testing SPLIT->JOIN round-trip...
Original string: hello world test
Calling SPLIT...
SAMM: Tracked freelist allocation 0x909020000 in scope (depth: 1, scope size: 1)
SAMM: Tracked list allocation 0x909020000 in scope (depth: 1, scope size: 2)
BCPL String Optimizations: Initialized (pool + SIMD)
SAMM: Tracked string pool allocation 0x908d137dc in scope (depth: 1, scope size: 3)
SAMM: Tracked string pool allocation 0x908d137a0 in scope (depth: 1, scope size: 4)
SPLIT completed
SPLIT returned a list, now calling JOIN...
