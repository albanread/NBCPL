// encoders/enc_create_branch_with_link.cpp
#include "Encoder.h"
#include <string>

/**
 * @brief Creates a Branch with Link (BL) instruction for a function call.
 * @details
 * This function generates the machine code for a BL instruction, which performs
 * a direct function call to a labeled address. It stores the return address (PC+4)
 * [cite_start]in the link register (X30) before branching[cite: 94].
 *
 * The branch target is a PC-relative offset encoded as a 26-bit signed immediate.
 * The immediate field is set to 0, and the instruction is tagged with
 * `RelocationType::PC_RELATIVE_26_BIT_OFFSET`. The linker is responsible for
 * calculating the final offset and patching the instruction.
 *
 * The encoding follows the "Unconditional branch (immediate)" format:
 * - **op (bits 31-26)**: `0b100101`.
 * - **imm26 (bits 25-0)**: The 26-bit signed PC-relative immediate (offset / 4).
 *
 * @param label_name The target function's label.
 * @return An `Instruction` object with relocation info.
 */
Instruction Encoder::create_branch_with_link(const std::string& label_name) {
    // The base opcode for the BL instruction is 0x94000000.
    // The immediate field (bits 0-25) is left as zero for the linker to fill in.
    uint32_t encoding = 0x94000000;

    // Format the assembly string.
    std::string assembly_text = "BL " + label_name;

    // Return the completed Instruction object with relocation information.
    Instruction instr(encoding, assembly_text);
    instr.opcode = InstructionDecoder::OpType::BL;
    instr.relocation = RelocationType::PC_RELATIVE_26_BIT_OFFSET;
    instr.target_label = label_name;
    return instr;
}

// encoders/opt_create_ubfx.cpp
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "BitPatcher.h"
#include "Encoder.h"
/**
 * @brief Encodes the ARM64 'UBFX' (Unsigned Bitfield Extract) instruction.
 * @details
 * This function generates the 32-bit machine code to extract a bitfield from a
 * source register, zero-extend it, and place it in a destination register.
 * UBFX is an alias for the UBFM (Unsigned Bitfield Move) instruction.
 * The operation is `UBFX <Xd|Wd>, <Xn|Wn>, #lsb, #width`.
 *
 * The encoding follows the "Bitfield" format for UBFM:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `10` for UBFM.
 * - **Family (bits 28-23)**: `0b100101`.
 * - **N (bit 22)**: Must match `sf`.
 * - **immr (bits 21-16)**: The least significant bit of the source field (`lsb`).
 * - **imms (bits 15-10)**: The most significant bit of the source field (`lsb + width - 1`).
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register (e.g., "x1", "w2").
 * @param lsb The least significant bit of the field to extract (0-63).
 * @param width The width of the bitfield (1-64).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or bitfield parameters.
 */
Instruction Encoder::opt_create_ubfx(const std::string& xd, const std::string& xn, int lsb, int width) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(xd);
    uint32_t rn_num = get_reg_encoding(xn);
    bool is_64bit = (xd[0] == 'x' || xd[0] == 'X');

    if (is_64bit != (xn[0] == 'x' || xn[0] == 'X')) {
        throw std::invalid_argument("Mismatched register sizes for UBFX.");
    }

    // 2. Validate bitfield parameters
    int datasize = is_64bit ? 64 : 32;
    if (lsb < 0 || lsb >= datasize) {
        throw std::invalid_argument("UBFX lsb is out of range for the register size.");
    }
    if (width < 1 || (lsb + width) > datasize) {
        throw std::invalid_argument("UBFX width is out of range or exceeds register size.");
    }

    // 3. Calculate encoding fields for the UBFM alias
    uint32_t n_val = is_64bit ? 1 : 0;
    uint32_t immr_val = static_cast<uint32_t>(lsb);
    uint32_t imms_val = static_cast<uint32_t>(lsb + width - 1);

    // 4. Use BitPatcher to construct the instruction word.
    // Base opcode for UBFM is 0x53000000.
    BitPatcher patcher(0x53000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(n_val, 22, 1);       // N bit
    patcher.patch(immr_val, 16, 6);    // immr (lsb)
    patcher.patch(imms_val, 10, 6);    // imms (msb)
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 5. Format the assembly string and return the Instruction object.
    std::string assembly_text = "UBFX " + xd + ", " + xn + ", #" + std::to_string(lsb) + ", #" + std::to_string(width);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::UBFX;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = lsb;
    instr.uses_immediate = true;
    return instr;
}

// encoders/create_movz_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'MOVZ' (Move with Zero) instruction.
 * @details
 * This function generates the 32-bit machine code to move a 16-bit immediate
 * into a register, zeroing the other bits. The immediate can be shifted to
 * align with any 16-bit boundary in the register.
 * [cite_start]The instruction has the format: `MOVZ <Xd|Wd>, #imm{, LSL #shift}`[cite: 43].
 * [cite_start]The operation is `$rd = i^Ã¸ << sh$`, meaning the immediate is zero-extended and shifted[cite: 44].
 *
 * The encoding follows the "Move wide (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `0b10` for MOVZ.
 * - **Family (bits 28-23)**: `0b100101`.
 * - **hw (bits 22-21)**: The shift amount, encoded as `shift / 16`.
 * - **imm16 (bits 20-5)**: The 16-bit immediate value.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param immediate The 16-bit immediate value to move.
 * @param shift The left shift to apply. Must be 0, 16, 32, or 48.
 * @param rel The relocation type for the instruction, used by the linker.
 * @param target The target symbol for relocation.
 * @return An `Instruction` object containing the encoding and other metadata.
 * @throw std::invalid_argument for invalid registers or invalid shift values.
 */
Instruction Encoder::create_movz_imm(const std::string& xd, uint16_t immediate, int shift, RelocationType rel, const std::string& target) {
    // (A) Self-checking: Validate the shift value.
    if (shift != 0 && shift != 16 && shift != 32 && shift != 48) {
        throw std::invalid_argument("Invalid shift for MOVZ. Must be 0, 16, 32, or 48.");
    }

    // Helper lambda to parse the destination register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_movz_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(xd);

    // A 32-bit register cannot be shifted by 32 or 48.
    if (!rd_is_64 && (shift == 32 || shift == 48)) {
        throw std::invalid_argument("Cannot use a shift of 32 or 48 with a 32-bit 'W' register.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for MOVZ is 0x52800000.
    BitPatcher patcher(0x52800000);

    // Set the size flag (sf) for a 64-bit register destination.
    if (rd_is_64) {
        patcher.patch(1, 31, 1);
    }

    // Encode the shift into the 'hw' field (bits 21-22).
    uint32_t hw = shift / 16;
    patcher.patch(hw, 21, 2);

    // Patch the 16-bit immediate into bits 5-20.
    patcher.patch(immediate, 5, 16);

    // Patch the destination register (Rd) into bits 0-4.
    patcher.patch(rd_num, 0, 5);

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "MOVZ " + xd + ", #" + std::to_string(immediate);
    if (shift > 0) {
        assembly_text += ", LSL #" + std::to_string(shift);
    }

    // (D) Return the completed Instruction object, including relocation info.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::MOVZ;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_mul_vector_reg.cpp
#include "Encoder.h"
#include <sstream>
#include <stdexcept>

Instruction Encoder::create_mul_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    uint32_t rd = get_reg_encoding(vd);
    uint32_t rn = get_reg_encoding(vn);
    uint32_t rm = get_reg_encoding(vm);

    // Base encoding for MUL vector instruction
    // Q | 0 | 0 | 01110 | size[1:0] | 1 | Rm[4:0] | 100111 | Rn[4:0] | Rd[4:0]
    // For integer MUL: opcode = 100111 (bits 15-10)
    uint32_t encoding = 0x0E009C00; // Base with Q=0, opcode=100111

    // Set Q bit, size, and mandatory bit 21 based on arrangement
    if (arrangement == "2S") {
        // Q=0 (64-bit), size=10 for 32-bit elements
        encoding |= (0x2 << 22); // size = 10
        encoding |= (1U << 21);  // mandatory bit 21 = 1
    } else if (arrangement == "4S") {
        // Q=1 (128-bit), size=10 for 32-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x2 << 22);  // size = 10
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else if (arrangement == "8B") {
        // Q=0 (64-bit), size=00 for 8-bit elements
        encoding |= (0x0 << 22); // size = 00
        encoding |= (1U << 21);  // mandatory bit 21 = 1
    } else if (arrangement == "16B") {
        // Q=1 (128-bit), size=00 for 8-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x0 << 22);  // size = 00
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else if (arrangement == "4H") {
        // Q=0 (64-bit), size=01 for 16-bit elements
        encoding |= (0x1 << 22); // size = 01
        encoding |= (1U << 21);  // mandatory bit 21 = 1
    } else if (arrangement == "8H") {
        // Q=1 (128-bit), size=01 for 16-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x1 << 22);  // size = 01
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else {
        throw std::runtime_error("Unsupported arrangement for MUL vector: " + arrangement);
    }

    // Set register fields
    encoding |= (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "MUL " << vd << "." << arrangement << ", " << vn << "." << arrangement << ", " << vm << "." << arrangement;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::MUL_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    return instr;
}
// encoders/enc_create_fdiv_vector_reg.cpp
#include "../Encoder.h"
#include <stdexcept>
#include <iostream>

Instruction Encoder::enc_create_fdiv_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    // FDIV vector register instruction
    // FDIV Vd.<T>, Vn.<T>, Vm.<T>
    // Floating-point divide (vector)
    
    if (arrangement != "2S" && arrangement != "4S" && arrangement != "2D") {
        throw std::runtime_error("Invalid arrangement for FDIV vector: " + arrangement + " (expected 2S, 4S, or 2D)");
    }
    
    // Extract register numbers
    int vd_num = get_reg_encoding(vd);
    int vn_num = get_reg_encoding(vn);
    int vm_num = get_reg_encoding(vm);
    
    if (vd_num < 0 || vd_num > 31 || vn_num < 0 || vn_num > 31 || vm_num < 0 || vm_num > 31) {
        throw std::runtime_error("Invalid vector register in FDIV vector instruction");
    }
    
    // FDIV vector encoding (Advanced SIMD three same)
    // 31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0
    //  0| Q|1|01110| sz|1|      Rm      |111111|      Rn      |      Rd      |
    //
    // sz=0 for 32-bit (S), sz=1 for 64-bit (D)
    // Q=0 for 64-bit vector (2S/1D), Q=1 for 128-bit vector (4S/2D)
    
    uint32_t instruction = 0x2E20FC00; // Base encoding: 0|0|1|01110|0|1|00000|111111|00000|00000
    
    // Set Q bit based on arrangement
    if (arrangement == "4S" || arrangement == "2D") {
        instruction |= (1U << 30); // Set Q=1 for 128-bit
    }
    
    // Set sz bit based on element size
    if (arrangement == "2D") {
        instruction |= (1U << 22); // Set sz=1 for 64-bit elements
    }
    // sz=0 for 32-bit elements (2S, 4S)
    
    // Set register fields
    instruction |= (vm_num << 16);  // Rm field
    instruction |= (vn_num << 5);   // Rn field  
    instruction |= vd_num;          // Rd field
    
    return Instruction(instruction, "FDIV " + vd + "." + arrangement + ", " + vn + "." + arrangement + ", " + vm + "." + arrangement);
}
// encoders/enc_create_csetm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

// Forward declaration of helper functions, assuming they are available.
uint32_t get_condition_code(const std::string& cond);
uint32_t invert_condition_code(uint32_t cond);

namespace {
ConditionCode stringToConditionCode(const std::string& cond) {
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);
    if (upper_cond == "EQ") return ConditionCode::EQ;
    if (upper_cond == "NE") return ConditionCode::NE;
    if (upper_cond == "CS") return ConditionCode::CS;
    if (upper_cond == "CC") return ConditionCode::CC;
    if (upper_cond == "MI") return ConditionCode::MI;
    if (upper_cond == "PL") return ConditionCode::PL;
    if (upper_cond == "VS") return ConditionCode::VS;
    if (upper_cond == "VC") return ConditionCode::VC;
    if (upper_cond == "HI") return ConditionCode::HI;
    if (upper_cond == "LS") return ConditionCode::LS;
    if (upper_cond == "GE") return ConditionCode::GE;
    if (upper_cond == "LT") return ConditionCode::LT;
    if (upper_cond == "GT") return ConditionCode::GT;
    if (upper_cond == "LE") return ConditionCode::LE;
    if (upper_cond == "AL") return ConditionCode::AL;
    if (upper_cond == "NV") return ConditionCode::NV;
    return ConditionCode::UNKNOWN;
}
}

/**
 * @brief Encodes the ARM64 'CSETM' (Conditional Set Mask) instruction.
 * @details
 * This function generates the machine code to set the destination register to all
 * ones (-1) if a condition is TRUE, and to all zeros otherwise.
 *
 * `CSETM` is an alias for the `CSINV` (Conditional Set by Inverting) instruction.
 * The operation `CSETM Rd, cond` is encoded as `CSINV Rd, ZR, ZR, invert(cond)`.
 * The `CSINV` encoding follows the "Conditional select" format.
 *
 * @param Rd The destination register (e.g., "x0", "w1").
 * @param cond The condition mnemonic as a string (e.g., "EQ", "LT", "GE").
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or unrecognized conditions.
 */
Instruction Encoder::create_csetm(const std::string& Rd, const std::string& cond) {
    // (A) Get the numeric condition code and invert it for the CSINV alias.
    uint32_t cond_code = get_condition_code(cond);
    uint32_t inverted_cond_code = invert_condition_code(cond_code);

    // Helper lambda to parse the destination register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_csetm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(Rd);

    // (B) Use BitPatcher to encode CSINV Rd, ZR, ZR, !cond.
    // The base opcode for 32-bit CSINV is 0x5A800000.
    BitPatcher patcher(0x5A800000);

    // Patch sf for 64-bit operation.
    if (rd_is_64) {
        patcher.patch(1, 31, 1);
    }

    // Patch destination register (Rd)
    patcher.patch(rd_num, 0, 5);

    // Patch source registers (Rn and Rm) to be the zero register (31)
    patcher.patch(31, 5, 5);  // Rn = ZR
    patcher.patch(31, 16, 5); // Rm = ZR

    // Patch the INVERTED condition code
    patcher.patch(inverted_cond_code, 12, 4);

    // (C) Format the assembly string for the CSETM alias.
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);
    std::string assembly_text = "CSETM " + Rd + ", " + upper_cond;

    // (D) Return the completed Instruction object.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CSETM;
    instr.dest_reg = Encoder::get_reg_encoding(Rd);

    // Set the semantic condition code field using the helper
    instr.cond = stringToConditionCode(cond);

    return instr;
}

// encoders/create_sub_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'SUB (register)' instruction.
 * @details
 * This function generates the 32-bit machine code for a SUB instruction
 * that subtracts the value of one register from another and stores the result
 * in a destination register.
 * The instruction has the format: `SUB <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * [cite_start]The operation is `$rd = rn - rm$`. [cite: 1]
 *
 * The encoding follows the "Data-processing (register)" format for SUB:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **op (bit 30)**: 1 (for subtraction).
 * - **S (bit 29)**: 0 (do not set flags).
 * - **Family (bits 28-21)**: `0b01011000`.
 * - **Rm (bits 20-16)**: The subtrahend register `xm`.
 * - **Rn (bits 9-5)**: The minuend register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register.
 * @param xn The register to subtract from (minuend).
 * @param xm The register to subtract (subtrahend).
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_sub_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_sub_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for SUB must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit SUB (register) is 0x4B000000.
    BitPatcher patcher(0x4B000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the registers into their respective fields.
    patcher.patch(rd_num, 0, 5);
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rm_num, 16, 5);

    // (C) Format the assembly string.
    std::string assembly_text = "SUB " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::SUB;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/enc_create_add_literal.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Creates an ADD (immediate) instruction for the lower 12 bits of a PC-relative address.
 * @details
 * This function creates the second instruction in a standard two-instruction sequence
 * used to load a full 64-bit address into a register. It is designed to follow
 * an `ADRP` instruction.
 *
 * 1. `ADRP Xd, <label>`: Calculates the address of the 4KB page containing the label.
 * 2. `ADD Xd, Xn, #:lo12:<label>`: This instruction adds the 12-bit offset of the
 * [cite_start]label within that page to complete the address calculation[cite: 97].
 *
 * The immediate field in the encoding is set to 0. The function tags the instruction
 * with `RelocationType::ADD_12_BIT_UNSIGNED_OFFSET` so a linker can calculate the
 * true 12-bit offset later and patch the machine code.
 *
 * @param xd The destination register, which will hold the final address.
 * @param xn The source register from the preceding `ADRP` instruction (usually the same as `xd`).
 * @param label_name The target label for the address calculation.
 * @return An `Instruction` object with relocation information for the linker.
 * @throw std::invalid_argument if registers are not 64-bit 'X' registers.
 */
Instruction Encoder::create_add_literal(const std::string& xd, const std::string& xn, const std::string& label_name) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'x' for address calculations. (Thrown by create_add_literal)");
            }
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);

    // This operation is exclusively for forming 64-bit addresses.
    if (!rd_is_64 || !rn_is_64) {
        throw std::invalid_argument("Operands for ADD (literal) must be 64-bit 'X' registers.");
    }

    // (B) Use BitPatcher. The base for 64-bit ADD (immediate) is 0x91000000.
    // The immediate field (bits 10-21) is intentionally left as zero for the linker to patch.
    BitPatcher patcher(0x91000000);

    // Patch the registers.
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rd_num, 0, 5);  // Rd

    // (C) Format the assembly string to show the common linker relocation directive.
    std::string assembly_text = "ADD " + xd + ", " + xn + ", #:lo12:" + label_name;

    // (D) Return the completed Instruction object with relocation information.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ADD;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.uses_immediate = true; // Although the immediate is patched later, it's conceptually an immediate operation
    instr.relocation = RelocationType::ADD_12_BIT_UNSIGNED_OFFSET;
    instr.target_label = label_name;
    return instr;
}

// encoders/enc_create_ldp_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LDP' (Load Pair of Registers) instruction with an immediate offset.
 * @details
 * This function generates the machine code to load a pair of registers from memory
 * [cite_start]using a base register and a signed immediate offset. [cite: 49, 50, 55]
 * The operation is `LDP <Xt1>, <Xt2>, [<Xn>{, #imm}]`.
 *
 * The encoding follows the "Load/Store Pair (signed offset)" format:
 * - **size (bits 31-30)**: `10` for 64-bit registers, `00` for 32-bit registers.
 * - **Family (bits 29-23)**: `0b1010010`.
 * - **L (bit 22)**: `1` for Load.
 * - **imm7 (bits 21-15)**: A 7-bit signed immediate, scaled by the register size.
 * - **Rt2 (bits 14-10)**: The second destination register.
 * - **Rn (bits 9-5)**: The base address register.
 * - **Rt (bits 4-0)**: The first destination register.
 *
 * @param xt1 The first destination register (e.g., "x0", "w0").
 * @param xt2 The second destination register (e.g., "x1", "w1").
 * @param xn The base address register (e.g., "x2", "sp").
 * @param immediate The signed byte offset. For 64-bit loads, this must be a multiple of 8 in the range [-512, 504]. For 32-bit loads, it must be a multiple of 4 in the range [-256, 252].
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or out-of-range/unaligned immediates.
 */
Instruction Encoder::create_ldp_imm(const std::string& xt1, const std::string& xt2, const std::string& xn, int immediate) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_ldp_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt1_num, rt1_is_64] = parse_register(xt1);
    auto [rt2_num, rt2_is_64] = parse_register(xt2);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rt1_is_64 != rt2_is_64) {
        throw std::invalid_argument("LDP registers to be loaded must be the same size.");
    }
    if (!rn_is_64) {
        throw std::invalid_argument("LDP base register must be a 64-bit 'X' register or SP.");
    }

    uint32_t base_opcode;
    int scale;
    int min_offset, max_offset;

    if (rt1_is_64) { // 64-bit LDP
        base_opcode = 0xA9400000;
        scale = 8;
        min_offset = -512;
        max_offset = 504;
    } else { // 32-bit LDP
        base_opcode = 0x29400000;
        scale = 4;
        min_offset = -256;
        max_offset = 252;
    }

    if (immediate < min_offset || immediate > max_offset || immediate % scale != 0) {
        throw std::invalid_argument("Invalid immediate for LDP. Must be a multiple of " + std::to_string(scale) +
                                  " in range [" + std::to_string(min_offset) + ", " + std::to_string(max_offset) + "].");
    }

    uint32_t imm7 = (immediate / scale) & 0x7F; // Get the 7-bit scaled immediate

    BitPatcher patcher(base_opcode);
    patcher.patch(imm7, 15, 7);
    patcher.patch(rt2_num, 10, 5);
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rt1_num, 0, 5);

    std::string assembly_text = "LDP " + xt1 + ", " + xt2 + ", [" + xn + ", #" + std::to_string(immediate) + "]";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LDP;
    instr.dest_reg = Encoder::get_reg_encoding(xt1); // First destination register
    instr.src_reg1 = Encoder::get_reg_encoding(xt2); // Second destination register
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_movz_movk_jit_addr.cpp
#include "Encoder.h"
#include <string>

std::vector<Instruction> Encoder::create_movz_movk_jit_addr(const std::string& xd, uint64_t address, const std::string& symbol) {
    std::vector<Instruction> instructions;

    // 1. Split the 64-bit address into four 16-bit chunks.
    uint16_t chunk0 = (address >> 0)  & 0xFFFF;
    uint16_t chunk1 = (address >> 16) & 0xFFFF;
    uint16_t chunk2 = (address >> 32) & 0xFFFF;
    uint16_t chunk3 = (address >> 48) & 0xFFFF;

    // 2. Generate MOVZ for the lowest chunk.
    instructions.push_back(Encoder::create_movz_imm(xd, chunk0, 0, RelocationType::NONE, symbol));
    instructions.back().jit_attribute = JITAttribute::JitAddress;

    // 3. Generate MOVK for the three remaining chunks, unconditionally.
    instructions.push_back(Encoder::create_movk_imm(xd, chunk1, 16, RelocationType::NONE, symbol));
    instructions.back().jit_attribute = JITAttribute::JitAddress;

    instructions.push_back(Encoder::create_movk_imm(xd, chunk2, 32, RelocationType::NONE, symbol));
    instructions.back().jit_attribute = JITAttribute::JitAddress;

    instructions.push_back(Encoder::create_movk_imm(xd, chunk3, 48, RelocationType::NONE, symbol));
    instructions.back().jit_attribute = JITAttribute::JitAddress;

    return instructions;
}

// encoders/enc_create_brk.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>

/**
 * @brief Encodes the ARM64 'BRK' (Breakpoint) instruction.
 * @details
 * This function generates the machine code for a BRK instruction, which causes a
 * synchronous exception to be taken. It's primarily used for debugging purposes,
 * allowing a debugger to halt execution at a specific point. The 16-bit immediate
 * can be used to pass information to the debug handler.
 *
 * The instruction has the format: `BRK #imm`.
 *
 * The encoding follows the "Exception generation" format:
 * - **Family (bits 31-21)**: `0b11010100001`
 * - **imm16 (bits 20-5)**: The 16-bit immediate value
 * - **op (bits 4-0)**: `0b00000`
 *
 * @param imm The 16-bit immediate value [0, 65535].
 * @return An `Instruction` object containing the encoding and assembly text.
 */
Instruction Encoder::create_brk(uint16_t imm) {
    // The base opcode for the BRK instruction is 0xD4200000.
    BitPatcher patcher(0xD4200000);

    // Patch the 16-bit immediate into bits 5-20.
    patcher.patch(imm, 5, 16);

    // Format the assembly string.
    std::string assembly_text = "BRK #" + std::to_string(imm);

    // Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::BRK;
    instr.immediate = imm;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_get_cond_encoding.cpp
#include "Encoder.h"
#include <string>
#include <unordered_map>
#include <stdexcept>
#include <algorithm>
#include <cctype>

/**
 * @brief Maps a condition string (e.g., "EQ", "NE") to its 4-bit encoding.
 * @details
 * This helper function translates a standard ARM condition mnemonic string into
 * its corresponding 4-bit integer representation used in instruction encodings.
 * It is not case-sensitive and supports common aliases (e.g., "HS" for "CS").
 * The condition codes are documented in the ARMv8 reference manual [cite: 218].
 *
 * @param cond The condition mnemonic as a string (e.g., "EQ", "ne", "Lt").
 * @return The 4-bit integer code for the condition.
 * @throw std::invalid_argument if the condition is not recognized.
 */
uint32_t Encoder::get_cond_encoding(const std::string& cond) {
    // Use a static map for efficiency; it's initialized only once.
    static const std::unordered_map<std::string, uint32_t> cond_map = {
        {"EQ", 0b0000}, // Equal [cite: 218]
        {"NE", 0b0001}, // Not equal [cite: 218]
        {"CS", 0b0010}, // Carry set [cite: 218]
        {"HS", 0b0010}, // Unsigned higher or same [cite: 218]
        {"CC", 0b0011}, // Carry clear [cite: 218]
        {"LO", 0b0011}, // Unsigned lower [cite: 218]
        {"MI", 0b0100}, // Minus, Negative [cite: 218]
        {"PL", 0b0101}, // Plus, Positive or zero [cite: 218]
        {"VS", 0b0110}, // Overflow [cite: 218]
        {"VC", 0b0111}, // No overflow [cite: 218]
        {"HI", 0b1000}, // Unsigned higher [cite: 218]
        {"LS", 0b1001}, // Unsigned lower or same [cite: 218]
        {"GE", 0b1010}, // Signed greater than or equal [cite: 218]
        {"LT", 0b1011}, // Signed less than [cite: 218]
        {"GT", 0b1100}, // Signed greater than [cite: 218]
        {"LE", 0b1101}, // Signed less than or equal [cite: 218]
        {"AL", 0b1110}, // Always [cite: 218]
        {"NV", 0b1111}  // Always (alternative) [cite: 218]
    };

    // Convert input to uppercase for case-insensitive matching.
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);

    auto it = cond_map.find(upper_cond);
    if (it == cond_map.end()) {
        throw std::invalid_argument("Invalid condition mnemonic: " + cond);
    }
    return it->second;
}

// encoders/enc_create_ld1_vector_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_ld1_vector_reg(const std::string& vt, const std::string& xn, const std::string& arrangement) {
    uint32_t rt = get_reg_encoding(vt);
    uint32_t rn = get_reg_encoding(xn);

    // Encoding for LD1 {Vt.4S}, [Xn]
    // Q(1) | 0 | 0 | 0110 | 1 | L(1) | M(0) | 1 | Rm(11111) | 1100 | Rn | Rt
    uint32_t encoding = 0x4C40CC00 | (rn << 5) | rt;

    std::stringstream ss;
    ss << "LD1 {" << vt << "." << arrangement << "}, [" << xn << "]";
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::LD1_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_fmul_vector_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fmul_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    uint32_t rd = get_reg_encoding(vd);
    uint32_t rn = get_reg_encoding(vn);
    uint32_t rm = get_reg_encoding(vm);

    // Encoding for FMUL Vd.4S, Vn.4S, Vm.4S (32-bit single-precision floats)
    // Q(1) | 0 | 0 | 1110 | 1 | M(0) | 1 | Rm | 1001 | Rn | Rd
    uint32_t encoding = 0x4E209000 | (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "FMUL " << vd << "." << arrangement << ", " << vn << "." << arrangement << ", " << vm << "." << arrangement;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FMUL_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    return instr;
}

// encoders/enc_create_return.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>

/**
 * @brief Creates a 'RET' (Return) instruction.
 * @details
 * This function generates the machine code for a RET instruction, which performs
 * an indirect branch to the address held in the link register (X30). It is the
 * standard way to return from a function.
 *
 * While `RET` is functionally similar to `BR X30`, it uses a distinct opcode
 * that provides a hint to the processor's branch prediction hardware that a
 * function return is occurring.
 *
 * The encoding follows the "Unconditional branch (register)" format for RET:
 * - **Family (bits 31-10)**: Fixed value of `0b1101011001011111000000`.
 * - **Rn (bits 9-5)**: `30` (the Link Register, X30).
 * - **op (bits 4-0)**: Fixed `0b00000`.
 *
 * @return An `Instruction` object for `RET`.
 */
Instruction Encoder::create_return() {
    // The base opcode for the RET instruction family is 0xD65F0000.
    BitPatcher patcher(0xD65F0000);

    // Patch the source register (Rn) to the Link Register (X30).
    patcher.patch(30, 5, 5);

    // The canonical assembly text for this instruction.
    std::string assembly_text = "RET";

    // Return the completed instruction, tagging as a Jump for analysis tools.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::RET;
    instr.src_reg1 = 30; // X30 (Link Register)
    return instr;
}

// encoders/enc_create_str_fp_imm.cpp
#include "../Encoder.h"
#include <stdexcept>
#include "BitPatcher.h"

/**
 * @brief Encodes the ARM64 'STR' (Store Register) for a floating-point/SIMD register.
 * @details
 * This function generates the machine code to store a 64-bit floating-point
 * register (Dd) to memory using a base register (Xn) and an unsigned,
 * scaled immediate offset. The operation is `STR <Dt>, [<Xn>{, #imm}]`.
 *
 * The encoding follows the "Load/Store Register (unsigned immediate)" format:
 * - **size (bits 31-30)**: `11` for 64-bit.
 * - **V (bit 26)**: `1` for SIMD/FP.
 * - **opc (bits 23-22)**: `00` for STR.
 * - **imm12 (bits 21-10)**: A 12-bit unsigned immediate, scaled by 8 for 64-bit access.
 * - **Rn (bits 9-5)**: The base address register.
 * - **Rt (bits 4-0)**: The source floating-point register.
 *
 * @param dt The source floating-point register (e.g., "D0", "D7").
 * @param xn The base address register (e.g., "X29", "SP").
 * @param immediate The unsigned byte offset, which must be a multiple of 8 in the range [0, 32760].
 * @return An `Instruction` object.
 */
Instruction Encoder::create_str_fp_imm(const std::string& dt, const std::string& xn, int immediate) {
    // Validate that the offset is within the valid range and a multiple of 8.
    if (immediate < 0 || immediate > 32760 || immediate % 8 != 0) {
        throw std::runtime_error("STR (FP) immediate offset is out of range [0, 32760] or not a multiple of 8.");
    }

    uint32_t dt_reg = Encoder::get_reg_encoding(dt);
    uint32_t xn_reg = Encoder::get_reg_encoding(xn);
    uint32_t imm12 = static_cast<uint32_t>(immediate / 8);

    // The base opcode for STR Dt, [Xn, #imm] is 0xFD000000.
    // This is derived from the LDR equivalent (0xFD400000) by clearing bit 22 (the L bit).
    BitPatcher patcher(0xFD000000);

    // Patch the required fields into the base opcode.
    patcher.patch(imm12, 10, 12); // Patch the 12-bit scaled immediate.
    patcher.patch(xn_reg, 5, 5);  // Patch the base register (Rn).
    patcher.patch(dt_reg, 0, 5);  // Patch the source register (Rt).

    // Format the assembly string for clarity in listings and debugging.
    std::string assembly_text = "STR " + dt + ", [" + xn + ", #" + std::to_string(immediate) + "]";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::STR_FP;
    instr.src_reg1 = Encoder::get_reg_encoding(dt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_fcvtzs_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fcvtzs_reg(const std::string& xd, const std::string& dn) {
    uint32_t rd = get_reg_encoding(xd);
    uint32_t rn = get_reg_encoding(dn);

    // Encoding for FCVTZS Xd, Dn (from double to signed 64-bit, rounding to zero)
    uint32_t encoding = 0x9E780000 | (rn << 5) | rd;

    std::stringstream ss;
    ss << "FCVTZS " << xd << ", " << dn;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FCVTZS;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    return instr;
}

// encoders/create_cmp_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'CMP (register)' instruction.
 * @details
 * This function generates the 32-bit machine code for a CMP instruction,
 * which compares two registers and sets the condition flags based on the result.
 * CMP is an alias for SUBS with the zero register (XZR/WZR) as the destination.
 * The instruction has the format: `CMP <Xn|Wn>, <Xm|Wm>`.
 *
 * The encoding follows the "Data-processing (register)" format for SUBS:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **op (bit 30)**: 1 (for subtraction).
 * - **S  (bit 29)**: 1 (to set flags).
 * - **Family (bits 28-21)**: `0b01011000`.
 * - **Rm (bits 20-16)**: The second source register `xm`.
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: `0b11111` (the zero register).
 *
 * @param xn The first source register to compare (e.g., "x1", "wsp").
 * @param xm The second source register to compare (e.g., "x2", "wzr").
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_cmp_reg(const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_cmp_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (rn_is_64 != rm_is_64) {
        throw std::invalid_argument("Mismatched register sizes. Operands for CMP (register) must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // The base opcode for a 32-bit SUBS (register) is 0x6B000000.
    BitPatcher patcher(0x6B000000);

    if (rn_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the source registers `Rn` and `Rm`.
    patcher.patch(rm_num, 16, 5);
    patcher.patch(rn_num, 5, 5);

    // Patch the destination register `Rd` to be the zero register (31).
    patcher.patch(31, 0, 5);

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "CMP " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CMP;
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/create_orr_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'ORR' (Bitwise OR) instruction.
 * @details
 * This function generates the 32-bit machine code for an ORR instruction
 * that performs a bitwise OR between two source registers and stores the
 * result in a destination register.
 * The instruction has the format: `ORR <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * The logical operation is `$rd = rn | op2$`, where op2 is the `rm` register.
 *
 * The encoding follows the "Data-processing (register)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-24)**: `0b0101010` for the ORR (register) instruction.
 * - **Rm (bits 20-16)**: The second source register `xm`.
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0").
 * @param xn The first source register.
 * @param xm The second source register.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_orr_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Base opcode for 32-bit ORR (register) is 0x2A000000.
    BitPatcher patcher(0x2A000000);

    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_orr_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for ORR must have the same size.");
    }

    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm
    Instruction instr(patcher.get_value(), "ORR " + xd + ", " + xn + ", " + xm);
    instr.opcode = InstructionDecoder::OpType::ORR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/enc_create_add_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'ADD (immediate)' instruction.
 * @details
 * This function generates the 32-bit machine code for an ADD instruction
 * that adds an immediate value to a register and stores the result
 * in a destination register.
 * The instruction has the format: `ADD <Xd|Wd>, <Xn|Wn>, #imm`.
 *
 * The encoding follows the "Add/subtract (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **op (bit 30)**: 0 (for addition).
 * - **S (bit 29)**: 0 (do not set flags).
 * - **Family (bits 28-24)**: `0b10001`.
 * - **sh (bit 22)**: 0 (for no shift on immediate).
 * - **imm12 (bits 21-10)**: The 12-bit unsigned immediate value.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register.
 * @param xn The source register.
 * @param immediate An unsigned 12-bit immediate value [0, 4095].
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or out-of-range immediates.
 */
Instruction Encoder::create_add_imm(const std::string& xd, const std::string& xn, int immediate) {
    // Ensure all braces are properly closed in the function body.
    // (A) Self-checking: Validate the immediate value.
    if (immediate < 0 || immediate > 4095) {
        throw std::invalid_argument("Immediate for ADD must be an unsigned 12-bit value [0, 4095].");
    }

    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_add_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (B) Parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rd_is_64 != rn_is_64) {
        throw std::invalid_argument("Mismatched register sizes. Operands for ADD (immediate) must be the same size.");
    }

    // (C) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit ADD (imm) is 0x11000000.
    BitPatcher patcher(0x11000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the immediate value (imm12) into bits 10-21.
    patcher.patch(static_cast<uint32_t>(immediate), 10, 12);

    // Patch the source and destination registers.
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rn_num, 5, 5); // Patch the source register.
    patcher.patch(rd_num, 0, 5); // Patch the destination register.

    // (D) Format the assembly string for the Instruction object.
    std::string assembly_text = "ADD " + xd + ", " + xn + ", #" + std::to_string(immediate);

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ADD;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_mvn_reg.cpp
#include "BitPatcher.h"
#include "../Encoder.h"
#include <algorithm>
#include <cctype>
#include <sstream>
#include <stdexcept>

/**
 * @brief Creates an MVN (Move with NOT) instruction, which is an alias for ORN with XZR.
 * @param xd The destination register.
 * @param xm The source register to be bitwise NOT-ed.
 * @return A complete Instruction object.
 */
Instruction Encoder::create_mvn_reg(const std::string& xd, const std::string& xm) {
    // MVN xd, xm  <=>  ORN xd, XZR, xm
    // ARM64: ORN <Xd|Wd>, XZR, <Xm|Wm>
    // We'll emit the assembly as "MVN xd, xm" for clarity.

    // Helper lambda to parse register strings like "x0", "w1", "sp", "wzr".
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix: " + reg_str);
            }
            reg_num = std::stoi(lower_reg.substr(1));
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rm_num, rm_is_64] = parse_register(xm);

    // ORN <Xd|Wd>, XZR, <Xm|Wm>
    // Encoding for ORN (register): same as ORR (register) but with N=1 (bit 21)
    // Base opcode for 32-bit ORN (register) is 0x2A200800.
    BitPatcher patcher(0x2A200800);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(31, 5, 5);      // Rn = XZR/WZR (always 31)
    patcher.patch(rm_num, 16, 5); // Rm

    // Format the assembly string for the Instruction object.
    std::ostringstream oss;
    oss << "MVN " << xd << ", " << xm;

    Instruction instr(patcher.get_value(), oss.str());
    instr.opcode = InstructionDecoder::OpType::ORR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding("XZR");
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/create_and_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'AND (register)' instruction.
 * @details
 * This function generates the 32-bit machine code for an AND instruction
 * that performs a bitwise AND between two source registers and stores the result
 * in a destination register. The instruction has the format:
 * `AND <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * The logical operation is `$rd = rn & op2$`, where op2 is the `rm` register.
 *
 * The encoding follows the "Data-processing (register)" format:
 * - **sf (bit 31)**: 1 for 64-bit (X regs), 0 for 32-bit (W regs).
 * - **opc (bits 30-24)**: `0b0001010` for the AND (register) instruction.
 * - **Rm (bits 20-16)**: The second source register `xm`.
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The first source register (e.g., "x1", "sp").
 * @param xm The second source register (e.g., "x2", "wzr").
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument if register names are invalid or if sizes are mixed.
 */
Instruction Encoder::create_and_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings like "x0", "w1", "sp", "wzr".
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_and_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 30) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'. Use 'wsp'/'sp' or 'wzr'/'xzr' for register 31.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Perform self-checking by parsing and validating all register arguments first.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for AND (register) must be simultaneously 32-bit (W) or 64-bit (X).");
    }

    // (B) Use the BitPatcher to construct the instruction word.
    // Base opcode for 32-bit AND (register) is 0x0A000000.
    BitPatcher patcher(0x0A000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "AND " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::AND;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/create_add_reg.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>
#include <cctype>
#include <algorithm>
#include <vector>

/**
 * @brief Encodes the ARM64 'ADD (register)' instruction.
 * @details
 * This function generates the 32-bit machine code for an ADD instruction
 * that adds two source registers and places the result in a destination register.
 * The operation has the format: `ADD <Xd|Wd>, <Xn|Wn>, <Xm|Wm>` [cite: 1, 6].
 *
 * The encoding follows the "Data-processing (register)" format with the
 * following bitfield layout:
 * - **sf (bit 31)**: 1 for 64-bit (X regs), 0 for 32-bit (W regs).
 * - **opc (bits 30-24)**: A fixed value of `0b0001011` identifies this as an ADD/SUB register operation.
 * - **Rm (bits 20-16)**: The second general-purpose source register, `xm` [cite: 1].
 * - **Rn (bits 9-5)**: The first general-purpose source register, `xn` [cite: 6, 20].
 * - **Rd (bits 4-0)**: The general-purpose destination register, `xd` [cite: 4].
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The first source register (e.g., "x1", "sp").
 * @param xm The second source register (e.g., "x2", "wzr").
 * @return An `Instruction` object containing the encoding and assembly text [cite: 2].
 * @throw std::invalid_argument if register names are invalid or if register sizes are mixed.
 */
Instruction Encoder::create_add_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings like "x0", "w1", "sp", "wzr".
    // Returns the register number (0-31) and a boolean indicating if it's a 64-bit register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_add_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 30) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'. Use 'wsp'/'sp' or 'wzr'/'xzr' for register 31.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Perform self-checking by parsing and validating all register arguments first.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for ADD (register) must be simultaneously 32-bit (W) or 64-bit (X).");
    }

    // (B) Use the BitPatcher to construct the instruction word.
    // Base opcode for 32-bit ADD (register) is 0x0B000000.
    BitPatcher patcher(0x0B000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "ADD " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object, using the constructor from Encoder.h [cite: 2].
    // For this simple instruction, no relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ADD;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/enc_create_csetm_ne.cpp
#include "Encoder.h"

Instruction Encoder::create_csetm_ne(const std::string& xd) {
    return create_csetm(xd, "NE");
}

// encoders/opt_create_and_imm.cpp
#include <algorithm>
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>

/**
 * @brief Encodes the ARM64 'AND' (Bitwise AND) instruction with an immediate.
 * @details
 * This function generates the 32-bit machine code for an AND instruction
 * that performs a bitwise AND between a register and a bitmask immediate.
 * The instruction has the format: `AND <Xd|Wd>, <Xn|Wn>, #imm`.
 *
 * The encoding follows the "Logical (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `00` for AND.
 * - **Family (bits 28-23)**: `0b100100`.
 * - **N (bit 22)**: Encoded based on the immediate pattern.
 * - **immr (bits 21-16)**: Encoded rotation for the immediate.
 * - **imms (bits 15-10)**: Encoded size/pattern for the immediate.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register (e.g., "x1", "sp").
 * @param immediate The immediate value, which must be encodable as a bitmask.
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or unencodable immediates.
 */
Instruction Encoder::opt_create_and_imm(const std::string& xd, const std::string& xn, int64_t immediate) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(xd);
    uint32_t rn_num = get_reg_encoding(xn);
    bool is_64bit = (xd[0] == 'x' || xd[0] == 'X');

    // Ensure register sizes match (simplified check)
    if (is_64bit != (xn[0] == 'x' || xn[0] == 'X')) {
         if ((xn != "sp" && xn != "SP") && (xd != "sp" && xd != "SP")) {
            throw std::invalid_argument("Mismatched register sizes for AND (immediate).");
         }
    }

    // 2. Encode the bitmask immediate
    uint32_t n_val, immr_val, imms_val;
    if (!encode_bitmask_immediate(static_cast<uint64_t>(immediate), is_64bit, n_val, immr_val, imms_val)) {
        throw std::invalid_argument("Immediate value " + std::to_string(immediate) + " cannot be encoded for AND instruction.");
    }

    // 3. Use BitPatcher to construct the instruction word.
    // Base opcode for Logical (immediate) with opc=00 (AND) is 0x12000000.
    BitPatcher patcher(0x12000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(n_val, 22, 1);       // N bit
    patcher.patch(immr_val, 16, 6);    // immr
    patcher.patch(imms_val, 10, 6);    // imms
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 4. Format the assembly string and return the Instruction object.
    std::string assembly_text = "AND " + xd + ", " + xn + ", #" + std::to_string(immediate);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::AND;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_fmov_w_to_s.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>

// ARM64 FMOV (32-bit variant, scalar, from general-purpose register to vector register)
// This instruction moves the contents of a W register to an S register
// Encoding: FMOV Sd, Wn
// 0x1E270000 | (Rn << 5) | Rd
// Where Rn is the W register (bits 5-9) and Rd is the S register (bits 0-4)

Instruction Encoder::create_fmov_w_to_s(const std::string& sd, const std::string& wn) {
    // Parse S register number from "S0", "S1", etc.
    auto parse_s_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'S') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    // Parse W register number from "W0", "W1", etc.
    auto parse_w_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'W') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    int s_dst = parse_s_reg(sd);
    int w_src = parse_w_reg(wn);

    if (s_dst < 0 || s_dst > 31 || w_src < 0 || w_src > 31) {
        throw std::runtime_error("Invalid register for FMOV W to S: " + sd + ", " + wn);
    }

    // FMOV Sd, Wn encoding (32-bit scalar)
    BitPatcher patcher(0x1E270000);
    patcher.patch(w_src, 5, 5); // bits 5-9: source W register
    patcher.patch(s_dst, 0, 5); // bits 0-4: destination S register

    Instruction instr(patcher.get_value(), "FMOV " + sd + ", " + wn);
    instr.opcode = InstructionDecoder::OpType::FMOV;
    instr.dest_reg = Encoder::get_reg_encoding(sd);
    instr.src_reg1 = Encoder::get_reg_encoding(wn);

    return instr;
}
// encoders/enc_create_br_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'BR' (Branch to Register) instruction.
 * @details
 * This function generates the machine code for a BR instruction, which performs
 * an indirect branch to the address held in a general-purpose register.
 * [cite_start]The operation is `PC = Xn`[cite: 95, 99].
 *
 * The encoding follows the "Unconditional branch (register)" format:
 * - **Family (bits 31-10)**: Fixed value of `0b1101011000011111000000`.
 * - [cite_start]**Rn (bits 9-5)**: The source register `xn` holding the target address[cite: 95].
 * - **op (bits 4-0)**: Fixed `0b00000`.
 *
 * @param xn The 64-bit register holding the target branch address.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument if the register is not a 64-bit 'X' register.
 */
Instruction Encoder::create_br_reg(const std::string& xn) {
    // Helper lambda to parse the source register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        // BR instruction requires a 64-bit register.
        if (lower_reg.rfind("x", 0) != 0) {
            throw std::invalid_argument("Invalid register for BR: '" + reg_str + "'. Must be an 'X' register.");
        }

        try {
            uint32_t reg_num = std::stoul(lower_reg.substr(1));
            if (reg_num > 31) {
                throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
            }
            return {reg_num, true}; // is_64bit is always true
        } catch (const std::logic_error&) {
            throw std::invalid_argument("Invalid register format for BR: '" + reg_str + "'.");
        }
    };

    // (A) Parse and validate the register.
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (!rn_is_64) {
        // This check is slightly redundant given the parser, but serves as defense-in-depth.
        throw std::invalid_argument("BR instruction requires a 64-bit 'X' source register.");
    }

    // (B) Use BitPatcher. The base opcode for BR is 0xD61F0000.
    BitPatcher patcher(0xD61F0000);

    // Patch the source register (Rn) into bits 5-9.
    patcher.patch(rn_num, 5, 5);

    // (C) Format the assembly string.
    std::string assembly_text = "BR " + xn;

    // (D) Return the completed Instruction object.
    // Tagging as 'Jump' can be useful for downstream analysis tools.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::BR;
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    return instr;
}

// encoders/enc_create_branch_unconditional.cpp
#include "Encoder.h"
#include <string>

/**
 * @brief Creates an unconditional branch instruction (B) to a label.
 * @details
 * This function generates the machine code for an unconditional branch. The branch
 * target is a PC-relative offset encoded as a 26-bit signed immediate. The ARMv8
 * [cite_start]reference manual describes the operation as `$PC = PC + rel_{27:2}:0_2$`. [cite: 85]
 *
 * The immediate field is set to 0, and the instruction is tagged with
 * `RelocationType::PC_RELATIVE_26_BIT_OFFSET`. The linker is responsible for
 * calculating the final offset from the current program counter (PC) and patching the instruction.
 *
 * The encoding follows the "Unconditional branch (immediate)" format:
 * - **op (bits 31-26)**: `0b000101`.
 * - **imm26 (bits 25-0)**: The 26-bit signed PC-relative immediate (offset / 4).
 *
 * @param label_name The target label.
 * @return An `Instruction` object with relocation info.
 */
Instruction Encoder::create_branch_unconditional(const std::string& label_name) {
    // The base opcode for the B instruction is 0x14000000.
    // The immediate field (bits 0-25) is left as zero for the linker to fill in.
    // No variable parts need to be patched into the encoding at this stage.
    uint32_t encoding = 0x14000000;

    // Format the assembly string.
    std::string assembly_text = "B " + label_name;

    // Return the completed Instruction object with relocation information.
    Instruction instr(encoding, assembly_text);
    instr.opcode = InstructionDecoder::OpType::B;
    instr.relocation = RelocationType::PC_RELATIVE_26_BIT_OFFSET;
    instr.target_label = label_name;
    return instr;
}

// encoders/opt_create_orr_imm.cpp
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "BitPatcher.h"
#include "Encoder.h"
/**
 * @brief Encodes the ARM64 'ORR' (Bitwise OR) instruction with an immediate.
 * @details
 * This function generates the 32-bit machine code for an ORR instruction
 * that performs a bitwise OR between a register and a bitmask immediate.
 * The instruction has the format: `ORR <Xd|Wd>, <Xn|Wn>, #imm`.
 *
 * The encoding follows the "Logical (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bitÃ¥.
 * - **opc (bits 30-29)**: `01` for ORR.
 * - **Family (bits 28-23)**: `0b100100`.
 * - **N (bit 22)**: Encoded based on the immediate pattern.
 * - **immr (bits 21-16)**: Encoded rotation for the immediate.
 * - **imms (bits 15-10)**: Encoded size/pattern for the immediate.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register (e.g., "x1", "sp").
 * @param immediate The immediate value, which must be encodable as a bitmask.
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or unencodable immediates.
 */
Instruction Encoder::opt_create_orr_imm(const std::string& xd, const std::string& xn, int64_t immediate) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(xd);
    uint32_t rn_num = get_reg_encoding(xn);
    bool is_64bit = (xd[0] == 'x' || xd[0] == 'X');

    // Ensure register sizes match (simplified check)
    if (is_64bit != (xn[0] == 'x' || xn[0] == 'X')) {
         if ((xn != "sp" && xn != "SP") && (xd != "sp" && xd != "SP")) {
            throw std::invalid_argument("Mismatched register sizes for ORR (immediate).");
         }
    }

    // 2. Encode the bitmask immediate
    uint32_t n_val, immr_val, imms_val;
    if (!encode_bitmask_immediate(static_cast<uint64_t>(immediate), is_64bit, n_val, immr_val, imms_val)) {
        throw std::invalid_argument("Immediate value " + std::to_string(immediate) + " cannot be encoded for ORR instruction.");
    }

    // 3. Use BitPatcher to construct the instruction word.
    // Base opcode for Logical (immediate) with opc=01 (ORR) is 0x32000000.
    BitPatcher patcher(0x32000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(n_val, 22, 1);       // N bit
    patcher.patch(immr_val, 16, 6);    // immr
    patcher.patch(imms_val, 10, 6);    // imms
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 4. Format the assembly string and return the Instruction object.
    std::string assembly_text = "ORR " + xd + ", " + xn + ", #" + std::to_string(immediate);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ORR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_csetm_eq.cpp
#include "Encoder.h"

Instruction Encoder::create_csetm_eq(const std::string& xd) {
    return create_csetm(xd, "EQ");
}

// encoders/enc_create_cset_eq.cpp
#include "Encoder.h"

Instruction Encoder::create_cset_eq(const std::string& xd) {
    return create_cset(xd, "EQ");
}

// encoders/create_sub_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'SUB (immediate)' instruction.
 * @details
 * This function generates the 32-bit machine code for a SUB instruction
 * that subtracts an immediate value from a register and stores the result
 * in a destination register.
 * The instruction has the format: `SUB <Xd|Wd>, <Xn|Wn>, #imm`.
 *
 * The encoding follows the "Add/subtract (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **op (bit 30)**: 1 (for subtraction).
 * - **S (bit 29)**: 0 (to not set flags).
 * - **Family (bits 28-24)**: `0b10001`.
 * - **sh (bit 22)**: 0 (for no shift on immediate).
 * - **imm12 (bits 21-10)**: The 12-bit unsigned immediate value.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register.
 * @param xn The source register.
 * @param imm An unsigned 12-bit immediate value [0, 4095].
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or out-of-range immediates.
 */
Instruction Encoder::create_sub_imm(const std::string& xd, const std::string& xn, int imm) {
    // (A) Self-checking: Validate the immediate value.
    if (imm < 0 || imm > 4095) {
        throw std::invalid_argument("Immediate for SUB must be an unsigned 12-bit value [0, 4095].");
    }

    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_sub_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (B) Parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rd_is_64 != rn_is_64) {
        throw std::invalid_argument("Mismatched register sizes. Operands for SUB (immediate) must be the same size.");
    }

    // (C) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit SUB (imm) is 0x51000000.
    BitPatcher patcher(0x51000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the immediate value (imm12) into bits 10-21.
    patcher.patch(static_cast<uint32_t>(imm), 10, 12);

    // Patch the source and destination registers.
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rd_num, 0, 5);

    // (D) Format the assembly string.
    std::string assembly_text = "SUB " + xd + ", " + xn + ", #" + std::to_string(imm);

    // (E) Return the completed Instruction object.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::SUB;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = imm;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_ldp_pre_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <stdexcept>

Instruction Encoder::create_ldp_pre_imm(const std::string& xt1, const std::string& xt2, const std::string& xn, int immediate) {
    uint32_t rt1_val = get_reg_encoding(xt1);
    uint32_t rt2_val = get_reg_encoding(xt2);
    uint32_t rn_val = get_reg_encoding(xn);

    if (immediate % 8 != 0) {
        throw std::invalid_argument("LDP immediate must be a multiple of 8.");
    }

    int imm7 = immediate / 8;
    if (imm7 < -64 || imm7 > 63) {
        throw std::out_of_range("LDP immediate out of range for 7-bit signed offset.");
    }

    BitPatcher patcher(0xA9C00000);
    patcher.patch(imm7, 15, 7);
    patcher.patch(rt2_val, 10, 5);
    patcher.patch(rn_val, 5, 5);
    patcher.patch(rt1_val, 0, 5);

    std::string assembly = "LDP " + xt1 + ", " + xt2 + ", [" + xn + ", #" + std::to_string(immediate) + "]!";
    Instruction instr(patcher.get_value(), assembly);
    instr.opcode = InstructionDecoder::OpType::LDP;
    instr.dest_reg = Encoder::get_reg_encoding(xt1);
    instr.src_reg1 = Encoder::get_reg_encoding(xt2);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/opt_create_sbfx.cpp
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "BitPatcher.h"
#include "Encoder.h"
/**
 * @brief Encodes the ARM64 'SBFX' (Signed Bitfield Extract) instruction.
 * @details
 * This function generates the 32-bit machine code to extract a bitfield from a
 * source register, sign-extend it, and place it in a destination register.
 * SBFX is an alias for the SBFM (Signed Bitfield Move) instruction.
 * The operation is `SBFX <Xd|Wd>, <Xn|Wn>, #lsb, #width`.
 *
 * The encoding follows the "Bitfield" format for SBFM:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `00` for SBFM.
 * - **Family (bits 28-23)**: `0b100100`.
 * - **N (bit 22)**: Must match `sf`.
 * - **immr (bits 21-16)**: The least significant bit of the source field (`lsb`).
 * - **imms (bits 15-10)**: The most significant bit of the source field (`lsb + width - 1`).
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register (e.g., "x1", "w2").
 * @param lsb The least significant bit of the field to extract (0-63).
 * @param width The width of the bitfield (1-64).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or bitfield parameters.
 */
Instruction Encoder::opt_create_sbfx(const std::string& xd, const std::string& xn, int lsb, int width) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(xd);
    uint32_t rn_num = get_reg_encoding(xn);
    bool is_64bit = (xd[0] == 'x' || xd[0] == 'X');

    if (is_64bit != (xn[0] == 'x' || xn[0] == 'X')) {
        throw std::invalid_argument("Mismatched register sizes for SBFX.");
    }

    // 2. Validate bitfield parameters
    int datasize = is_64bit ? 64 : 32;
    if (lsb < 0 || lsb >= datasize) {
        throw std::invalid_argument("SBFX lsb is out of range for the register size.");
    }
    if (width < 1 || (lsb + width) > datasize) {
        throw std::invalid_argument("SBFX width is out of range or exceeds register size.");
    }

    // 3. Calculate encoding fields for the SBFM alias
    uint32_t n_val = is_64bit ? 1 : 0;
    uint32_t immr_val = static_cast<uint32_t>(lsb);
    uint32_t imms_val = static_cast<uint32_t>(lsb + width - 1);

    // 4. Use BitPatcher to construct the instruction word.
    // Base opcode for SBFM is 0x13000000.
    BitPatcher patcher(0x13000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(n_val, 22, 1);       // N bit
    patcher.patch(immr_val, 16, 6);    // immr (lsb)
    patcher.patch(imms_val, 10, 6);    // imms (msb)
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 5. Format the assembly string and return the Instruction object.
    std::string assembly_text = "SBFX " + xd + ", " + xn + ", #" + std::to_string(lsb) + ", #" + std::to_string(width);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::SBFX;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = lsb;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_ldr_fp_imm.cpp
#include "Encoder.h"
#include "BitPatcher.h" // Make sure to include BitPatcher
#include <sstream>

Instruction Encoder::create_ldr_fp_imm(const std::string& dt, const std::string& xn, int immediate) {
    // Unsigned offset, must be a multiple of the transfer size (8 bytes for a double).
    if (immediate < 0 || immediate > 32760 || immediate % 8 != 0) {
        throw std::runtime_error("LDR (FP) immediate offset out of range [0, 32760] or not a multiple of 8.");
    }

    uint32_t rt = get_reg_encoding(dt);
    uint32_t rn = get_reg_encoding(xn);
    uint32_t imm12 = static_cast<uint32_t>(immediate / 8);

    // CORRECTED: Use the base opcode for a 64-bit floating-point load (0xFD400000).
    // The previous opcode (0xBD400000) was for a 32-bit load.
    BitPatcher patcher(0xFD400000);

    // Patch the required fields into the base opcode.
    patcher.patch(imm12, 10, 12); // Patch the 12-bit scaled immediate.
    patcher.patch(rn, 5, 5);      // Patch the base register (Rn).
    patcher.patch(rt, 0, 5);      // Patch the destination register (Rt).

    std::stringstream ss;
    ss << "LDR " << dt << ", [" << xn << ", #" << immediate << "]";
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::LDR_FP;
    instr.dest_reg = Encoder::get_reg_encoding(dt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// Overload with comment argument
Instruction Encoder::create_ldr_fp_imm(const std::string& dt, const std::string& xn, int immediate, const std::string& comment) {
    // Unsigned offset, must be a multiple of the transfer size (8 bytes for a double).
    if (immediate < 0 || immediate > 32760 || immediate % 8 != 0) {
        throw std::runtime_error("LDR (FP) immediate offset out of range [0, 32760] or not a multiple of 8.");
    }

    uint32_t rt = get_reg_encoding(dt);
    uint32_t rn = get_reg_encoding(xn);
    uint32_t imm12 = static_cast<uint32_t>(immediate / 8);

    BitPatcher patcher(0xFD400000);

    patcher.patch(imm12, 10, 12);
    patcher.patch(rn, 5, 5);
    patcher.patch(rt, 0, 5);

    std::stringstream ss;
    ss << "LDR " << dt << ", [" << xn << ", #" << immediate << "]";
    if (!comment.empty()) {
        ss << " ; " << comment;
    }
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::LDR_FP;
    instr.dest_reg = Encoder::get_reg_encoding(dt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_fsub_reg.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <sstream>

Instruction Encoder::create_fsub_reg(const std::string& dd, const std::string& dn, const std::string& dm) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(dn);
    uint32_t rm = get_reg_encoding(dm);

    // Correct encoding for FSUB Dd, Dn, Dm (double-precision, type=01)
    // Reference opcode: 0x1E603800 (type field bits [23:22] = 01 for double)
    BitPatcher patcher(0x1E603800);
    patcher.patch(rm, 16, 5); // Rm
    patcher.patch(rn, 5, 5);  // Rn
    patcher.patch(rd, 0, 5);  // Rd

    std::stringstream ss;
    ss << "FSUB " << dd << ", " << dn << ", " << dm;
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::FSUB;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    instr.src_reg2 = Encoder::get_reg_encoding(dm);
    return instr;
}

// encoders/enc_create_fdiv_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fdiv_reg(const std::string& dd, const std::string& dn, const std::string& dm) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(dn);
    uint32_t rm = get_reg_encoding(dm);

    // Encoding for FDIV Dd, Dn, Dm (double-precision, type=01)
    uint32_t encoding = 0x1E601800 | (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "FDIV " << dd << ", " << dn << ", " << dm;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FDIV;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    instr.src_reg2 = Encoder::get_reg_encoding(dm);
    return instr;
}

// encoders/enc_create_fsqrt_reg.cpp
#include "Encoder.h"
#include "BitPatcher.h"

// Implements the ARM64 FSQRT Dd, Dn instruction encoding.
// FSQRT (double-precision) has base encoding 0x1E61C000.
// Dd: destination FP register (0-31), Dn: source FP register (0-31).
Instruction Encoder::create_fsqrt_reg(const std::string& dd, const std::string& dn) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(dn);

    // Encoding for FSQRT Dd, Dn (double-precision): 0x1E61C000
    BitPatcher patcher(0x1E61C000);
    patcher.patch(rn, 5, 5);  // Dn at bits [9:5]
    patcher.patch(rd, 0, 5);  // Dd at bits [4:0]

    std::string asm_text = "FSQRT " + dd + ", " + dn;
    Instruction instr(patcher.get_value(), asm_text);
    instr.opcode = InstructionDecoder::OpType::FSQRT;
    instr.dest_reg = rd + 32; // FP register encoding offset
    instr.src_reg1 = rn + 32; // FP register encoding offset
    return instr;
}

// encoders/enc_create_scvtf_reg.cpp
#include "Encoder.h"
#include <sstream>
#include "BitPatcher.h"

Instruction Encoder::create_scvtf_reg(const std::string& dd, const std::string& xn) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(xn);

    // Use BitPatcher for encoding SCVTF Dd, Xn (from signed 64-bit int to double)
    BitPatcher patcher(0x9E620000);
    patcher.patch(rn, 5, 5); // Patch source register (Rn)
    patcher.patch(rd, 0, 5); // Patch destination register (Rd)

    std::stringstream ss;
    ss << "SCVTF " << dd << ", " << xn;
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::SCVTF;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    return instr;
}

// encoders/enc_create_fsub_vector_reg.cpp
#include "../Encoder.h"
#include <stdexcept>
#include <iostream>

Instruction Encoder::enc_create_fsub_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    // FSUB vector register instruction
    // FSUB Vd.<T>, Vn.<T>, Vm.<T>
    // Floating-point subtract (vector)
    
    if (arrangement != "2S" && arrangement != "4S" && arrangement != "2D") {
        throw std::runtime_error("Invalid arrangement for FSUB vector: " + arrangement + " (expected 2S, 4S, or 2D)");
    }
    
    // Extract register numbers
    int vd_num = get_reg_encoding(vd);
    int vn_num = get_reg_encoding(vn);
    int vm_num = get_reg_encoding(vm);
    
    if (vd_num < 0 || vd_num > 31 || vn_num < 0 || vn_num > 31 || vm_num < 0 || vm_num > 31) {
        throw std::runtime_error("Invalid vector register in FSUB vector instruction");
    }
    
    // FSUB vector encoding (Advanced SIMD three same)
    // 31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0
    //  0| Q|   0|01110| sz|1|      Rm      |100010|      Rn      |      Rd      |
    //
    // sz=0 for 32-bit (S), sz=1 for 64-bit (D)
    // Q=0 for 64-bit vector (2S/1D), Q=1 for 128-bit vector (4S/2D)
    
    uint32_t instruction = 0x0E200C00; // Base encoding: 0|0|0|01110|0|1|00000|100010|00000|00000
    
    // Set Q bit based on arrangement
    if (arrangement == "4S" || arrangement == "2D") {
        instruction |= (1U << 30); // Set Q=1 for 128-bit
    }
    
    // Set sz bit based on element size
    if (arrangement == "2D") {
        instruction |= (1U << 22); // Set sz=1 for 64-bit elements
    }
    // sz=0 for 32-bit elements (2S, 4S)
    
    // Set register fields
    instruction |= (vm_num << 16);  // Rm field
    instruction |= (vn_num << 5);   // Rn field  
    instruction |= vd_num;          // Rd field
    
    return Instruction(instruction, "FSUB " + vd + "." + arrangement + ", " + vn + "." + arrangement + ", " + vm + "." + arrangement);
}
// encoders/enc_create_ldr_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LDR' (Load Register) instruction with an unsigned immediate offset.
 * @details
 * This function generates the machine code to load a register from memory using a
 * base register and an unsigned, scaled immediate offset.
 * The operation is `LDR <Xt>, [<Xn>{, #imm}]`.
 *
 * The encoding follows the "Load/Store Register (unsigned immediate)" format:
 * - **size (bits 31-30)**: `11` for 64-bit, `10` for 32-bit.
 * - **Family (bits 29-24)**: `0b111001`.
 * - **L (bit 22)**: `1` for Load.
 * - **imm12 (bits 21-10)**: A 12-bit unsigned immediate, scaled by the register size (4 or 8).
 * - **Rn (bits 9-5)**: The base address register.
 * - **Rt (bits 4-0)**: The destination register.
 *
 * @param xt The destination register (e.g., "x0", "w0").
 * @param xn The base address register (e.g., "x2", "sp").
 * @param immediate The unsigned byte offset. For 64-bit loads, this must be a multiple of 8 in the range [0, 32760]. For 32-bit, a multiple of 4 in [0, 16380].
 * @param variable_name (optional) The variable name to append as a comment.
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, out-of-range/unaligned immediates, or using a 32-bit base register.
 */

Instruction Encoder::create_ldr_imm(const std::string& xt, const std::string& xn, int immediate, const std::string& variable_name) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31; }
        else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31; }
        else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31; }
        else if (lower_reg == "sp") { is_64bit = true; reg_num = 31; }
        else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_ldr_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt_num, rt_is_64] = parse_register(xt);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (!rn_is_64) {
        throw std::invalid_argument("LDR base register must be a 64-bit 'X' register or SP.");
    }

    uint32_t base_opcode;
    int scale;
    int max_offset;

    if (rt_is_64) {
        base_opcode = 0xF9400000;
        scale = 8;
        max_offset = 32760;
    } else {
        base_opcode = 0xB9400000;
        scale = 4;
        max_offset = 16380;
    }

    if (immediate % scale != 0 || immediate < 0 || immediate > max_offset) {
        throw std::invalid_argument("Immediate value out of range or not aligned.");
    }

    std::string assembly_text = "LDR " + xt + ", [" + xn + ", #" + std::to_string(immediate) + "]";

    // Append the variable name to the comment if provided
    if (!variable_name.empty() && assembly_text.find(variable_name) == std::string::npos) {
        assembly_text += " ; " + variable_name;
    }

    uint32_t instruction = base_opcode | ((immediate / scale) << 10) | (rn_num << 5) | rt_num;
    Instruction instr(instruction, assembly_text);
    instr.opcode = InstructionDecoder::OpType::LDR;
    instr.dest_reg = Encoder::get_reg_encoding(xt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_add_vector_reg.cpp
#include "Encoder.h"
#include <sstream>
#include <stdexcept>

Instruction Encoder::create_add_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    uint32_t rd = get_reg_encoding(vd);
    uint32_t rn = get_reg_encoding(vn);
    uint32_t rm = get_reg_encoding(vm);

    // Base encoding for ADD vector instruction
    // Q | 0 | 0 | 01110 | size[1:0] | 1 | Rm[4:0] | 100001 | Rn[4:0] | Rd[4:0]
    // For integer ADD: opcode = 100001 (bits 15-10)
    uint32_t encoding = 0x0E008400; // Base with Q=0, opcode=100001

    // Set Q bit, size, and mandatory bit 21 based on arrangement
    if (arrangement == "2S") {
        // Q=0 (64-bit), size=10 for 32-bit elements
        encoding |= (0x2 << 22); // size = 10
        encoding |= (1U << 21);  // mandatory bit 21 = 1
    } else if (arrangement == "4S") {
        // Q=1 (128-bit), size=10 for 32-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x2 << 22);  // size = 10
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else if (arrangement == "8B") {
        // Q=0 (64-bit), size=00 for 8-bit elements
        encoding |= (0x0 << 22); // size = 00
        encoding |= (1U << 21);  // mandatory bit 21 = 1
    } else if (arrangement == "16B") {
        // Q=1 (128-bit), size=00 for 8-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x0 << 22);  // size = 00
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else if (arrangement == "4H") {
        // Q=0 (64-bit), size=01 for 16-bit elements
        encoding |= (0x1 << 22); // size = 01
        encoding |= (1U << 21);  // mandatory bit 21 = 1
    } else if (arrangement == "8H") {
        // Q=1 (128-bit), size=01 for 16-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x1 << 22);  // size = 01
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else if (arrangement == "2D") {
        // Q=1 (128-bit), size=11 for 64-bit elements
        encoding |= (1U << 30);   // Q=1
        encoding |= (0x3 << 22);  // size = 11
        encoding |= (1U << 21);   // mandatory bit 21 = 1
    } else {
        throw std::runtime_error("Unsupported arrangement for ADD vector: " + arrangement);
    }

    // Set register fields
    encoding |= (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "ADD " << vd << "." << arrangement << ", " << vn << "." << arrangement << ", " << vm << "." << arrangement;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::ADD_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    return instr;
}
// encoders/enc_create_fadd_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fadd_reg(const std::string& dd, const std::string& dn, const std::string& dm) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(dn);
    uint32_t rm = get_reg_encoding(dm);

    // Encoding for FADD Dd, Dn, Dm (double-precision, type=01)
    uint32_t encoding = 0x1E602800 | (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "FADD " << dd << ", " << dn << ", " << dm;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FADD;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    instr.src_reg2 = Encoder::get_reg_encoding(dm);
    return instr;
}

// encoders/enc_create_movz_movk_abs64.cpp
#include "Encoder.h"
#include <vector>
#include <stdexcept>

/**
 * @brief Creates an EFFICIENT sequence of MOVZ/MOVK instructions to load a 64-bit value.
 * @details
 * This function generates the shortest possible sequence of one MOVZ and up to three MOVK
 * instructions. It intelligently skips 16-bit chunks that are zero.
 *
 * @param xd The destination 64-bit register (must be an 'X' register).
 * @param address The 64-bit absolute address or value to load.
 * @param symbol The symbol name for relocation purposes.
 * @return A `std::vector<Instruction>` containing the minimal instruction sequence.
 */
std::vector<Instruction> Encoder::create_movz_movk_abs64(const std::string& xd, uint64_t address, const std::string& symbol) {
    std::vector<Instruction> instructions;

    // Handle the edge case where the address is zero.
    if (address == 0) {
        instructions.push_back(Encoder::create_movz_imm(xd, 0, 0, RelocationType::MOVZ_MOVK_IMM_0, symbol));
        return instructions;
    }

    // Split the 64-bit address into four 16-bit chunks.
    uint16_t chunks[4];
    chunks[0] = (address >> 0)  & 0xFFFF;
    chunks[1] = (address >> 16) & 0xFFFF;
    chunks[2] = (address >> 32) & 0xFFFF;
    chunks[3] = (address >> 48) & 0xFFFF;

    // Define the corresponding relocation types for each chunk.
    RelocationType relocations[4] = {
        RelocationType::MOVZ_MOVK_IMM_0,
        RelocationType::MOVZ_MOVK_IMM_16,
        RelocationType::MOVZ_MOVK_IMM_32,
        RelocationType::MOVZ_MOVK_IMM_48
    };

    bool is_first_instruction = true;

    // Iterate through the chunks and generate instructions only for non-zero parts.
    for (int i = 0; i < 4; ++i) {
        if (chunks[i] != 0) {
            int shift = i * 16;
            if (is_first_instruction) {
                // The first non-zero chunk uses MOVZ to zero out the rest of the register.
                instructions.push_back(Encoder::create_movz_imm(xd, chunks[i], shift, relocations[i], symbol));
                is_first_instruction = false;
            } else {
                // Subsequent non-zero chunks use MOVK to keep the existing bits.
                instructions.push_back(Encoder::create_movk_imm(xd, chunks[i], shift, relocations[i], symbol));
            }
        }
    }

    return instructions;
}

// encoders/enc_create_fadd_vector_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fadd_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    uint32_t rd = get_reg_encoding(vd);
    uint32_t rn = get_reg_encoding(vn);
    uint32_t rm = get_reg_encoding(vm);

    // Base encoding for FADD (vector)
    uint32_t encoding = 0x4E208400 | (rm << 16) | (rn << 5) | rd;

    // Set the size bits based on the arrangement
    if (arrangement == "4S" || arrangement == "2S") {
        // size bits (22, 23) = 00 for single-precision, Q bit determines 2S vs 4S
        encoding &= ~(0b11 << 22); // Clear size bits (set to 00)
        if (arrangement == "2S") {
            encoding &= ~(1 << 30); // Clear Q bit for 64-bit operation
        }
    } else if (arrangement == "2D") {
        // size bits (22, 23) = 01 for double-precision
        encoding |= (0b01 << 22);
    } else {
        throw std::runtime_error("Unsupported arrangement for FADD: " + arrangement);
    }

    std::stringstream ss;
    ss << "FADD " << vd << "." << arrangement << ", " << vn << "." << arrangement << ", " << vm << "." << arrangement;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FADD_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    return instr;
}

// encoders/enc_create_fcmp_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fcmp_reg(const std::string& dn, const std::string& dm) {
    uint32_t rn = get_reg_encoding(dn);
    uint32_t rm = get_reg_encoding(dm);

    // Encoding for FCMP Dn, Dm (double-precision)
    uint32_t encoding = 0x1E602008 | (rm << 16) | (rn << 5);

    std::stringstream ss;
    ss << "FCMP " << dn << ", " << dm;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FCMP;
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    instr.src_reg2 = Encoder::get_reg_encoding(dm);
    return instr;
}

// encoders/enc_create_ldr_scaled_reg_64bit.cpp
#include "../Encoder.h"
#include "../BitPatcher.h"
#include <string>
#include <stdexcept>
#include <algorithm>
#include <cctype>

/**
 * @brief Encodes an LDR (Load Register) instruction with a scaled 64-bit register offset.
 * @details
 * This function generates the machine code to load a 64-bit register (Xt) from an
 * address computed by a 64-bit base (Xn) plus a shifted 64-bit index register (Xm).
 * The operation is `LDR Xt, [Xn, Xm, LSL #shift]`.
 *
 * For a 64-bit load with a 64-bit index register, the only valid left shift amount defined by the architecture is 3. A shift of 0 (no shift) is also supported.
 *
 * The encoding follows the "Load/Store Register (register offset)" format:
 * - **size (bits 31-30)**: `11` for 64-bit load.
 * - **Family (bits 29-22)**: `0b11100011`.
 * - **L (bit 22)**: `1` for Load.
 * - **Rm (bits 20-16)**: The index register `xm`.
 * - **option (bits 15-13)**: `0b011` for LSL.
 * - **S (bit 12)**: `1` if shift is applied, `0` otherwise.
 * - **Rn (bits 9-5)**: The base address register `xn`.
 * - **Rt (bits 4-0)**: The destination register `xt`.
 *
 * @param xt The 64-bit destination register (e.g., "x0").
 * @param xn The 64-bit base address register (e.g., "x1", "sp").
 * @param xm The 64-bit index register (e.g., "x2").
 * @param shift The left shift amount. **Must be 0 or 3**.
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or unsupported shift values.
 */
Instruction Encoder::create_ldr_scaled_reg_64bit(const std::string& xt, const std::string& xn, const std::string& xm, int shift) {
    // (A) Validate the shift amount for a 64-bit load with a 64-bit register offset.
    if (shift != 0 && shift != 3) {
        throw std::invalid_argument("Invalid shift for 64-bit LDR with 64-bit register offset. Must be 0 or 3.");
    }
    
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr" || lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr" || lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_ldr_scaled_reg_64bit)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (B) Parse and validate registers.
    auto [rt_num, rt_is_64] = parse_register(xt);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!rt_is_64) {
        throw std::invalid_argument("Destination register for LDR (64-bit) must be an 'X' register.");
    }
    if (!rn_is_64 || !rm_is_64) {
        throw std::invalid_argument("Base and index registers for this LDR variant must be 64-bit 'X' registers.");
    }

    // (C) Use BitPatcher.
    // The base opcode for LDR Xt, [Xn, Xm] with LSL option (but no shift applied yet) is 0xF8606000.
    BitPatcher patcher(0xF8606000);

    // Patch registers.
    patcher.patch(rt_num, 0, 5);  // Rt
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // Patch the shift enable bit if a shift is required.
    if (shift == 3) {
        patcher.patch(1, 12, 1); // Set the 'S' bit to enable the LSL #3
    }

    // (D) Format the assembly string.
    std::string assembly_text = "LDR " + xt + ", [" + xn + ", " + xm;
    if (shift > 0) {
        assembly_text += ", LSL #" + std::to_string(shift);
    }
    assembly_text += "]";
    
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LDR;
    instr.dest_reg = Encoder::get_reg_encoding(xt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.src_reg1 = Encoder::get_reg_encoding(xm);
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_dup_scalar.cpp
#include "../Encoder.h"
#include <stdexcept>
#include <iostream>

Instruction Encoder::enc_create_dup_scalar(const std::string& vd, const std::string& rn, const std::string& arrangement) {
    // DUP (scalar) instruction
    // DUP Vd.<T>, Rn
    // Duplicate general-purpose register to vector
    
    if (arrangement != "2S" && arrangement != "4S" && arrangement != "8H" && arrangement != "16B" && 
        arrangement != "2D" && arrangement != "4H" && arrangement != "8B") {
        throw std::runtime_error("Invalid arrangement for DUP: " + arrangement + " (expected 2S, 4S, 8H, 16B, 2D, 4H, 8B)");
    }
    
    // Extract register numbers
    int vd_num = get_reg_encoding(vd);
    int rn_num = get_reg_encoding(rn);
    
    if (vd_num < 0 || vd_num > 31 || rn_num < 0 || rn_num > 31) {
        throw std::runtime_error("Invalid register in DUP instruction");
    }
    
    // DUP (scalar) encoding (Advanced SIMD copy)
    // 31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0
    //  0| Q| 0|01110000|    imm5   | 0| 0| 0| 0| 1|   Rn   |   Rd   |
    //
    // Q=0 for 64-bit vector, Q=1 for 128-bit vector
    // imm5 encodes the element size and index
    
    uint32_t instruction = 0x0E000C00; // Base encoding: 0|0|0|01110000|00000|0|0|0|0|1|00000|00000
    
    // Set Q bit and imm5 based on arrangement
    uint32_t imm5 = 0;
    bool is_128bit = false;
    
    if (arrangement == "8B") {
        imm5 = 0x01; // 00001 for 8-bit elements, 64-bit vector
        is_128bit = false;
    } else if (arrangement == "16B") {
        imm5 = 0x01; // 00001 for 8-bit elements, 128-bit vector
        is_128bit = true;
    } else if (arrangement == "4H") {
        imm5 = 0x02; // 00010 for 16-bit elements, 64-bit vector
        is_128bit = false;
    } else if (arrangement == "8H") {
        imm5 = 0x02; // 00010 for 16-bit elements, 128-bit vector
        is_128bit = true;
    } else if (arrangement == "2S") {
        imm5 = 0x04; // 00100 for 32-bit elements, 64-bit vector
        is_128bit = false;
    } else if (arrangement == "4S") {
        imm5 = 0x04; // 00100 for 32-bit elements, 128-bit vector
        is_128bit = true;
    } else if (arrangement == "2D") {
        imm5 = 0x08; // 01000 for 64-bit elements, 128-bit vector
        is_128bit = true;
    }
    
    // Set Q bit for 128-bit vector
    if (is_128bit) {
        instruction |= (1U << 30); // Set Q=1
    }
    
    // Set imm5 field (bits 16-20)
    instruction |= (imm5 << 16);
    
    // Set register fields
    instruction |= (rn_num << 5);   // Rn field
    instruction |= vd_num;          // Rd field
    
    return Instruction(instruction, "DUP " + vd + "." + arrangement + ", " + rn);
}
// encoders/create_cmp_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'CMP (immediate)' instruction.
 * @details
 * This function generates the 32-bit machine code for a CMP instruction,
 * which compares a register with an immediate value and sets the condition flags.
 * CMP is an alias for SUBS with the zero register (XZR/WZR) as the destination.
 * The instruction has the format: `CMP <Xn|Wn>, #imm`.
 *
 * [cite_start]The encoding follows the "Add/subtract (immediate)" format[cite: 1]:
 * - **sf (bit 31)**: 1 for 64-bit (Xn), 0 for 32-bit (Wn).
 * - **op (bit 30)**: 1 (for subtraction).
 * - **S  (bit 29)**: 1 (to set flags).
 * - **Family (bits 28-24)**: `0b10001`.
 * - **sh (bit 22)**: 0 (for no shift on immediate).
 * - **imm12 (bits 21-10)**: The 12-bit unsigned immediate value.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: `0b11111` (the zero register).
 *
 * @param xn The source register to compare (e.g., "x1", "w5", "sp").
 * @param immediate An unsigned 12-bit immediate value [0, 4095].
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or out-of-range immediates.
 */
Instruction Encoder::create_cmp_imm(const std::string& xn, int immediate) {
    // (A) Self-checking: Validate the immediate value.
    if (immediate < 0 || immediate > 4095) {
        throw std::invalid_argument("Immediate for CMP must be an unsigned 12-bit value [0, 4095].");
    }

    // Helper lambda to parse the source register string.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_cmp_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) { // This will catch invalid numbers but allow x31 for XZR
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rn_num, rn_is_64] = parse_register(xn);

    // (B) Use the BitPatcher to construct the instruction word.
    // The base opcode for a 32-bit SUBS (imm) is 0x71000000.
    BitPatcher patcher(0x71000000);

    if (rn_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the immediate value (imm12) into bits 10-21.
    patcher.patch(static_cast<uint32_t>(immediate), 10, 12);

    // Patch the source register (Rn) into bits 5-9.
    patcher.patch(rn_num, 5, 5);

    // Patch the destination register (Rd) to be the zero register (31).
    patcher.patch(31, 0, 5);

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "CMP " + xn + ", #" + std::to_string(immediate);

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CMP;
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_get_reg_encoding.cpp
#include "Encoder.h"
#include <string>
#include <stdexcept>
#include <algorithm>
#include <cctype>
#include <iostream>
#include <execinfo.h>
#include <cstdlib>

/**
 * @brief Helper function to get the 5-bit integer encoding of a register name.
 * @details
 * This function translates a register name string (e.g., "X0", "w1", "sp", "D0", "V0") into
 * its 5-bit hardware encoding (0-31). It is case-insensitive and handles aliases
 * for the stack pointer (SP) and zero register (WZR/XZR), as well as floating-point
 * and vector registers (D0-D31, V0-V31).
 *
 * @param reg_name The register name as a string.
 * @return The 5-bit integer encoding of the register.
 * @throw std::invalid_argument if the register name is invalid.
 */
uint32_t Encoder::get_reg_encoding(const std::string& reg_name) {
    if (reg_name.empty()) {
        std::cerr << "ERROR: Empty register name detected in get_reg_encoding!" << std::endl;
        std::cerr << "This error occurred during encoder function call." << std::endl;
        
        // Print stack trace
        void *array[10];
        size_t size = backtrace(array, 10);
        char **strings = backtrace_symbols(array, size);
        
        std::cerr << "Stack trace:" << std::endl;
        for (size_t i = 0; i < size; i++) {
            std::cerr << "  " << strings[i] << std::endl;
        }
        free(strings);
        
        throw std::invalid_argument("Register name cannot be empty.");
    }

    // Convert to lowercase for case-insensitive matching.
    std::string lower_reg = reg_name;
    std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

    // Handle aliases for register 31 first.
    if (lower_reg == "wzr" || lower_reg == "xzr" || lower_reg == "wsp" || lower_reg == "sp") {
        return 31;
    }

    // Check for a valid alphabetic prefix.
    char prefix = lower_reg[0];
    if (!std::isalpha(prefix)) {
        throw std::invalid_argument("Invalid register prefix in '" + reg_name + "'. Must be a letter.");
    }

    try {
        // Handle different register types
        if (prefix == 'd' || prefix == 'v' || prefix == 's') { // Added 'v' for vector registers and 's' for single precision FP
            uint32_t reg_num = std::stoul(lower_reg.substr(1));
            if (reg_num > 31) {
                throw std::out_of_range("FP/Vector register number " + std::to_string(reg_num) + 
                                      " is out of the valid range [0, 31].");
            }
            return reg_num;
        } else if (prefix == 'w' || prefix == 'x') {
            uint32_t reg_num = std::stoul(lower_reg.substr(1));
            if (reg_num > 31) {
                throw std::out_of_range("Register number " + std::to_string(reg_num) + 
                                      " is out of the valid range [0, 31].");
            }
            return reg_num;
        } else {
            throw std::invalid_argument("Invalid register prefix in '" + reg_name + 
                                     "'. Must be 'w', 'x', 'd', 'v', or 's'.");
        }
    } catch (const std::logic_error&) {
        throw std::invalid_argument("Invalid register format: " + reg_name);
    }
}

// encoders/enc_create_sub_vector_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_sub_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    uint32_t rd = get_reg_encoding(vd);
    uint32_t rn = get_reg_encoding(vn);
    uint32_t rm = get_reg_encoding(vm);

    // Encoding for SUB Vd.2S, Vn.2S, Vm.2S (vector integer subtract)
    // Q(0) | 1 | 0 | 01110 | 1 | M(0) | 1 | Rm | 1000 | Rn | Rd
    // For .2S (2x32-bit): Q=0, size=10
    uint32_t encoding = 0x6E208000 | (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "SUB " << vd << "." << arrangement << ", " << vn << "." << arrangement << ", " << vm << "." << arrangement;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::SUB_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    return instr;
}
// encoders/enc_create_stp_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'STP' (Store Pair of Registers) instruction with an immediate offset.
 * @details
 * This function generates the machine code to store a pair of registers to memory
 * using a base register and a signed immediate offset.
 * [cite_start]The operation is `STP <Xt1>, <Xt2>, [<Xn>{, #imm}]`[cite: 147].
 *
 * The encoding follows the "Load/Store Pair (signed offset)" format:
 * - **size (bits 31-30)**: `10` for 64-bit, `00` for 32-bit.
 * - **Family (bits 29-23)**: `0b1010010`.
 * - **L (bit 22)**: `0` for **Store**.
 * - **imm7 (bits 21-15)**: A 7-bit signed immediate, scaled by the register size.
 * - **Rt2 (bits 14-10)**: The second source register.
 * - **Rn (bits 9-5)**: The base address register.
 * - **Rt (bits 4-0)**: The first source register.
 *
 * @param xt1 The first source register to store (e.g., "x0", "w0").
 * @param xt2 The second source register to store (e.g., "x1", "w1").
 * @param xn The base address register (e.g., "x2", "sp").
 * @param immediate The signed byte offset. For 64-bit stores, this must be a multiple of 8 in the range [-512, 504]. For 32-bit stores, it must be a multiple of 4 in the range [-256, 252].
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or out-of-range/unaligned immediates.
 */
Instruction Encoder::create_stp_imm(const std::string& xt1, const std::string& xt2, const std::string& xn, int immediate) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_stp_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt1_num, rt1_is_64] = parse_register(xt1);
    auto [rt2_num, rt2_is_64] = parse_register(xt2);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rt1_is_64 != rt2_is_64) {
        throw std::invalid_argument("STP registers to be stored must be the same size.");
    }
    if (!rn_is_64) {
        throw std::invalid_argument("STP base register must be a 64-bit 'X' register or SP.");
    }

    uint32_t base_opcode;
    int scale;
    int min_offset, max_offset;

    if (rt1_is_64) { // 64-bit STP
        base_opcode = 0xA9000000;
        scale = 8;
        min_offset = -512;
        max_offset = 504;
    } else { // 32-bit STP
        base_opcode = 0x29000000;
        scale = 4;
        min_offset = -256;
        max_offset = 252;
    }

    if (immediate < min_offset || immediate > max_offset || immediate % scale != 0) {
        throw std::invalid_argument("Invalid immediate for STP. Must be a multiple of " + std::to_string(scale) +
                                  " in range [" + std::to_string(min_offset) + ", " + std::to_string(max_offset) + "].");
    }

    uint32_t imm7 = (immediate / scale) & 0x7F; // Get the 7-bit scaled immediate

    BitPatcher patcher(base_opcode);
    patcher.patch(imm7, 15, 7);
    patcher.patch(rt2_num, 10, 5);
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rt1_num, 0, 5);

    std::string assembly_text = "STP " + xt1 + ", " + xt2 + ", [" + xn + ", #" + std::to_string(immediate) + "]";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::STP;
    instr.src_reg1 = Encoder::get_reg_encoding(xt1); // First source register
    instr.src_reg2 = Encoder::get_reg_encoding(xt2); // Second source register
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_get_condition_code.cpp
#include "Encoder.h"
#include <string>
#include <unordered_map>
#include <stdexcept>
#include <algorithm>
#include <cctype>

/**
 * @brief Maps a condition string (e.g., "EQ", "NE") to its 4-bit encoding.
 * @details
 * This helper function translates a standard ARM condition mnemonic string into
 * its corresponding 4-bit integer representation. It's not case-sensitive and supports
 * common aliases (e.g., "HS" for "CS") as found in the ARM documentation.
 *
 * @param cond The condition mnemonic as a string (e.g., "EQ", "ne", "Lt").
 * @return The 4-bit integer code for the condition.
 * @throw std::invalid_argument if the condition is not recognized.
 */
uint32_t get_condition_code(const std::string& cond) {
    // A static map is efficient as it's initialized only once.
    static const std::unordered_map<std::string, uint32_t> cond_map = {
        {"EQ", 0b0000}, // Equal [cite: 218]
        {"NE", 0b0001}, // Not equal [cite: 218]
        {"CS", 0b0010}, // Carry set [cite: 218]
        {"HS", 0b0010}, // Unsigned higher or same [cite: 218]
        {"CC", 0b0011}, // Carry clear [cite: 218]
        {"LO", 0b0011}, // Unsigned lower [cite: 218]
        {"MI", 0b0100}, // Minus, Negative [cite: 218]
        {"PL", 0b0101}, // Plus, Positive or zero [cite: 218]
        {"VS", 0b0110}, // Overflow [cite: 218]
        {"VC", 0b0111}, // No overflow [cite: 218]
        {"HI", 0b1000}, // Unsigned higher [cite: 218]
        {"LS", 0b1001}, // Unsigned lower or same [cite: 218]
        {"GE", 0b1010}, // Signed greater than or equal [cite: 218]
        {"LT", 0b1011}, // Signed less than [cite: 218]
        {"GT", 0b1100}, // Signed greater than [cite: 218]
        {"LE", 0b1101}, // Signed less than or equal [cite: 218]
        {"AL", 0b1110}  // Always [cite: 218]
    };

    // Convert input to uppercase for case-insensitive matching.
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);

    auto it = cond_map.find(upper_cond);
    if (it == cond_map.end()) {
        throw std::invalid_argument("Invalid condition mnemonic: " + cond);
    }
    return it->second;
}

// encoders/enc_create_ldrb_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LDRB' (Load Register Byte) instruction with an unsigned immediate offset.
 * @details
 * This function generates the machine code to load a single byte from memory and
 * zero-extend it into the destination register.
 * The operation is `LDRB <Wt|Xt>, [<Xn>{, #imm}]`.
 *
 * The encoding follows the "Load/Store Register (unsigned immediate)" format:
 * - **size (bits 31-30)**: `00` for byte access.
 * - **Family (bits 29-24)**: `0b111001`.
 * - **L (bit 22)**: `1` for Load.
 * - **imm12 (bits 21-10)**: A 12-bit unsigned byte offset.
 * - **Rn (bits 9-5)**: The base address register.
 * - **Rt (bits 4-0)**: The destination register.
 *
 * @param xt The destination register (e.g., "w0", "x0"). The loaded byte is zero-extended.
 * @param xn The base address register (e.g., "x1", "sp").
 * @param immediate The unsigned byte offset, in the range [0, 4095].
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or out-of-range immediates.
 */
Instruction Encoder::create_ldrb_imm(const std::string& xt, const std::string& xn, int immediate) {
    // (A) Validate the immediate offset.
    if (immediate < 0 || immediate > 4095) {
        throw std::invalid_argument("Immediate for LDRB must be an unsigned 12-bit value [0, 4095].");
    }

    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_ldrb_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt_num, rt_is_64] = parse_register(xt);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (!rn_is_64) {
        throw std::invalid_argument("LDRB base register must be a 64-bit 'X' register or SP.");
    }

    // (B) Use BitPatcher. The base opcode for LDRB (unsigned immediate) is 0x39400000.
    BitPatcher patcher(0x39400000);

    // Patch the immediate, base register, and destination register.
    patcher.patch(static_cast<uint32_t>(immediate), 10, 12); // imm12
    patcher.patch(rn_num, 5, 5);                             // Rn
    patcher.patch(rt_num, 0, 5);                             // Rt

    // (C) Format the assembly string.
    std::string assembly_text = "LDRB " + xt + ", [" + xn;
    if (immediate != 0) {
        assembly_text += ", #" + std::to_string(immediate);
    }
    assembly_text += "]";

    // (D) Return the completed Instruction object.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LDRB;
    instr.dest_reg = Encoder::get_reg_encoding(xt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_branch_with_link_register.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'BLR' (Branch with Link to Register) instruction.
 * @details
 * This function generates the machine code for a BLR instruction, which performs
 * an indirect function call to the address held in a general-purpose register.
 * [cite_start]It stores the return address (PC+4) in the link register (X30)[cite: 96]. The program
 * [cite_start]counter is then set to the address in the source register (`PC = Xn`)[cite: 99].
 *
 * The encoding follows the "Unconditional branch (register)" format:
 * - **Family (bits 31-10)**: Fixed value of `0b1101011000111111000000`.
 * - [cite_start]**Rn (bits 9-5)**: The source register `xn` holding the target address[cite: 95].
 * - **op (bits 4-0)**: Fixed `0b00000`.
 *
 * @param xn The 64-bit register holding the target function address.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument if the register is not a 64-bit 'X' register.
 */
Instruction Encoder::create_branch_with_link_register(const std::string& xn) {
    // Helper lambda to parse the source register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        // BLR instruction requires a 64-bit register.
        if (lower_reg.rfind("x", 0) != 0) {
            throw std::invalid_argument("Invalid register for BLR: '" + reg_str + "'. Must be an 'X' register.");
        }

        try {
            uint32_t reg_num = std::stoul(lower_reg.substr(1));
            if (reg_num > 31) {
                throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
            }
            return {reg_num, true}; // is_64bit is always true
        } catch (const std::logic_error&) {
            throw std::invalid_argument("Invalid register format for BLR: '" + reg_str + "'.");
        }
    };

    // (A) Parse and validate the register.
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (!rn_is_64) {
        // This check is slightly redundant given the parser, but serves as defense-in-depth.
        throw std::invalid_argument("BLR instruction requires a 64-bit 'X' source register.");
    }

    // (B) Use BitPatcher. The base opcode for BLR is 0xD63F0000.
    BitPatcher patcher(0xD63F0000);

    // Patch the source register (Rn) into bits 5-9.
    patcher.patch(rn_num, 5, 5);

    // (C) Format the assembly string.
    std::string assembly_text = "BLR " + xn;

    // (D) Return the completed Instruction object.
    // Tagging as 'Jump' can be useful for downstream analysis tools.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::BLR;
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    return instr;
}

// encoders/enc_create_fmov_x_to_d.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>

// ARM64 FMOV (64-bit variant, scalar, from general-purpose register to vector register)
// This instruction moves the contents of an X register to a D register
// Encoding: FMOV Dd, Xn
// 0x9E670000 | (Rn << 5) | Rd
// Where Rn is the X register (bits 5-9) and Rd is the D register (bits 0-4)

Instruction Encoder::create_fmov_x_to_d(const std::string& dd, const std::string& xn) {
    // Parse D register number from "D0", "D1", etc.
    auto parse_d_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'D') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    // Parse X register number from "X0", "X1", etc.
    auto parse_x_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'X') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    int d_dst = parse_d_reg(dd);
    int x_src = parse_x_reg(xn);

    if (d_dst < 0 || d_dst > 31 || x_src < 0 || x_src > 31) {
        throw std::runtime_error("Invalid register for FMOV X to D: " + dd + ", " + xn);
    }

    // FMOV Dd, Xn encoding (64-bit scalar)
    BitPatcher patcher(0x9E670000);
    patcher.patch(x_src, 5, 5); // bits 5-9: source X register
    patcher.patch(d_dst, 0, 5); // bits 0-4: destination D register

    Instruction instr(patcher.get_value(), "FMOV " + dd + ", " + xn);
    instr.opcode = InstructionDecoder::OpType::FMOV;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);

    return instr;
}
// encoders/enc_create_ldp_post_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LDP' (Load Pair) instruction with post-indexing.
 * @details
 * This function generates the machine code to load a pair of registers from the
 * address in a base register, and then update the base register by adding an immediate.
 * The operation is `LDP <Xt1>, <Xt2>, [<Xn>], #imm`.
 *
 * The encoding follows the "Load/Store Pair (post-index)" format:
 * - **size (bits 31-30)**: `10` for 64-bit, `00` for 32-bit.
 * - **Family (bits 29-24)**: `0b101000`.
 * - **L (bit 22)**: `1` for Load.
 * - **imm7 (bits 21-15)**: A 7-bit signed immediate, scaled by the register size.
 * - **Rt2 (bits 14-10)**: The second destination register.
 * - **Rn (bits 9-5)**: The base address register (to be updated).
 * - **Rt (bits 4-0)**: The first destination register.
 *
 * @param xt1 The first destination register (e.g., "x0").
 * @param xt2 The second destination register (e.g., "x1").
 * @param xn The base address register (e.g., "x2", "sp"), which will be updated.
 * @param immediate The signed byte offset to add to the base register after loading. Must be a multiple of the register size (4 or 8).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or out-of-range/unaligned immediates.
 */
Instruction Encoder::create_ldp_post_imm(const std::string& xt1, const std::string& xt2, const std::string& xn, int immediate) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_ldp_post_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt1_num, rt1_is_64] = parse_register(xt1);
    auto [rt2_num, rt2_is_64] = parse_register(xt2);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rt1_is_64 != rt2_is_64) {
        throw std::invalid_argument("LDP registers to be loaded must be the same size.");
    }
    if (!rn_is_64) {
        throw std::invalid_argument("LDP base register must be a 64-bit 'X' register or SP.");
    }

    uint32_t base_opcode;
    int scale;
    int min_offset, max_offset;

    if (rt1_is_64) { // 64-bit LDP
        // Correct base_opcode for 64-bit LDP post-indexed:
        // sf=1, opc=01 (Load), V=0 (GP), fixed(010), P=0, M=0, L=1.
        // This corresponds to a leading pattern that ensures V=0 and correct instruction type.
        base_opcode = 0xA8400000; // This should be 10101000_01000000_00000000_00000000
                                  // sf=1, opc=01, V=0, P=0, M=0, L=1, then rest are part of Imm7 and reg encoding.
                                  // This combines sf=1, opc=01, V=0, 010 (fixed), P=0, M=0, L=1.
                                  // Which is: 1010010001XXXXXXX...
                                  // The 0xA8400000 pattern translates correctly for LDP post-index 64-bit.

        scale = 8;
        min_offset = -512;
        max_offset = 504;
    } else { // 32-bit LDP (W registers)
        base_opcode = 0x28400000; // Corresponding base_opcode for 32-bit LDP post-indexed
        scale = 4;
        min_offset = -256;
        max_offset = 252;
    }

    if (immediate % scale != 0 || immediate < min_offset || immediate > max_offset) {
        throw std::invalid_argument("LDP immediate offset must be a multiple of " + std::to_string(scale) +
                                    " and within range [" + std::to_string(min_offset) + ", " + std::to_string(max_offset) + "].");
    }

    uint32_t imm7 = (static_cast<uint32_t>(immediate) / scale) & 0x7F; // Mask to 7 bits

    uint32_t instruction_word = base_opcode |
                                (imm7 << 15) | // imm7 bits 21-15
                                (rt2_num << 10) | // Rt2 bits 14-10
                                (rn_num << 5) | // Rn bits 9-5
                                rt1_num; // Rt bits 4-0

    Instruction instr(instruction_word, "LDP " + xt1 + ", " + xt2 + ", [" + xn + "], #" + std::to_string(immediate));
    instr.opcode = InstructionDecoder::OpType::LDP;
    instr.dest_reg = Encoder::get_reg_encoding(xt1); // First destination register
    instr.src_reg1 = Encoder::get_reg_encoding(xt2); // Second destination register
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/opt_create_fmsub.cpp
#include <algorithm>
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>
#include <cctype>

/**
 * @brief Encodes the ARM64 'FMSUB' (Fused Multiply-Subtract) instruction.
 * @details
 * This function generates the machine code to multiply two source registers,
 * subtract a third, and store the result, without intermediate rounding.
 * The operation is `FMSUB <Vd>, <Vn>, <Vm>, <Va>`, where Vd = (Vn * Vm) - Va.
 *
 * The encoding follows the "Floating-point data-processing (3 source)" format:
 * - **M (bit 31)**: `0`.
 * - **S (bit 30)**: `0`.
 * - **type (bits 23-22)**: `00` for single-precision (S), `01` for double-precision (D).
 * - **Family (bits 24, 21, 15)**: `0b11111` identifies the MADD/MSUB family.
 * - **o1 (bit 21)**: `0` for FMSUB (when o0 is 1).
 * - **o0 (bit 15)**: `1` for subtraction.
 * - **Vm (bits 20-16)**: The second multiplicand register.
 * - **Va (bits 14-10)**: The subtrahend register.
 * - **Vn (bits 9-5)**: The first multiplicand register.
 * - **Vd (bits 4-0)**: The destination register.
 *
 * @param vd The destination and addend register (e.g., "D0", "S1").
 * @param vn The first source register (multiplicand).
 * @param vm The second source register (multiplier).
 * @param va The third source register (subtrahend).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or mismatched precision.
 */
Instruction Encoder::opt_create_fmsub(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& va) {
    // 1. Validate register names and determine precision
    char vd_prefix = vd.empty() ? ' ' : static_cast<char>(std::toupper(vd[0]));
    char vn_prefix = vn.empty() ? ' ' : static_cast<char>(std::toupper(vn[0]));
    char vm_prefix = vm.empty() ? ' ' : static_cast<char>(std::toupper(vm[0]));
    char va_prefix = va.empty() ? ' ' : static_cast<char>(std::toupper(va[0]));

    if (vd_prefix != vn_prefix || vn_prefix != vm_prefix || vm_prefix != va_prefix) {
        throw std::invalid_argument("Mismatched register precision for FMSUB. All must be 'S' or 'D'.");
    }
    if (vd_prefix != 'S' && vd_prefix != 'D') {
        throw std::invalid_argument("Invalid register type for FMSUB. Must be 'S' or 'D' registers.");
    }

    bool is_double = (vd_prefix == 'D');

    uint32_t vd_num = get_reg_encoding(vd);
    uint32_t vn_num = get_reg_encoding(vn);
    uint32_t vm_num = get_reg_encoding(vm);
    uint32_t va_num = get_reg_encoding(va);

    // 2. Use BitPatcher to construct the instruction word.
    // Base opcode for FMSUB is 0x1F008000 (includes o0=1 for subtract).
    BitPatcher patcher(0x1F008000);

    if (is_double) {
        patcher.patch(1, 22, 2); // type = 01 for double-precision
    }
    // type = 00 for single-precision is the default.

    patcher.patch(vm_num, 16, 5);    // Vm
    patcher.patch(va_num, 10, 5);    // Va
    patcher.patch(vn_num, 5, 5);     // Vn
    patcher.patch(vd_num, 0, 5);     // Vd

    // 3. Format the assembly string and return the Instruction object.
    std::string assembly_text = "FMSUB " + vd + ", " + vn + ", " + vm + ", " + va;
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::FMSUB;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    instr.ra_reg = Encoder::get_reg_encoding(va);
    return instr;
}

// encoders/create_lsl_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LSL (register)' instruction (LSLV).
 * @details
 * This function generates the 32-bit machine code for an LSL instruction
 * that performs a logical left shift on a register by a variable amount
 * specified in a second register. The canonical name for this instruction is LSLV.
 * The instruction has the format: `LSL <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * [cite_start]The operation is described as `$rd = rn << rm$`[cite: 21].
 *
 * The encoding follows the "Data-processing (2 source)" format for LSLV:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **S (bit 30)**: Must be 0.
 * - **Family (bits 29-22)**: Fixed value of `0b11010110`.
 * - **Rm (bits 20-16)**: The register containing the shift amount (`xm`).
 * - **opcode2 (bits 15-10)**: Fixed value of `0b000010` for LSLV.
 * - **Rn (bits 9-5)**: The source register to be shifted (`xn`).
 * - **Rd (bits 4-0)**: The destination register (`xd`).
 *
 * @param xd The destination register (e.g., "x0").
 * @param xn The source register to be shifted.
 * @param xm The register containing the shift amount.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_lsl_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_lsl_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for LSL (register) must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit LSLV is 0x1AC00800, which contains all fixed bits.
    BitPatcher patcher(0x1AC02000); 

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the registers into their respective fields.
    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "LSL " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LSL;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/opt_create_asr_imm.cpp
#include <algorithm>
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>

/**
 * @brief Encodes the ARM64 'ASR' (Arithmetic Shift Right) instruction with an immediate.
 * @details
 * This function generates the machine code to perform an arithmetic right shift
 * on a register by an immediate amount. `ASR` is an alias for the `SBFM`
 * (Signed Bitfield Move) instruction.
 * The operation is `ASR <Xd|Wd>, <Xn|Wn>, #<shift>`.
 *
 * The encoding follows the "Bitfield" format for SBFM:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `00` for SBFM.
 * - **Family (bits 28-23)**: `0b100100`.
 * - **N (bit 22)**: Must match `sf`.
 * - **immr (bits 21-16)**: The shift amount.
 * - **imms (bits 15-10)**: The destination bitfield width, which is `datasize - 1`.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register to be shifted.
 * @param shift_amount The immediate shift amount (0-63 for X regs, 0-31 for W regs).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or out-of-range shift amount.
 */
Instruction Encoder::opt_create_asr_imm(const std::string& xd, const std::string& xn, int shift_amount) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(xd);
    uint32_t rn_num = get_reg_encoding(xn);
    bool is_64bit = (xd[0] == 'x' || xd[0] == 'X');

    if (is_64bit != (xn[0] == 'x' || xn[0] == 'X')) {
        throw std::invalid_argument("Mismatched register sizes for ASR (immediate).");
    }

    // 2. Validate shift amount
    int datasize = is_64bit ? 64 : 32;
    if (shift_amount < 0 || shift_amount >= datasize) {
        throw std::invalid_argument("ASR shift amount is out of range for the register size.");
    }

    // 3. Calculate encoding fields for the SBFM alias
    uint32_t n_val = is_64bit ? 1 : 0;
    uint32_t immr_val = static_cast<uint32_t>(shift_amount);
    uint32_t imms_val = static_cast<uint32_t>(datasize - 1);

    // 4. Use BitPatcher to construct the instruction word.
    // Base opcode for SBFM is 0x13000000.
    BitPatcher patcher(0x13000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(n_val, 22, 1);       // N bit
    patcher.patch(immr_val, 16, 6);    // immr (shift amount)
    patcher.patch(imms_val, 10, 6);    // imms (datasize - 1)
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 5. Format the assembly string and return the Instruction object.
    std::string assembly_text = "ASR " + xd + ", " + xn + ", #" + std::to_string(shift_amount);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ASR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = shift_amount;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_nop.cpp
#include "Encoder.h"
#include <string>

/**
 * @brief Encodes the ARM64 'NOP' (No Operation) instruction.
 * @details
 * This function generates the machine code for a NOP instruction, which performs no operation
 * and is commonly used for instruction alignment or timing purposes.
 *
 * The ARM64 NOP instruction is simply an alias for `HINT #0`.
 * The encoding for NOP is:
 * - **opcode (bits 31-21)**: `0b1101010100000011001`
 * - **imm (bits 20-5)**: 0
 * - **op2 (bits 4-0)**: 0
 *
 * The 32-bit encoding for NOP is 0xD503201F.
 *
 * @return An `Instruction` object containing the encoding and assembly text.
 */
Instruction Encoder::create_nop() {
    // The base opcode for the NOP instruction is 0xD503201F.
    uint32_t encoding = 0xD503201F;

    // Format the assembly string.
    std::string assembly_text = "NOP";

    // Return the completed Instruction object. No relocation is needed.
    Instruction instr(encoding, assembly_text);
    instr.opcode = InstructionDecoder::OpType::NOP;
    return instr;
}

// encoders/enc_create_svc_imm.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_svc_imm(uint16_t immediate) {
     // SVC #imm (Supervisor Call)
     // Encoding: 11010100 00000000 00000000 iiiiiiii (imm16 in bits 20-5)
     uint32_t encoding = 0xD4000001 | ((static_cast<uint32_t>(immediate) & 0xFFFF) << 5);
     std::stringstream ss;
     ss << "SVC #" << immediate;
     Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::SVC;
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
 }

// encoders/opt_create_encode_bitmask_immediate.cpp
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "BitPatcher.h"
#include "Encoder.h"
/**
 * @brief (Internal Helper) Encodes a 64-bit immediate into the ARM64 bitmask immediate format.
 * @details
 * ARM64 logical instructions (AND, ORR, EOR) do not take arbitrary immediate values.
 * They use a special format that can represent a 32 or 64-bit value composed of
 * a repeating bit pattern that has been rotated. This function finds the correct
 * N, immr, and imms fields for a given immediate.
 *
 * @param immediate The immediate value to encode.
 * @param is_64bit True if the operation is 64-bit, false for 32-bit.
 * @param n_val Output for the 'N' field.
 * @param immr_val Output for the 'immr' field (rotation).
 * @param imms_val Output for the 'imms' field (element size/pattern).
 * @return True if the immediate can be encoded, false otherwise.
 */
bool Encoder::encode_bitmask_immediate(uint64_t immediate, bool is_64bit, uint32_t& n_val, uint32_t& immr_val, uint32_t& imms_val) {
    if (!is_64bit) {
        // For 32-bit operations, ensure the upper 32 bits are either all 0s or all 1s
        // matching the 31st bit, effectively zero- or sign-extending the value.
        if ((immediate & 0xFFFFFFFF00000000) != 0 && (immediate & 0xFFFFFFFF00000000) != 0xFFFFFFFF00000000) {
             // If the immediate is not a simple 32-bit value, check if it's a replicated 32-bit pattern
             if ((immediate & 0xFFFFFFFF) != (immediate >> 32)) {
                return false;
             }
        }
        immediate &= 0xFFFFFFFF; // Work with the lower 32 bits
    }

    // A value of 0 or all 1s is always valid.
    if (immediate == 0 || immediate == ~0ULL) {
        imms_val = is_64bit ? 0b111111 : 0b011111;
        immr_val = 0;
        n_val = is_64bit ? 1 : 0;
        return true;
    }

    // Iterate through element sizes (2, 4, 8, 16, 32 bits)
    for (int size = 2; size <= (is_64bit ? 64 : 32); size *= 2) {
        uint64_t mask = (1ULL << size) - 1;
        uint64_t pattern = immediate & mask;

        // Check if the pattern is just a single bit or all ones (invalid for this logic)
        if (pattern == 0 || pattern == mask) continue;

        // Replicate the pattern across 64 bits
        uint64_t replicated = 0;
        for (int i = 0; i < 64; i += size) {
            replicated |= (pattern << i);
        }

        // Check if the immediate can be formed by rotating the replicated pattern
        for (int rotation = 0; rotation < size; ++rotation) {
            uint64_t rotated = (replicated >> rotation) | (replicated << (64 - rotation));
            if (!is_64bit) {
                rotated &= 0xFFFFFFFF;
            }

            if (rotated == immediate) {
                // Found a valid encoding
                n_val = is_64bit ? 1 : 0;
                imms_val = (~(size - 1) & 0b111111) | (__builtin_popcountll(pattern) - 1);
                immr_val = rotation;
                return true;
            }
        }
    }

    return false; // Immediate cannot be encoded
}

// encoders/enc_create_fneg_reg.cpp
#include "Encoder.h"
#include <sstream>
#include "BitPatcher.h"

// Implements FNEG Dd, Dn (floating-point negate, double-precision)
Instruction Encoder::create_fneg_reg(const std::string& dd, const std::string& dn) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(dn);

    // Encoding for FNEG Dd, Dn:
    // 0x1E614000 | (rn << 5) | rd
    // FNEG Dd, Dn: 0001 1110 0110 0001 0100 0000 000r nnnn rrrrr
    BitPatcher patcher(0x1E614000);
    patcher.patch(rn, 5, 5); // Dn at bits [9:5]
    patcher.patch(rd, 0, 5); // Dd at bits [4:0]

    std::stringstream ss;
    ss << "FNEG " << dd << ", " << dn;
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::FMOV; // No dedicated FNEG OpType, FMOV is often used for unary float ops
    instr.dest_reg = rd;
    instr.src_reg1 = rn;
    return instr;
}

// encoders/enc_create_branch_conditional.cpp
#include "../BitPatcher.h"
#include "../Encoder.h"
#include "../InstructionDecoder.h"
#include <algorithm>
#include <cctype>
#include <map>
#include <stdexcept>
#include <string>



/**
 * @brief Creates a conditional branch instruction (e.g., B.EQ) to a label.
 * @details
 * This function generates the machine code for a conditional branch. The branch
 * target is a PC-relative offset encoded as a 19-bit signed immediate.
 *
 * The immediate field is set to 0, and the instruction is tagged with
 * `RelocationType::PC_RELATIVE_19_BIT_OFFSET`. The linker is responsible for
 * calculating the final offset and patching the instruction.
 *
 * The encoding follows the "Conditional branch (immediate)" format[cite: 90]:
 * - **Family (bits 31-25)**: `0b0101010`.
 * - **op (bit 24)**: `0`.
 * - **imm19 (bits 23-5)**: The 19-bit signed PC-relative immediate (offset / 4).
 * - **Fixed (bit 4)**: `0`.
 * - **cond (bits 3-0)**: The 4-bit condition code from `get_condition_code`.
 *
 * @param condition The condition code as a string (e.g., "EQ", "NE", "LT").
 * @param label_name The target label.
 * @return An `Instruction` object with relocation info.
 * @throw std::invalid_argument if the condition is not recognized.
 */
namespace {
ConditionCode stringToConditionCode(const std::string& cond) {
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);
    if (upper_cond == "EQ") return ConditionCode::EQ;
    if (upper_cond == "NE") return ConditionCode::NE;
    if (upper_cond == "CS") return ConditionCode::CS;
    if (upper_cond == "CC") return ConditionCode::CC;
    if (upper_cond == "MI") return ConditionCode::MI;
    if (upper_cond == "PL") return ConditionCode::PL;
    if (upper_cond == "VS") return ConditionCode::VS;
    if (upper_cond == "VC") return ConditionCode::VC;
    if (upper_cond == "HI") return ConditionCode::HI;
    if (upper_cond == "LS") return ConditionCode::LS;
    if (upper_cond == "GE") return ConditionCode::GE;
    if (upper_cond == "LT") return ConditionCode::LT;
    if (upper_cond == "GT") return ConditionCode::GT;
    if (upper_cond == "LE") return ConditionCode::LE;
    if (upper_cond == "AL") return ConditionCode::AL;
    if (upper_cond == "NV") return ConditionCode::NV;
    return ConditionCode::UNKNOWN;
}
}

Instruction Encoder::create_branch_conditional(const std::string& condition, const std::string& label_name) {
    // (A) Get the 4-bit encoding for the condition string.
    uint32_t cond_code = get_condition_code(condition);

    // (B) Use BitPatcher. The base for B.cond is 0x54000000.
    // The immediate field (imm19) is left as zero for the linker to patch.
    BitPatcher patcher(0x54000000);

    // Patch the condition code into bits 0-3.
    patcher.patch(cond_code, 0, 4);

    // (C) Format the assembly string with a capitalized condition.
    std::string upper_condition = condition;
    std::transform(upper_condition.begin(), upper_condition.end(), upper_condition.begin(), ::toupper);
    std::string assembly_text = "B." + upper_condition + " " + label_name;

    // (D) Return the completed Instruction object with relocation information.
    Instruction instr(patcher.get_value(), assembly_text);

    // â Set the opcode field
    instr.opcode = InstructionDecoder::OpType::B_COND;
    instr.relocation = RelocationType::PC_RELATIVE_19_BIT_OFFSET;
    instr.target_label = label_name;

    // â Set the semantic condition code field using the helper
    instr.cond = stringToConditionCode(condition);

    return instr;
}

// encoders/enc_create_fmov_s_to_w.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>

// ARM64 FMOV (32-bit variant, scalar, from vector register to general-purpose register)
// This instruction moves the contents of an S register to a W register
// Encoding: FMOV Wd, Sn
// 0x1E260000 | (Rn << 5) | Rd
// Where Rn is the S register (bits 5-9) and Rd is the W register (bits 0-4)

Instruction Encoder::create_fmov_s_to_w(const std::string& wd, const std::string& sn) {
    // Parse W register number from "W0", "W1", etc.
    auto parse_w_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'W') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    // Parse S register number from "S0", "S1", etc.
    auto parse_s_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'S') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    int w_dst = parse_w_reg(wd);
    int s_src = parse_s_reg(sn);

    if (w_dst < 0 || w_dst > 31 || s_src < 0 || s_src > 31) {
        throw std::runtime_error("Invalid register for FMOV S to W: " + wd + ", " + sn);
    }

    // FMOV Wd, Sn encoding (32-bit scalar)
    BitPatcher patcher(0x1E260000);
    patcher.patch(s_src, 5, 5); // bits 5-9: source S register
    patcher.patch(w_dst, 0, 5); // bits 0-4: destination W register

    Instruction instr(patcher.get_value(), "FMOV " + wd + ", " + sn);
    instr.opcode = InstructionDecoder::OpType::FMOV;
    instr.dest_reg = Encoder::get_reg_encoding(wd);
    instr.src_reg1 = Encoder::get_reg_encoding(sn);

    return instr;
}
// encoders/enc_create_mov_fp_sp.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>

/**
 * @brief Creates a 'MOV X29, SP' instruction to set up the frame pointer.
 * @details
 * This is a common instruction in function prologues used to set the frame pointer (FP, X29)
 * to the current stack pointer (SP).
 *
 * This instruction is an alias for `ADD X29, SP, #0`.
 *
 * The encoding follows the "Add/subtract (immediate)" format:
 * - **sf (bit 31)**: `1` (64-bit).
 * - **op (bit 30)**: `0` (addition).
 * - **S (bit 29)**: `0` (do not set flags).
 * - **Family (bits 28-24)**: `0b10001`.
 * - **imm12 (bits 21-10)**: `0`.
 * - **Rn (bits 9-5)**: `31` (SP).
 * - **Rd (bits 4-0)**: `29` (FP).
 *
 * @return An `Instruction` object for `MOV X29, SP`.
 */
Instruction Encoder::create_mov_fp_sp() {
    // This instruction is an alias for ADD X29, SP, #0.
    // The base opcode for 64-bit ADD (immediate) is 0x91000000.
    BitPatcher patcher(0x91000000);

    // The immediate is 0, so no patch is needed for that field.

    // Patch the source register (Rn) to SP (which is encoded as register 31).
    patcher.patch(31, 5, 5);

    // Patch the destination register (Rd) to FP (X29).
    patcher.patch(29, 0, 5);

    // The canonical assembly text for the alias.
    std::string assembly_text = "MOV X29, SP";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::MOV;
    instr.dest_reg = 29; // X29 (FP)
    instr.src_reg1 = 31; // SP
    return instr;
}

// encoders/opt_create_csinv.cpp
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "BitPatcher.h"
#include "Encoder.h"
/**
 * @brief Encodes the ARM64 'CSINV' (Conditional Select Invert) instruction.
 * @details
 * This function generates the 32-bit machine code to conditionally invert a
 * register's value. If the condition is true, the destination register is set
 * to the value of the first source register (Rn). If the condition is false,
 * it is set to the bitwise inverse of the second source register (Rm).
 * The operation is `CSINV <Xd|Wd>, <Xn|Wn>, <Xm|Wm>, <cond>`.
 *
 * The encoding follows the "Conditional select" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **op (bit 30)**: `1`.
 * - **S (bit 29)**: `0`.
 * - **Family (bits 28-24)**: `0b11010`.
 * - **op2 (bits 11-10)**: `0b00`.
 * - **Rm (bits 20-16)**: The second source register `xm`.
 * - **cond (bits 15-12)**: The 4-bit condition code.
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param rd The destination register (e.g., "x0", "w1").
 * @param rn The first source register (used when condition is true).
 * @param rm The second source register (inverted when condition is false).
 * @param cond The condition mnemonic as a string (e.g., "EQ", "NE", "LT").
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or unrecognized conditions.
 */
Instruction Encoder::opt_create_csinv(const std::string& rd, const std::string& rn, const std::string& rm, const std::string& cond) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(rd);
    uint32_t rn_num = get_reg_encoding(rn);
    uint32_t rm_num = get_reg_encoding(rm);
    bool is_64bit = (rd[0] == 'x' || rd[0] == 'X');

    // Ensure all registers are of the same size
    if (is_64bit != (rn[0] == 'x' || rn[0] == 'X') || is_64bit != (rm[0] == 'x' || rm[0] == 'X')) {
        // Allow for zero registers (wzr/xzr) to be mixed
        if (!(rn == "wzr" || rn == "xzr" || rm == "wzr" || rm == "xzr")) {
            throw std::invalid_argument("Mismatched register sizes for CSINV.");
        }
    }

    // 2. Get the 4-bit encoding for the condition string.
    uint32_t cond_code = get_condition_code(cond);

    // 3. Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit CSINV is 0x5A800000.
    BitPatcher patcher(0x5A800000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(rm_num, 16, 5);      // Rm
    patcher.patch(cond_code, 12, 4);   // cond
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 4. Format the assembly string and return the Instruction object.
    std::string assembly_text = "CSINV " + rd + ", " + rn + ", " + rm + ", " + cond;
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CSINV;
    instr.dest_reg = Encoder::get_reg_encoding(rd);
    instr.src_reg1 = Encoder::get_reg_encoding(rn);
    instr.src_reg2 = Encoder::get_reg_encoding(rm);
    return instr;
}

// encoders/opt_create_cbz.cpp
#include <algorithm>
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>

/**
 * @brief Encodes the ARM64 'CBZ' (Compare and Branch if Zero) instruction.
 * @details
 * This function generates the machine code for a CBZ instruction, which tests
 * the value in a register and branches to a label if the value is zero.
 * The operation is `CBZ <Xt|Wt>, <label>`.
 *
 * The encoding follows the "Compare and branch (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **Family (bits 30-24)**: `0b0110100`.
 * - **imm19 (bits 23-5)**: A 19-bit signed PC-relative immediate offset (offset / 4).
 * - **Rt (bits 4-0)**: The source register to test.
 *
 * @param xt The source register to test (e.g., "x0", "w1").
 * @param label_name The target label to branch to.
 * @return An `Instruction` object with relocation information for the linker.
 * @throw std::invalid_argument for invalid register names.
 */
Instruction Encoder::opt_create_cbz(const std::string& xt, const std::string& label_name) {
    // 1. Validate register name and determine size
    uint32_t rt_num = get_reg_encoding(xt);
    bool is_64bit = (xt[0] == 'x' || xt[0] == 'X');

    // 2. Use BitPatcher to construct the instruction word.
    // The immediate field (imm19) is left as zero for the linker to patch.
    // Base opcode for CBZ is 0x34000000.
    BitPatcher patcher(0x34000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(rt_num, 0, 5); // Rt

    // 3. Format the assembly string.
    std::string assembly_text = "CBZ " + xt + ", " + label_name;

    // 4. Return the completed Instruction object with relocation information.
    // The linker will calculate the 19-bit PC-relative offset.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CBZ;
    instr.src_reg1 = Encoder::get_reg_encoding(xt);
    instr.relocation = RelocationType::PC_RELATIVE_19_BIT_OFFSET;
    instr.target_label = label_name;
    return instr;
}

// encoders/opt_create_cbnz.cpp
#include <algorithm>
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>

/**
 * @brief Encodes the ARM64 'CBNZ' (Compare and Branch if Not Zero) instruction.
 * @details
 * This function generates the machine code for a CBNZ instruction, which tests
 * the value in a register and branches to a label if the value is not zero.
 * The operation is `CBNZ <Xt|Wt>, <label>`.
 *
 * The encoding follows the "Compare and branch (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **op (bit 24)**: 1 for CBNZ.
 * - **Family (bits 30-25)**: `0b011010`.
 * - **imm19 (bits 23-5)**: A 19-bit signed PC-relative immediate offset (offset / 4).
 * - **Rt (bits 4-0)**: The source register to test.
 *
 * @param xt The source register to test (e.g., "x0", "w1").
 * @param label_name The target label to branch to.
 * @return An `Instruction` object with relocation information for the linker.
 * @throw std::invalid_argument for invalid register names.
 */
Instruction Encoder::opt_create_cbnz(const std::string& xt, const std::string& label_name) {
    // 1. Validate register name and determine size
    uint32_t rt_num = get_reg_encoding(xt);
    bool is_64bit = (xt[0] == 'x' || xt[0] == 'X');

    // 2. Use BitPatcher to construct the instruction word.
    // The immediate field (imm19) is left as zero for the linker to patch.
    // Base opcode for CBNZ is 0x35000000 (differs from CBZ by bit 24).
    BitPatcher patcher(0x35000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(rt_num, 0, 5); // Rt

    // 3. Format the assembly string.
    std::string assembly_text = "CBNZ " + xt + ", " + label_name;

    // 4. Return the completed Instruction object with relocation information.
    // The linker will calculate the 19-bit PC-relative offset.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CBNZ;
    instr.src_reg1 = Encoder::get_reg_encoding(xt);
    instr.relocation = RelocationType::PC_RELATIVE_19_BIT_OFFSET;
    instr.target_label = label_name;
    return instr;
}

// encoders/enc_create_mov_sp_fp.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>

/**
 * @brief Creates a 'MOV SP, X29' instruction to restore the stack pointer.
 * @details
 * This is a common instruction in function epilogues used to restore the stack pointer (SP)
 * from the frame pointer (FP, X29), effectively deallocating the stack frame.
 *
 * This instruction is an alias for `ADD SP, X29, #0`.
 *
 * [cite_start]The encoding follows the "Add/subtract (immediate)" format[cite: 1]:
 * - **sf (bit 31)**: `1` (64-bit).
 * - **op (bit 30)**: `0` (addition).
 * - **S (bit 29)**: `0` (do not set flags).
 * - **Family (bits 28-24)**: `0b10001`.
 * - **imm12 (bits 21-10)**: `0`.
 * - **Rn (bits 9-5)**: `29` (FP, X29).
 * - **Rd (bits 4-0)**: `31` (SP).
 *
 * @return An `Instruction` object for `MOV SP, X29`.
 */
Instruction Encoder::create_mov_sp_fp() {
    // This instruction is an alias for ADD SP, X29, #0.
    // The base opcode for 64-bit ADD (immediate) is 0x91000000.
    BitPatcher patcher(0x91000000);

    // The immediate is 0, so no patch is needed for that field.

    // Patch the source register (Rn) to FP (X29).
    patcher.patch(29, 5, 5);

    // Patch the destination register (Rd) to SP (which is encoded as register 31).
    patcher.patch(31, 0, 5);

    // The canonical assembly text for the alias.
    std::string assembly_text = "MOV SP, X29";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::MOV;
    instr.dest_reg = 31; // SP
    instr.src_reg1 = 29; // X29 (FP)
    return instr;
}

// encoders/opt_create_fmadd.cpp
#include <algorithm>
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>
#include <cctype>

/**
 * @brief Encodes the ARM64 'FMADD' (Fused Multiply-Add) instruction.
 * @details
 * This function generates the machine code to multiply two source registers,
 * add a third, and store the result, without intermediate rounding.
 * The operation is `FMADD <Vd>, <Vn>, <Vm>, <Va>`, where Vd = (Vn * Vm) + Va.
 *
 * The encoding follows the "Floating-point data-processing (3 source)" format:
 * - **M (bit 31)**: `0`.
 * - **S (bit 30)**: `0`.
 * - **type (bits 23-22)**: `00` for single-precision (S), `01` for double-precision (D).
 * - **Family (bits 24, 21, 15)**: `0b11111` identifies the MADD/MSUB family.
 * - **o1 (bit 21)**: `0` for FMADD.
 * - **o0 (bit 15)**: `0` for addition.
 * - **Vm (bits 20-16)**: The second multiplicand register.
 * - **Va (bits 14-10)**: The addend register.
 * - **Vn (bits 9-5)**: The first multiplicand register.
 * - **Vd (bits 4-0)**: The destination register.
 *
 * @param vd The destination and addend register (e.g., "D0", "S1").
 * @param vn The first source register (multiplicand).
 * @param vm The second source register (multiplier).
 * @param va The third source register (addend).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or mismatched precision.
 */
Instruction Encoder::opt_create_fmadd(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& va) {
    // 1. Validate register names and determine precision
    char vd_prefix = vd.empty() ? ' ' : static_cast<char>(std::toupper(vd[0]));
    char vn_prefix = vn.empty() ? ' ' : static_cast<char>(std::toupper(vn[0]));
    char vm_prefix = vm.empty() ? ' ' : static_cast<char>(std::toupper(vm[0]));
    char va_prefix = va.empty() ? ' ' : static_cast<char>(std::toupper(va[0]));

    if (vd_prefix != vn_prefix || vn_prefix != vm_prefix || vm_prefix != va_prefix) {
        throw std::invalid_argument("Mismatched register precision for FMADD. All must be 'S' or 'D'.");
    }
    if (vd_prefix != 'S' && vd_prefix != 'D') {
        throw std::invalid_argument("Invalid register type for FMADD. Must be 'S' or 'D' registers.");
    }

    bool is_double = (vd_prefix == 'D');

    uint32_t vd_num = get_reg_encoding(vd);
    uint32_t vn_num = get_reg_encoding(vn);
    uint32_t vm_num = get_reg_encoding(vm);
    uint32_t va_num = get_reg_encoding(va);

    // 2. Use BitPatcher to construct the instruction word.
    // Base opcode for FMADD is 0x1F000000.
    BitPatcher patcher(0x1F000000);

    if (is_double) {
        patcher.patch(1, 22, 2); // type = 01 for double-precision
    }
    // type = 00 for single-precision is the default in the base opcode.

    patcher.patch(vm_num, 16, 5);    // Vm
    patcher.patch(va_num, 10, 5);    // Va
    patcher.patch(vn_num, 5, 5);     // Vn
    patcher.patch(vd_num, 0, 5);     // Vd

    // 3. Format the assembly string and return the Instruction object.
    std::string assembly_text = "FMADD " + vd + ", " + vn + ", " + vm + ", " + va;
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::FMADD;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    instr.ra_reg = Encoder::get_reg_encoding(va);
    return instr;
}

// encoders/enc_create_fmov_reg.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>

// ARM64 FMOV (register to register, Dn to Dm)
// Encoding: FMOV Dd, Dn
// 0x1E604000 | (Dn << 5) | Dd
// D registers are numbered D0-D31

Instruction Encoder::create_fmov_reg(const std::string& dd, const std::string& ds) {
    // Parse register numbers from "D0", "D1", etc.
    auto parse_d_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'D') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    int d_dst = parse_d_reg(dd);
    int d_src = parse_d_reg(ds);

    if (d_dst < 0 || d_dst > 31 || d_src < 0 || d_src > 31) {
        throw std::runtime_error("Invalid D register for FMOV: " + dd + ", " + ds);
    }

    // FMOV Dd, Dn encoding
    BitPatcher patcher(0x1E604000);
    patcher.patch(d_src, 5, 5); // bits 5-9: source register
    patcher.patch(d_dst, 0, 5); // bits 0-4: destination register

    Instruction instr(patcher.get_value(), "FMOV " + dd + ", " + ds);
    instr.opcode = InstructionDecoder::OpType::FMOV;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(ds);
    return instr;
}

// encoders/opt_create_add_shifted_reg.cpp
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <algorithm>
#include <stdexcept>

/**
 * @brief Encodes the ARM64 'ADD (shifted register)' instruction.
 * @details
 * This function generates the 32-bit machine code for an ADD instruction
 * that adds a register to a second register that has been shifted by an
 * immediate amount.
 * The instruction has the format: `ADD <Xd|Wd>, <Xn|Wn>, <Xm|Wm>{, <shift> #<amount>}`.
 *
 * The encoding follows the "Data-processing (register)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `0b00`.
 * - **S (bit 29)**: `0`.
 * - **Family (bits 28-25)**: `0b01011`.
 * - **shift (bits 23-22)**: `00` for LSL, `01` for LSR, `10` for ASR.
 * - **N (bit 21)**: `0`.
 * - **Rm (bits 20-16)**: The second source register `xm` (to be shifted).
 * - **imm6 (bits 15-10)**: The 6-bit shift amount.
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param rd The destination register (e.g., "x0", "w1").
 * @param rn The first source register.
 * @param rm The second source register (to be shifted).
 * @param shift_type The type of shift ("LSL", "LSR", or "ASR").
 * @param shift_amount The amount to shift by (0-63).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or shift parameters.
 */
Instruction Encoder::opt_create_add_shifted_reg(const std::string& rd, const std::string& rn, const std::string& rm, const std::string& shift_type, int shift_amount) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(rd);
    uint32_t rn_num = get_reg_encoding(rn);
    uint32_t rm_num = get_reg_encoding(rm);
    bool is_64bit = (rd[0] == 'x' || rd[0] == 'X');

    if (is_64bit != (rn[0] == 'x' || rn[0] == 'X') || is_64bit != (rm[0] == 'x' || rm[0] == 'X')) {
        throw std::invalid_argument("Mismatched register sizes for ADD (shifted register).");
    }

    // 2. Validate shift parameters
    int max_shift = is_64bit ? 63 : 31;
    if (shift_amount < 0 || shift_amount > max_shift) {
        throw std::invalid_argument("Shift amount is out of range for the register size.");
    }

    uint32_t shift_code;
    std::string upper_shift_type = shift_type;
    std::transform(upper_shift_type.begin(), upper_shift_type.end(), upper_shift_type.begin(), ::toupper);

    if (upper_shift_type == "LSL") {
        shift_code = 0b00;
    } else if (upper_shift_type == "LSR") {
        shift_code = 0b01;
    } else if (upper_shift_type == "ASR") {
        shift_code = 0b10;
    } else {
        throw std::invalid_argument("Invalid shift type for ADD (shifted register). Must be LSL, LSR, or ASR.");
    }

    // 3. Use BitPatcher to construct the instruction word.
    // Base opcode for ADD (shifted register) is 0x0B000000.
    BitPatcher patcher(0x0B000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(shift_code, 22, 2);              // shift
    patcher.patch(rm_num, 16, 5);                  // Rm
    patcher.patch(static_cast<uint32_t>(shift_amount), 10, 6); // imm6
    patcher.patch(rn_num, 5, 5);                   // Rn
    patcher.patch(rd_num, 0, 5);                   // Rd

    // 4. Format the assembly string and return the Instruction object.
    std::string assembly_text = "ADD " + rd + ", " + rn + ", " + rm + ", " + upper_shift_type + " #" + std::to_string(shift_amount);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ADD;
    instr.dest_reg = Encoder::get_reg_encoding(rd);
    instr.src_reg1 = Encoder::get_reg_encoding(rn);
    instr.src_reg2 = Encoder::get_reg_encoding(rm);
    instr.immediate = shift_amount;
    instr.uses_immediate = true;
    return instr;
}

// encoders/create_mul_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'MUL' (Multiply) instruction.
 * @details
 * This function generates the 32-bit machine code for a multiply instruction.
 * `MUL` is an alias for the `MADD` (Multiply-Add) instruction, where the addend
 * register (`Ra`) is the zero register (WZR/XZR).
 * [cite_start]The operation `MUL <Xd>, <Xn>, <Xm>` is encoded as `MADD <Xd>, <Xn>, <Xm>, <XZR>`[cite: 1].
 *
 * [cite_start]The encoding follows the "Data-processing (3 source)" format for MADD[cite: 1]:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `0b01`.
 * - **Family (bits 28-21)**: `0b11011000`.
 * - **Rm (bits 20-16)**: The second source register `xm`.
 * - **o0 (bit 15)**: 0.
 * - **Ra (bits 14-10)**: `0b11111` (the zero register).
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0").
 * @param xn The first source register.
 * @param xm The second source register.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_mul_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_mul_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for MUL must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit MADD is 0x1B000000.
    BitPatcher patcher(0x1B000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the destination and source registers.
    patcher.patch(rd_num, 0, 5);
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rm_num, 16, 5);

    // Patch the addend register (Ra) to be the zero register (31).
    patcher.patch(31, 10, 5);

    // (C) Format the assembly string.
    std::string assembly_text = "MUL " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::MUL;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    instr.ra_reg = 31; // XZR/WZR
    return instr;
}

// encoders/opt_create_eor_imm.cpp
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "BitPatcher.h"
#include "Encoder.h"
/**
 * @brief Encodes the ARM64 'EOR' (Bitwise Exclusive OR) instruction with an immediate.
 * @details
 * This function generates the 32-bit machine code for an EOR instruction
 * that performs a bitwise XOR between a register and a bitmask immediate.
 * The instruction has the format: `EOR <Xd|Wd>, <Xn|Wn>, #imm`.
 *
 * The encoding follows the "Logical (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `10` for EOR.
 * - **Family (bits 28-23)**: `0b100100`.
 * - **N (bit 22)**: Encoded based on the immediate pattern.
 * - **immr (bits 21-16)**: Encoded rotation for the immediate.
 * - **imms (bits 15-10)**: Encoded size/pattern for the immediate.
 * - **Rn (bits 9-5)**: The source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register (e.g., "x1", "sp").
 * @param immediate The immediate value, which must be encodable as a bitmask.
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or unencodable immediates.
 */
Instruction Encoder::opt_create_eor_imm(const std::string& xd, const std::string& xn, int64_t immediate) {
    // 1. Validate register names and determine size
    uint32_t rd_num = get_reg_encoding(xd);
    uint32_t rn_num = get_reg_encoding(xn);
    bool is_64bit = (xd[0] == 'x' || xd[0] == 'X');

    // Ensure register sizes match (simplified check)
    if (is_64bit != (xn[0] == 'x' || xn[0] == 'X')) {
         if ((xn != "sp" && xn != "SP") && (xd != "sp" && xd != "SP")) {
            throw std::invalid_argument("Mismatched register sizes for EOR (immediate).");
         }
    }

    // 2. Encode the bitmask immediate
    uint32_t n_val, immr_val, imms_val;
    if (!encode_bitmask_immediate(static_cast<uint64_t>(immediate), is_64bit, n_val, immr_val, imms_val)) {
        throw std::invalid_argument("Immediate value " + std::to_string(immediate) + " cannot be encoded for EOR instruction.");
    }

    // 3. Use BitPatcher to construct the instruction word.
    // Base opcode for Logical (immediate) with opc=10 (EOR) is 0x52000000.
    BitPatcher patcher(0x52000000);

    if (is_64bit) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(n_val, 22, 1);       // N bit
    patcher.patch(immr_val, 16, 6);    // immr
    patcher.patch(imms_val, 10, 6);    // imms
    patcher.patch(rn_num, 5, 5);       // Rn
    patcher.patch(rd_num, 0, 5);       // Rd

    // 4. Format the assembly string and return the Instruction object.
    std::string assembly_text = "EOR " + xd + ", " + xn + ", #" + std::to_string(immediate);
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::EOR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/enc_create_str_word_imm.cpp
#include "Encoder.h"
#include "BitPatcher.h"

// Implements Encoder::create_str_word_imm for 32-bit STR (store word) instruction.
// STR Wt, [Xn, #imm12] -- stores a 32-bit word from Wt to [Xn + imm12]

Instruction Encoder::create_str_word_imm(const std::string& wt, const std::string& xn, int immediate) {
    // Base opcode for STR (word, unsigned immediate) is 0xB9000000
    BitPatcher patcher(0xB9000000);

    // Immediate is 12 bits, unsigned
    uint32_t imm12 = static_cast<uint32_t>(immediate) & 0xFFF;

    // Patch imm12 at bits [21:10]
    patcher.patch(imm12, 10, 12);

    // Patch Rn (base address register) at bits [9:5]
    patcher.patch(get_reg_encoding(xn), 5, 5);

    // Patch Rt (source register Wt) at bits [4:0]
    patcher.patch(get_reg_encoding(wt), 0, 5);

    std::string assembly_text = "STR " + wt + ", [" + xn + ", #" + std::to_string(immediate) + "]";
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::STR;
    instr.src_reg1 = Encoder::get_reg_encoding(wt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/create_sdiv_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'SDIV' (Signed Divide) instruction.
 * @details
 * This function generates the 32-bit machine code for a signed division instruction.
 * The instruction has the format: `SDIV <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * The operation is `$rd = rn / rm$`.
 *
 * The encoding follows the "Data-processing (2 source)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **S (bit 29)**: Must be 0.
 * - **Family (bits 28-22)**: `0b11010110`.
 * - **Rm (bits 20-16)**: The divisor register `xm`.
 * - **opcode2 (bits 15-10)**: `0b000111` for SDIV.
 * - **Rn (bits 9-5)**: The dividend register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register.
 * @param xn The dividend register.
 * @param xm The divisor register.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_sdiv_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_sdiv_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for SDIV must be the same size.");
    }

    // The base opcode for 32-bit SDIV is 0x1AC01C00.
     // The base opcode for 64-bit SDIV is 0x9AC01C00.
     uint32_t base_opcode = rd_is_64 ? 0x9AC00C00 : 0x1AC00C00;
     BitPatcher patcher(base_opcode);

    patcher.patch(rm_num, 16, 5); // Patch the divisor register.
    patcher.patch(rn_num, 5, 5);  // Patch the dividend register.
    patcher.patch(rd_num, 0, 5);  // Patch the destination register.

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "SDIV " + xd + ", " + xn + ", " + xm;

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::SDIV;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/enc_create_fcvt_d_to_s.cpp
#include "../Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>

// ARM64 FCVT (Floating-point Convert precision)
// This instruction converts from double precision (D) to single precision (S)
// Encoding: FCVT Sd, Dn
// 0x1E224000 | (Rn << 5) | Rd
// Where Rn is the D register (bits 5-9) and Rd is the S register (bits 0-4)

Instruction Encoder::create_fcvt_d_to_s(const std::string& sd, const std::string& dn) {
    // Parse S register number from "S0", "S1", etc.
    auto parse_s_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'S') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    // Parse D register number from "D0", "D1", etc.
    auto parse_d_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'D') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    int s_dst = parse_s_reg(sd);
    int d_src = parse_d_reg(dn);

    if (s_dst < 0 || s_dst > 31 || d_src < 0 || d_src > 31) {
        throw std::runtime_error("Invalid register for FCVT D to S: " + sd + ", " + dn);
    }

    // FCVT Sd, Dn encoding (double to single precision)
    BitPatcher patcher(0x1E224000);
    patcher.patch(d_src, 5, 5); // bits 5-9: source D register
    patcher.patch(s_dst, 0, 5); // bits 0-4: destination S register

    Instruction instr(patcher.get_value(), "FCVT " + sd + ", " + dn);
    instr.opcode = InstructionDecoder::OpType::FCVT;
    instr.dest_reg = Encoder::get_reg_encoding(sd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);

    return instr;
}
// encoders/enc_create_stp_pre_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'STP' (Store Pair) instruction with pre-indexing.
 * @details
 * This function generates the machine code to first update a base register by adding an
 * immediate offset, and then store a pair of registers to the new address.
 * [cite_start]The operation is `STP <Xt1>, <Xt2>, [<Xn>, #imm]!`. [cite: 1]
 *
 * The encoding follows the "Load/Store Pair (pre-index)" format:
 * - **size** (bits 31-30): `10` for 64-bit, `00` for 32-bit.
 * - **Family** (bits 29-24): `0b101001`.
 * - **L** (bit 22): `0` for Store.
 * - **imm7** (bits 21-15): A 7-bit signed immediate, scaled by the register size.
 * - **Rt2** (bits 14-10): The second source register.
 * - **Rn** (bits 9-5): The base address register (to be updated).
 * - **Rt** (bits 4-0): The first source register.
 *
 * @param xt1 The first source register to store.
 * @param xt2 The second source register to store.
 * @param xn The base address register (will be updated).
 * @param immediate The signed byte offset to add to the base register before storing. Must be a multiple of the register size (4 or 8).
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, mismatched sizes, or out-of-range/unaligned immediates.
 */
Instruction Encoder::create_stp_pre_imm(const std::string& xt1, const std::string& xt2, const std::string& xn, int immediate) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_stp_pre_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt1_num, rt1_is_64] = parse_register(xt1);
    auto [rt2_num, rt2_is_64] = parse_register(xt2);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rt1_is_64 != rt2_is_64) {
        throw std::invalid_argument("STP registers to be stored must be the same size.");
    }
    if (!rn_is_64) {
        throw std::invalid_argument("STP base register must be a 64-bit 'X' register or SP.");
    }

    uint32_t base_opcode;
    int scale;
    int min_offset, max_offset;

    if (rt1_is_64) { // 64-bit STP
        base_opcode = 0xA9800000;
        scale = 8;
        min_offset = -512;
        max_offset = 504;
    } else { // 32-bit STP
        base_opcode = 0x29800000;
        scale = 4;
        min_offset = -256;
        max_offset = 252;
    }

    if (immediate < min_offset || immediate > max_offset || immediate % scale != 0) {
        throw std::invalid_argument("Invalid immediate for STP pre-index. Must be a multiple of " + std::to_string(scale) +
                                  " in range [" + std::to_string(min_offset) + ", " + std::to_string(max_offset) + "].");
    }

    uint32_t imm7 = (immediate / scale) & 0x7F; // Get the 7-bit scaled immediate

    BitPatcher patcher(base_opcode);
    patcher.patch(imm7, 15, 7);
    patcher.patch(rt2_num, 10, 5);
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rt1_num, 0, 5);

    std::string assembly_text = "STP " + xt1 + ", " + xt2 + ", [" + xn + ", #" + std::to_string(immediate) + "]!";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::STP;
    instr.src_reg1 = Encoder::get_reg_encoding(xt1); // First source register
    instr.src_reg2 = Encoder::get_reg_encoding(xt2); // Second source register
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/enc_create_fcvtms_reg.cpp
#include "Encoder.h"
#include <sstream>
#include "BitPatcher.h"

Instruction Encoder::create_fcvtms_reg(const std::string& xd, const std::string& dn) {
    uint32_t rd = get_reg_encoding(xd);
    uint32_t rn = get_reg_encoding(dn);

    // Encoding for FCVTMS Xd, Dn (from double to signed 64-bit, rounding toward minus infinity)
    BitPatcher patcher(0x9E780000);
    patcher.patch(rn, 5, 5); // Dn at bits [9:5]
    patcher.patch(rd, 0, 5);  // Xd at bits [4:0]

    std::stringstream ss;
    ss << "FCVTMS " << xd << ", " << dn;
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::FCVTMS; // You may need to add this OpType
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    return instr;
}

// encoders/enc_create_dmb.cpp
#include "Encoder.h"

Instruction Encoder::create_dmb() {
    // The opcode for DMB ISH (Data Memory Barrier, Inner Shareable) is fixed.
    // This instruction ensures that all memory accesses appearing before
    // the DMB are observed before any memory accesses appearing after the DMB.
    const uint32_t encoding = 0xD5033BFF;

    Instruction instr(encoding, "DMB ISH");
    instr.opcode = InstructionDecoder::OpType::DMB;
    return instr;
}

// encoders/Encoder_canEncodeAsImmediate.cpp
#include "../Encoder.h"
#include "../InstructionDecoder.h"
#include <cstdint>
#include <limits>

// Helper for ADD/SUB: 12-bit unsigned, optionally shifted by 12
static bool canEncodeAddSubImmediate(int64_t imm) {
    // 12-bit unsigned, no shift
    if (imm >= 0 && imm <= 0xFFF) return true;
    // 12-bit unsigned, shifted left by 12 (imm12 << 12)
    if ((imm & 0xFFF) == 0 && (imm >> 12) >= 0 && (imm >> 12) <= 0xFFF) return true;
    return false;
}

// Helper for logical immediates (AND/ORR/EOR): ARM64 "bitmask immediate" encoding
// This is a complex encoding; here we use a conservative approximation for common cases.
// For a full implementation, see ARM ARM C3.2.5, but here are some common encodable values:
// - All-ones (e.g., 0xFF, 0xFFFF, 0xFFFFFFFF, etc.)
// - Single contiguous runs of 1s (e.g., 0x3C, 0xF0, 0xFF00, etc.)
// - Powers of two minus one (e.g., 0x1, 0x3, 0x7, 0xF, 0x1F, ...)
// - Inverse of above (e.g., 0xFFFFFFFE, 0xFFFFFFFC, ...)
// This function is intentionally conservative: it may reject some encodable values, but will not accept invalid ones.
static bool isBitmaskImmediate(uint64_t imm, int width) {
    // Trivial cases
    if (imm == 0 || imm == std::numeric_limits<uint64_t>::max()) return false;
    if (width == 32) imm &= 0xFFFFFFFF;

    // Check for single run of 1s (e.g., 0x000FF000)
    uint64_t x = imm | (imm >> 1);
    x |= (x >> 2);
    x |= (x >> 4);
    x |= (x >> 8);
    x |= (x >> 16);
    x |= (x >> 32);
    // If x is all 1s, then imm was a single run of 1s (possibly rotated)
    if (x == (width == 32 ? 0xFFFFFFFF : 0xFFFFFFFFFFFFFFFF)) {
        // Now check if imm is a rotated run of 1s
        for (int rot = 0; rot < width; ++rot) {
            uint64_t rotated = ((imm << rot) | (imm >> (width - rot))) & ((1ULL << width) - 1);
            if ((rotated & (rotated + 1)) == 0) return true; // All 1s are contiguous
        }
    }

    // Common bitmask patterns
    // All-ones in a byte/halfword/word
    for (int size = 1; size <= width; size <<= 1) {
        uint64_t mask = (1ULL << size) - 1;
        for (int shift = 0; shift <= width - size; ++shift) {
            if ((imm & (mask << shift)) == (mask << shift) && (imm | (mask << shift)) == ((1ULL << width) - 1)) {
                return true;
            }
        }
    }

    // Powers of two minus one
    if ((imm & (imm + 1)) == 0) return true;
    // Inverse: powers of two minus one, inverted
    uint64_t inv = ~imm & ((1ULL << width) - 1);
    if ((inv & (inv + 1)) == 0) return true;

    return false;
}

bool Encoder::canEncodeAsImmediate(InstructionDecoder::OpType opcode, int64_t immediate) {
    using OpType = InstructionDecoder::OpType;
    switch (opcode) {
        case OpType::ADD:
        case OpType::SUB:
            // ADD/SUB (immediate): 12-bit unsigned, optionally shifted by 12
            return canEncodeAddSubImmediate(immediate);

        case OpType::AND:
        case OpType::ORR:
        case OpType::EOR:
            // Logical immediates: ARM64 bitmask immediate encoding
            // Try both 32-bit and 64-bit encodings
            return isBitmaskImmediate(static_cast<uint64_t>(immediate), 32) ||
                   isBitmaskImmediate(static_cast<uint64_t>(immediate), 64);

        // You can add more opcodes and their rules here as needed.
        default:
            // For unknown opcodes, be conservative and return false.
            return false;
    }
}

// encoders/create_movk_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'MOVK' (Move with Keep) instruction.
 * @details
 * This function generates the 32-bit machine code to move a 16-bit immediate
 * into a register, keeping the other bits of the register unchanged.
 * The instruction has the format: `MOVK <Xd|Wd>, #imm{, LSL #shift}`.
 *
 * The encoding follows the "Move wide (immediate)" format:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `0b11` for MOVK.
 * - **Family (bits 28-23)**: `0b100101`.
 * - **hw (bits 22-21)**: The shift amount, encoded as `shift / 16`.
 * - **imm16 (bits 20-5)**: The 16-bit immediate value.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0").
 * @param immediate The 16-bit immediate value to move.
 * @param shift The left shift to apply. Must be 0, 16, 32, or 48.
 * @param rel The relocation type for the instruction, used by the linker.
 * @param target The target symbol for relocation.
 * @return An `Instruction` object containing the encoding and other metadata.
 * @throw std::invalid_argument for invalid registers or invalid shift values.
 */
Instruction Encoder::create_movk_imm(const std::string& xd, uint16_t immediate, int shift, RelocationType rel, const std::string& target) {
    // (A) Self-checking: Validate the shift value.
    if (shift != 0 && shift != 16 && shift != 32 && shift != 48) {
        throw std::invalid_argument("Invalid shift for MOVK. Must be 0, 16, 32, or 48.");
    }

    // Helper lambda to parse the destination register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_movk_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(xd);

    // A 32-bit register cannot be shifted by 32 or 48.
    if (!rd_is_64 && (shift == 32 || shift == 48)) {
        throw std::invalid_argument("Cannot use a shift of 32 or 48 with a 32-bit 'W' register.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for MOVK is 0x72800000.
    BitPatcher patcher(0x72800000);

    // Set the size flag (sf) for a 64-bit register destination.
    if (rd_is_64) {
        patcher.patch(1, 31, 1);
    }

    // Encode the shift into the 'hw' field (bits 21-22).
    uint32_t hw = shift / 16;
    patcher.patch(hw, 21, 2);

    // Patch the 16-bit immediate into bits 5-20.
    patcher.patch(immediate, 5, 16);

    // Patch the destination register (Rd) into bits 0-4.
    patcher.patch(rd_num, 0, 5);

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "MOVK " + xd + ", #" + std::to_string(immediate);
    if (shift > 0) {
        assembly_text += ", LSL #" + std::to_string(shift);
    }

    // (D) Return the completed Instruction object, including relocation info.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::MOVK;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    return instr;
}

// encoders/create_lsl_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LSL (immediate)' instruction.
 * @details
 * This function generates the 32-bit machine code for an LSL instruction
 * that performs a logical left shift on a register by an immediate amount.
 * The instruction has the format: `LSL <Xd|Wd>, <Xn|Wn>, #<shift_amount>`.
 *
 * This instruction is an alias for `UBFM` (Unsigned Bitfield Move).
 * The encoding follows the "Bitfield" format with the following bitfield layout:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-29)**: `10` for UBFM.
 * - **N (bit 22)**: Must match `sf`. `1` for 64-bit, `0` for 32-bit.
 * - **immr (bits 21-16)**: The rotate amount. For LSL, this is `(-shift) MOD datasize`.
 * - **imms (bits 15-10)**: The bitmask width. For LSL, this is `(datasize - 1 - shift)`.
 * - **Rn (bits 9-5)**: The source register (`xn`).
 * - **Rd (bits 4-0)**: The destination register (`xd`).
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register to be shifted.
 * @param shift_amount The immediate shift amount (0-63 for 64-bit, 0-31 for 32-bit).
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or out-of-range shift amount.
 */
Instruction Encoder::create_lsl_imm(const std::string& xd, const std::string& xn, int shift_amount) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_lsl_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 30) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'. Use 'wsp'/'sp' or 'wzr'/'xzr' for register 31.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rd_is_64 != rn_is_64) {
        throw std::invalid_argument("Mismatched register sizes. Operands for LSL (immediate) must be the same size.");
    }

    int datasize = rd_is_64 ? 64 : 32;
    if (shift_amount < 0 || shift_amount >= datasize) {
        throw std::invalid_argument("Shift amount for LSL is out of range for the register size.");
    }

    // --- Correct Encoding Logic for LSL as UBFM ---
    uint32_t N = rd_is_64 ? 1 : 0;
    uint32_t immr = (datasize - shift_amount) % datasize;
    uint32_t imms = datasize - 1 - shift_amount;
    
    // Base opcode for UBFM is 0x53000000 (for 32-bit)
    BitPatcher patcher(0x53000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // sf bit
        patcher.patch(1, 22, 1); // N bit
    }

    patcher.patch(immr, 16, 6); // immr
    patcher.patch(imms, 10, 6); // imms
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rd_num, 0, 5);  // Rd
    
    std::string assembly_text = "LSL " + xd + ", " + xn + ", #" + std::to_string(shift_amount);

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LSL;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = shift_amount;
    instr.uses_immediate = true;
    return instr;
}

// encoders/opt_create_asr_reg.cpp
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'ASR (register)' instruction (ASRV).
 * @details
 * This function generates the 32-bit machine code for an ASR instruction
 * that performs an arithmetic right shift on a register by a variable amount
 * specified in a second register. The canonical name for this instruction is ASRV.
 * The instruction has the format: `ASR <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 *
 * The encoding follows the "Data-processing (2 source)" format for ASRV:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **S (bit 30)**: Must be 0.
 * - **Family (bits 29-22)**: Fixed value of `0b11010110`.
 * - **Rm (bits 20-16)**: The register containing the shift amount (`xm`).
 * - **opcode2 (bits 15-10)**: Fixed value of `0b000100` for ASRV.
 * - **Rn (bits 9-5)**: The source register to be shifted (`xn`).
 * - **Rd (bits 4-0)**: The destination register (`xd`).
 *
 * @param xd The destination register (e.g., "x0").
 * @param xn The source register to be shifted.
 * @param xm The register containing the shift amount.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::opt_create_asr_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by opt_create_asr_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for ASR (register) must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit ASRV is 0x1AC01000.
    BitPatcher patcher(0x1AC01000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the registers into their respective fields.
    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "ASR " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ASR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/enc_create_fmla_vector_reg.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_fmla_vector_reg(const std::string& vd, const std::string& vn, const std::string& vm, const std::string& arrangement) {
    uint32_t rd = get_reg_encoding(vd);
    uint32_t rn = get_reg_encoding(vn);
    uint32_t rm = get_reg_encoding(vm);

    // Encoding for FMLA Vd.4S, Vn.4S, Vm.4S (32-bit single-precision floats)
    // Q(1) | 0 | 0 | 1110 | 1 | M(0) | 1 | Rm | 1000 | Rn | Rd
    uint32_t encoding = 0x4E208000 | (rm << 16) | (rn << 5) | rd;

    std::stringstream ss;
    ss << "FMLA " << vd << "." << arrangement << ", " << vn << "." << arrangement << ", " << vm << "." << arrangement;
    Instruction instr(encoding, ss.str());
    instr.opcode = InstructionDecoder::OpType::FMLA_VECTOR;
    instr.dest_reg = Encoder::get_reg_encoding(vd);
    instr.src_reg1 = Encoder::get_reg_encoding(vn);
    instr.src_reg2 = Encoder::get_reg_encoding(vm);
    return instr;
}

// encoders/enc_create_fmov_d_to_x.cpp
#include "Encoder.h"
#include "BitPatcher.h"
#include <stdexcept>
#include <string>

// ARM64 FMOV (64-bit variant, scalar, from vector register to general-purpose register)
// This instruction moves the contents of a D register to an X register
// Encoding: FMOV Xd, Dn
// 0x9E660000 | (Rn << 5) | Rd
// Where Rn is the D register (bits 5-9) and Rd is the X register (bits 0-4)

Instruction Encoder::create_fmov_d_to_x(const std::string& xd, const std::string& dn) {
    // Parse X register number from "X0", "X1", etc.
    auto parse_x_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'X') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    // Parse D register number from "D0", "D1", etc.
    auto parse_d_reg = [](const std::string& reg) -> int {
        if (reg.size() < 2 || reg[0] != 'D') return -1;
        try {
            return std::stoi(reg.substr(1));
        } catch (...) {
            return -1;
        }
    };

    int x_dst = parse_x_reg(xd);
    int d_src = parse_d_reg(dn);

    if (x_dst < 0 || x_dst > 31 || d_src < 0 || d_src > 31) {
        throw std::runtime_error("Invalid register for FMOV D to X: " + xd + ", " + dn);
    }

    // FMOV Xd, Dn encoding (64-bit scalar)
    BitPatcher patcher(0x9E660000);
    patcher.patch(d_src, 5, 5); // bits 5-9: source D register
    patcher.patch(x_dst, 0, 5); // bits 0-4: destination X register

    Instruction instr(patcher.get_value(), "FMOV " + xd + ", " + dn);
    instr.opcode = InstructionDecoder::OpType::FMOV;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);

    return instr;
}
// encoders/enc_create_adrp.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'ADRP' instruction.
 * @details
 * This function generates the machine code for an ADRP instruction. ADRP
 * calculates the address of the 4KB memory page containing a PC-relative
 * address and writes it to a register. It's the first part of a standard
 * two-instruction sequence for loading a full address, typically followed by
 * an `ADD (immediate)` to add the lower 12 bits.
 *
 * The immediate fields (immlo, immhi) are set to 0, and the instruction is
 * tagged with `RelocationType::PAGE_21_BIT_PC_RELATIVE`. The linker is
 * responsible for calculating the final 21-bit signed page offset from the
 * PC and patching it into the instruction.
 *
 * The encoding follows the "PC-relative addressing" format:
 * - **op (bit 31)**: 1 for ADRP.
 * - **immlo (bits 30-29)**: Low 2 bits of the 21-bit page offset.
 * - **Family (bits 28-24)**: `0b10000`.
 * - **immhi (bits 23-5)**: High 19 bits of the 21-bit page offset.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (must be a 64-bit 'X' register).
 * @param label_name The target label for the address calculation.
 * @return An `Instruction` object with relocation info for the linker.
 * @throw std::invalid_argument if the register is not a 64-bit 'X' register.
 */
Instruction Encoder::create_adrp(const std::string& xd, const std::string& label_name) {
    // Helper lambda to parse the destination register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        // ADRP only operates on 64-bit general-purpose registers.
        if (lower_reg.rfind("x", 0) != 0) {
            throw std::invalid_argument("Invalid register for ADRP: '" + reg_str + "'. Must be an 'X' register.");
        }

        try {
            uint32_t reg_num = std::stoul(lower_reg.substr(1));
            if (reg_num > 30) { // X31 (SP/XZR) is not a valid destination for ADRP.
                throw std::out_of_range("Register X31 (SP/XZR) is not a valid destination for ADRP.");
            }
            return {reg_num, true}; // is_64bit is always true
        } catch (const std::logic_error&) {
            throw std::invalid_argument("Invalid register format for ADRP: '" + reg_str + "'.");
        }
    };

    // (A) Parse and validate the register.
    auto [rd_num, rd_is_64] = parse_register(xd);

    // This check is slightly redundant given the parser's logic, but serves as a safeguard.
    if (!rd_is_64) {
        throw std::invalid_argument("ADRP instruction requires a 64-bit 'X' destination register.");
    }

    // (B) Use BitPatcher. The base for ADRP is 0x90000000.
    // The immediate fields are left as zero for the linker to patch.
    BitPatcher patcher(0x90000000);

    // Patch the destination register.
    patcher.patch(rd_num, 0, 5); // Rd

    // (C) Format the assembly string.
    std::string assembly_text = "ADRP " + xd + ", " + label_name;

    // (D) Return the completed Instruction object with relocation information.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::ADRP;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.relocation = RelocationType::PAGE_21_BIT_PC_RELATIVE;
    instr.target_label = label_name;
    return instr;
}

// encoders/create_eor_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'EOR (register)' instruction.
 * @details
 * This function generates the 32-bit machine code for an EOR instruction
 * that performs a bitwise XOR between two source registers and stores the result
 * in a destination register. The instruction has the format:
 * `EOR <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * The logical operation is `$rd = rn ^ op2$`, where op2 is the `rm` register.
 *
 * The encoding follows the "Data-processing (register)" format:
 * - **sf (bit 31)**: 1 for 64-bit (X regs), 0 for 32-bit (W regs).
 * - **opc (bits 30-24)**: `0b1001010` for the EOR (register) instruction.
 * - **Rm (bits 20-16)**: The second source register `xm`.
 * - **Rn (bits 9-5)**: The first source register `xn`.
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The first source register (e.g., "x1", "sp").
 * @param xm The second source register (e.g., "x2", "wzr").
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument if register names are invalid or if sizes are mixed.
 */
Instruction Encoder::create_eor_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings like "x0", "w1", "sp", "wzr".
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_eor_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 30) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'. Use 'wsp'/'sp' or 'wzr'/'xzr' for register 31.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Perform self-checking by parsing and validating all register arguments first.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for EOR (register) must be simultaneously 32-bit (W) or 64-bit (X).");
    }

    // (B) Use the BitPatcher to construct the instruction word.
    // Base opcode for 32-bit EOR (register) is 0x4A000000.
    BitPatcher patcher(0x4A000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // sf bit
    }

    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "EOR " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::EOR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}
// encoders/enc_create_str_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'STR' (Store Register) instruction with an unsigned immediate offset.
 * @details
 * This function generates the machine code to store a register to memory using a
 * base register and an unsigned, scaled immediate offset.
 * [cite_start]The operation is `STR <Xt>, [<Xn>{, #imm}]`[cite: 88].
 *
 * The encoding follows the "Load/Store Register (unsigned immediate)" format:
 * - **size** (bits 31-30): `11` for 64-bit, `10` for 32-bit.
 * - **Family** (bits 29-24): `0b111001`.
 * - **L** (bit 22): `0` for **Store**.
 * - **imm12** (bits 21-10): A 12-bit unsigned immediate, scaled by the register size.
 * - **Rn** (bits 9-5): The base address register.
 * - **Rt** (bits 4-0): The source register.
 *
 * @param xt The source register to store (e.g., "x0", "w0").
 * @param xn The base address register (e.g., "x2", "sp").
 * @param immediate The unsigned byte offset. For 64-bit stores, this must be a multiple of 8 in the range [0, 32760]. For 32-bit, a multiple of 4 in [0, 16380].
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers, out-of-range/unaligned immediates, or using a 32-bit base register.
 */
Instruction Encoder::create_str_imm(const std::string& xt, const std::string& xn, int immediate, const std::string& variable_name) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_str_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt_num, rt_is_64] = parse_register(xt);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (!rn_is_64) {
        throw std::invalid_argument("STR base register must be a 64-bit 'X' register or SP.");
    }

    uint32_t base_opcode;
    int scale;
    int max_offset;

    if (rt_is_64) { // 64-bit STR
        base_opcode = 0xF9000000;
        scale = 8;
        max_offset = 32760;
    } else { // 32-bit STR
        base_opcode = 0xB9000000;
        scale = 4;
        max_offset = 16380;
    }

    if (immediate < 0 || immediate > max_offset || immediate % scale != 0) {
        throw std::invalid_argument("Invalid immediate for STR. Must be a multiple of " + std::to_string(scale) +
                                  " in range [0, " + std::to_string(max_offset) + "].");
    }

    uint32_t imm12 = (immediate / scale);

    BitPatcher patcher(base_opcode);
    patcher.patch(imm12, 10, 12);
    patcher.patch(rn_num, 5, 5);
    patcher.patch(rt_num, 0, 5);

    std::string assembly_text = "STR " + xt + ", [" + xn + ", #" + std::to_string(immediate) + "]";

    // Append the variable name to the comment if provided
    if (!variable_name.empty() && assembly_text.find(variable_name) == std::string::npos) {
        assembly_text += " ; " + variable_name;
    }

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::STR;
    instr.src_reg1 = Encoder::get_reg_encoding(xt); // The register being stored
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/create_mov_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'MOV (register)' instruction.
 * @details
 * This function generates the 32-bit machine code to move a value from one
 * register to another. The `MOV` instruction is an alias for `ORR` (Bitwise OR)
 * where the first source register (`Rn`) is the zero register (WZR/XZR).
 * The operation `MOV <Xd>, <Xn>` is encoded as `ORR <Xd>, <XZR/WZR>, <Xn>`.
 *
 * [cite_start]The encoding follows the "Data-processing (register)" format for ORR[cite: 1, 58]:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **opc (bits 30-24)**: `0b0101010` for the ORR (register) instruction.
 * - **Rm (bits 20-16)**: The source register `xn`.
 * - **Rn (bits 9-5)**: `0b11111` (the zero register).
 * - **Rd (bits 4-0)**: The destination register `xd`.
 *
 * @param xd The destination register (e.g., "x0", "wsp").
 * @param xn The source register (e.g., "x1", "wzr").
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_mov_reg(const std::string& xd, const std::string& xn) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_mov_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rd_is_64 != rn_is_64) {
        throw std::invalid_argument("Mismatched register sizes. Operands for MOV (register) must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit ORR (register) is 0x2A000000.
    BitPatcher patcher(0x2A000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the destination register (Rd).
    patcher.patch(rd_num, 0, 5);

    // Patch the source register (Xn) into the Rm field.
    patcher.patch(rn_num, 16, 5);

    // Patch the first source register (Rn) to be the zero register (31).
    patcher.patch(31, 5, 5);

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "MOV " + xd + ", " + xn;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::MOV;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    return instr;
}

// encoders/enc_create_fmul_reg.cpp
#include "Encoder.h"
#include "BitPatcher.h" // Make sure to include BitPatcher
#include <sstream>

/**
 * @brief Encodes the ARM64 'FMUL' (Floating-point Multiply) instruction.
 * @details
 * This function generates the machine code to multiply two double-precision
 * floating-point registers and store the result in a third register.
 * The operation is `FMUL <Dd>, <Dn>, <Dm>`.
 *
 * The encoding follows the "Floating-point data-processing (2 source)" format:
 * - **M (bit 31)**: `0`
 * - **S (bit 30)**: `0`
 * - **type (bits 23-22)**: `01` for double-precision.
 * - **opcode (bits 20-12)**: `0001000` for FMUL.
 * - **Rm (bits 20-16)**: The second source register.
 * - **Rn (bits 9-5)**: The first source register.
 * - **Rd (bits 4-0)**: The destination register.
 *
 * @param dd The destination register (e.g., "D0").
 * @param dn The first source register (e.g., "D1").
 * @param dm The second source register (e.g., "D2").
 * @return An `Instruction` object.
 */
Instruction Encoder::create_fmul_reg(const std::string& dd, const std::string& dn, const std::string& dm) {
    uint32_t rd = get_reg_encoding(dd);
    uint32_t rn = get_reg_encoding(dn);
    uint32_t rm = get_reg_encoding(dm);

    // The correct base opcode for FMUL Dd, Dn, Dm (double-precision) is 0x1E600800.
    BitPatcher patcher(0x1E600800);

    // Patch the register fields into the base opcode.
    patcher.patch(rm, 16, 5); // Patch the second source register (Rm).
    patcher.patch(rn, 5, 5);  // Patch the first source register (Rn).
    patcher.patch(rd, 0, 5);  // Patch the destination register (Rd).

    std::stringstream ss;
    ss << "FMUL " << dd << ", " << dn << ", " << dm;
    Instruction instr(patcher.get_value(), ss.str());
    instr.opcode = InstructionDecoder::OpType::FMUL;
    instr.dest_reg = Encoder::get_reg_encoding(dd);
    instr.src_reg1 = Encoder::get_reg_encoding(dn);
    instr.src_reg2 = Encoder::get_reg_encoding(dm);
    return instr;
}

// encoders/create_lsr_reg.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LSR (register)' instruction (LSRV).
 * @details
 * This function generates the 32-bit machine code for an LSR instruction
 * that performs a logical right shift on a register by a variable amount
 * specified in a second register. The canonical name for this instruction is LSRV.
 * The instruction has the format: `LSR <Xd|Wd>, <Xn|Wn>, <Xm|Wm>`.
 * [cite_start]The operation is described as `$rd = rn >> rm$`[cite: 1].
 *
 * The encoding follows the "Data-processing (2 source)" format for LSRV:
 * - **sf (bit 31)**: 1 for 64-bit, 0 for 32-bit.
 * - **S (bit 30)**: Must be 0.
 * - **Family (bits 29-22)**: Fixed value of `0b11010110`.
 * - **Rm (bits 20-16)**: The register containing the shift amount (`xm`).
 * - **opcode2 (bits 15-10)**: Fixed value of `0b000011` for LSRV.
 * - **Rn (bits 9-5)**: The source register to be shifted (`xn`).
 * - **Rd (bits 4-0)**: The destination register (`xd`).
 *
 * @param xd The destination register (e.g., "x0").
 * @param xn The source register to be shifted.
 * @param xm The register containing the shift amount.
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or mismatched sizes.
 */
Instruction Encoder::create_lsr_reg(const std::string& xd, const std::string& xn, const std::string& xm) {
    // Helper lambda to parse register strings.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_lsr_reg)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    // (A) Self-checking: parse and validate registers.
    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);
    auto [rm_num, rm_is_64] = parse_register(xm);

    if (!(rd_is_64 == rn_is_64 && rn_is_64 == rm_is_64)) {
        throw std::invalid_argument("Mismatched register sizes. All operands for LSR (register) must be the same size.");
    }

    // (B) Use BitPatcher to construct the instruction word.
    // Base opcode for 32-bit LSRV is 0x1AC02400.
    BitPatcher patcher(0x1AC02400);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // Set the sf bit for 64-bit operation.
    }

    // Patch the registers into their respective fields.
    patcher.patch(rd_num, 0, 5);  // Rd
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rm_num, 16, 5); // Rm

    // (C) Format the assembly string for the Instruction object.
    std::string assembly_text = "LSR " + xd + ", " + xn + ", " + xm;

    // (D) Return the completed Instruction object. No relocation is needed.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LSR;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.src_reg2 = Encoder::get_reg_encoding(xm);
    return instr;
}

// encoders/enc_create_cset.cpp
#include "../BitPatcher.h"
#include "../Encoder.h"
#include "../InstructionDecoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

namespace {
ConditionCode stringToConditionCode(const std::string& cond) {
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);
    if (upper_cond == "EQ") return ConditionCode::EQ;
    if (upper_cond == "NE") return ConditionCode::NE;
    if (upper_cond == "CS") return ConditionCode::CS;
    if (upper_cond == "CC") return ConditionCode::CC;
    if (upper_cond == "MI") return ConditionCode::MI;
    if (upper_cond == "PL") return ConditionCode::PL;
    if (upper_cond == "VS") return ConditionCode::VS;
    if (upper_cond == "VC") return ConditionCode::VC;
    if (upper_cond == "HI") return ConditionCode::HI;
    if (upper_cond == "LS") return ConditionCode::LS;
    if (upper_cond == "GE") return ConditionCode::GE;
    if (upper_cond == "LT") return ConditionCode::LT;
    if (upper_cond == "GT") return ConditionCode::GT;
    if (upper_cond == "LE") return ConditionCode::LE;
    if (upper_cond == "AL") return ConditionCode::AL;
    if (upper_cond == "NV") return ConditionCode::NV;
    return ConditionCode::UNKNOWN;
}
}

// Forward declaration of the helper function from enc_create_branch_conditional.cpp
uint32_t get_condition_code(const std::string& cond);

// Helper to invert a condition code by flipping its least significant bit.
// For example, EQ (0b0000) becomes NE (0b0001).
uint32_t invert_condition_code(uint32_t cond) {
    return cond ^ 1;
}

/**
 * @brief Encodes the ARM64 'CSET' (Conditional Set) instruction.
 * @details
 * This function generates the machine code to set the destination register to 1
 * if a condition is TRUE, and 0 otherwise.
 *
 * `CSET` is an alias for the `CSINC` (Conditional Set Increment) instruction.
 * [cite_start]The operation `CSET Rd, cond` is encoded as `CSINC Rd, ZR, ZR, invert(cond)`[cite: 3].
 * The `CSINC` encoding follows the "Conditional select" format.
 *
 * @param Rd The destination register (e.g., "x0", "w1").
 * @param cond The condition mnemonic as a string (e.g., "EQ", "LT", "GE").
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or unrecognized conditions.
 */
Instruction Encoder::create_cset(const std::string& Rd, const std::string& cond) {
    // (A) Get the numeric condition code and invert it for the CSINC alias.
    uint32_t cond_code = get_condition_code(cond);
    uint32_t inverted_cond_code = invert_condition_code(cond_code);

    // Helper lambda to parse the destination register.
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_cset)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(Rd);

    // (B) Use BitPatcher to encode CSINC Rd, ZR, ZR, !cond.
    // The base opcode for 32-bit CSINC is 0x1A800400.
    BitPatcher patcher(0x1A800400);

    // Patch sf for 64-bit operation.
    if (rd_is_64) {
        patcher.patch(1, 31, 1);
    }

    // Patch destination register (Rd)
    patcher.patch(rd_num, 0, 5);

    // Patch source registers (Rn and Rm) to be the zero register (31)
    patcher.patch(31, 5, 5);  // Rn = ZR
    patcher.patch(31, 16, 5); // Rm = ZR

    // Patch the INVERTED condition code
    patcher.patch(inverted_cond_code, 12, 4);

    // (C) Format the assembly string for the CSET alias.
    std::string upper_cond = cond;
    std::transform(upper_cond.begin(), upper_cond.end(), upper_cond.begin(), ::toupper);
    std::string assembly_text = "CSET " + Rd + ", " + upper_cond;

    // (D) Return the completed Instruction object.
    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::CSET;
    instr.dest_reg = Encoder::get_reg_encoding(Rd);

    // Set the semantic condition code field using the helper
    instr.cond = stringToConditionCode(cond);

    return instr;
}

// encoders/enc_create_directive.cpp
#include "Encoder.h"
#include <sstream>

Instruction Encoder::create_directive(const std::string& directive_text, uint64_t data_value, const std::string& target_label, bool is_data) {
    // For label definitions (like ".L6:"), use the directive_text directly
    // For data directives, use the data_value with .quad
    
    std::string assembly_text;
    
    if (directive_text.find(":") != std::string::npos) {
        // This is a label definition - use the directive_text as-is
        assembly_text = directive_text;
    } else {
        // This is a data directive - generate .quad with the data_value
        std::stringstream ss;
        ss << ".quad 0x" << std::hex << data_value;
        
        // Append the target label as a comment for clarity, if provided.
        if (!target_label.empty()) {
            ss << " ; " << target_label;
        }
        
        assembly_text = ss.str();
    }

    // Return the instruction with the appropriate assembly text
    Instruction instr(static_cast<uint32_t>(data_value & 0xFFFFFFFF), assembly_text, RelocationType::NONE, target_label, is_data, false);
    instr.opcode = InstructionDecoder::OpType::DIRECTIVE;
    return instr;
}
// encoders/enc_create_ldr_word_imm.cpp
#include "BitPatcher.h"
#include "Encoder.h"
#include <algorithm>
#include <cctype>
#include <stdexcept>
#include <string>

/**
 * @brief Encodes the ARM64 'LDR' (Load Register Word, 32-bit) instruction with an unsigned immediate offset.
 * @details
 * This function generates the machine code to load a 32-bit word from memory and
 * zero-extend it into the destination register.
 * The operation is `LDR <Wt>, [<Xn>{, #imm}]`.
 *
 * The encoding follows the "Load/Store Register (unsigned immediate)" format:
 * - **size (bits 31-30)**: `10` for word (32-bit) access.
 * - **Family (bits 29-24)**: `0b111001`.
 * - **L (bit 22)**: `1` for Load.
 * - **imm12 (bits 21-10)**: A 12-bit unsigned byte offset.
 * - **Rn (bits 9-5)**: The base address register.
 * - **Rt (bits 4-0)**: The destination register.
 *
 * @param wt The destination register (e.g., "w0"). The loaded word is zero-extended.
 * @param xn The base address register (e.g., "x1", "sp").
 * @param immediate The unsigned byte offset, in the range [0, 4095].
 * @return An `Instruction` object.
 * @throw std::invalid_argument for invalid registers or out-of-range immediates.
 */
Instruction Encoder::create_ldr_word_imm(const std::string& wt, const std::string& xn, int immediate) {
    if (immediate < 0 || immediate > 4095) {
        throw std::invalid_argument("Immediate for LDR (word) must be an unsigned 12-bit value [0, 4095].");
    }

    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) throw std::invalid_argument("Register string cannot be empty.");
        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);
        bool is_64bit;
        uint32_t reg_num;
        if (lower_reg == "wzr") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "xzr") { is_64bit = true; reg_num = 31;
        } else if (lower_reg == "wsp") { is_64bit = false; reg_num = 31;
        } else if (lower_reg == "sp") { is_64bit = true; reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') is_64bit = false;
            else if (prefix == 'x') is_64bit = true;
            else throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by create_ldr_word_imm)");
            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 31) throw std::out_of_range("Register number out of range.");
            } catch(...) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rt_num, rt_is_64] = parse_register(wt);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (!rn_is_64) {
        throw std::invalid_argument("LDR base register must be a 64-bit 'X' register or SP.");
    }
    if (rt_is_64) {
        throw std::invalid_argument("Destination register for LDR (word) must be a 32-bit 'W' register.");
    }

    // Base opcode for LDR (word, unsigned immediate) is 0xB9400000 (size=10)
    BitPatcher patcher(0xB9400000);

    patcher.patch(static_cast<uint32_t>(immediate), 10, 12); // imm12
    patcher.patch(rn_num, 5, 5);                             // Rn
    patcher.patch(rt_num, 0, 5);                             // Rt

    std::string assembly_text = "LDR " + wt + ", [" + xn;
    if (immediate != 0) {
        assembly_text += ", #" + std::to_string(immediate);
    }
    assembly_text += "]";

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LDR;
    instr.dest_reg = Encoder::get_reg_encoding(wt);
    instr.base_reg = Encoder::get_reg_encoding(xn);
    instr.immediate = immediate;
    instr.uses_immediate = true;
    instr.is_mem_op = true;
    return instr;
}

// encoders/opt_create_lsl_imm.cpp
#include <cstdint>
#include "BitPatcher.h"
#include "Encoder.h"
#include <string>
#include <stdexcept>
#include <algorithm>
#include <cctype>

/**
 * @brief Encodes the ARM64 'LSL (immediate)' instruction.
 * @details
 * This function generates the 32-bit machine code for an LSL instruction
 * that performs a logical left shift on a register by an immediate amount.
 * The instruction has the format: `LSL <Xd|Wd>, <Xn|Wn>, #<shift_amount>`.
 *
 * This instruction is an alias for `UBFM` (Unsigned Bitfield Move).
 * The encoding follows the "Bitfield" format with the following bitfield layout:
 * - [cite_start]**sf (bit 31)**: 1 for 64-bit, 0 for 32-bit[cite: 299].
 * - [cite_start]**opc (bits 30-29)**: `10` for UBFM[cite: 299].
 * - **N (bit 22)**: Must match `sf`. [cite_start]`1` for 64-bit, `0` for 32-bit[cite: 299].
 * - **immr (bits 21-16)**: The rotate amount. [cite_start]For LSL, this is `(-shift) MOD datasize`[cite: 299].
 * - **imms (bits 15-10)**: The bitmask width. [cite_start]For LSL, this is `(datasize - 1 - shift)`[cite: 299].
 * - [cite_start]**Rn (bits 9-5)**: The source register (`xn`)[cite: 299].
 * - [cite_start]**Rd (bits 4-0)**: The destination register (`xd`)[cite: 299].
 *
 * @param xd The destination register (e.g., "x0", "w1").
 * @param xn The source register to be shifted.
 * @param shift_amount The immediate shift amount (0-63 for 64-bit, 0-31 for 32-bit).
 * @return An `Instruction` object containing the encoding and assembly text.
 * @throw std::invalid_argument for invalid registers or out-of-range shift amount.
 */
Instruction Encoder::opt_create_lsl_imm(const std::string& xd, const std::string& xn, int shift_amount) {
    auto parse_register = [](const std::string& reg_str) -> std::pair<uint32_t, bool> {
        if (reg_str.empty()) {
            throw std::invalid_argument("Register string cannot be empty.");
        }

        std::string lower_reg = reg_str;
        std::transform(lower_reg.begin(), lower_reg.end(), lower_reg.begin(), ::tolower);

        bool is_64bit;
        uint32_t reg_num;

        if (lower_reg == "wzr") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "xzr") {
            is_64bit = true;
            reg_num = 31;
        } else if (lower_reg == "wsp") {
            is_64bit = false;
            reg_num = 31;
        } else if (lower_reg == "sp") {
            is_64bit = true;
            reg_num = 31;
        } else {
            char prefix = lower_reg[0];
            if (prefix == 'w') {
                is_64bit = false;
            } else if (prefix == 'x') {
                is_64bit = true;
            } else {
                throw std::invalid_argument("Invalid register prefix in '" + reg_str + "'. Must be 'w' or 'x'. (Thrown by opt_create_lsl_imm)");
            }

            try {
                reg_num = std::stoul(reg_str.substr(1));
                if (reg_num > 30) {
                     throw std::out_of_range("Register number out of range for '" + reg_str + "'. Use 'wsp'/'sp' or 'wzr'/'xzr' for register 31.");
                }
            } catch (const std::logic_error&) {
                throw std::invalid_argument("Invalid register format: '" + reg_str + "'.");
            }
        }
        return {reg_num, is_64bit};
    };

    auto [rd_num, rd_is_64] = parse_register(xd);
    auto [rn_num, rn_is_64] = parse_register(xn);

    if (rd_is_64 != rn_is_64) {
        throw std::invalid_argument("Mismatched register sizes. Operands for LSL (immediate) must be the same size.");
    }

    int datasize = rd_is_64 ? 64 : 32;
    if (shift_amount < 0 || shift_amount >= datasize) {
        throw std::invalid_argument("Shift amount for LSL is out of range for the register size.");
    }

    // --- Encoding Logic for LSL as UBFM ---
    uint32_t immr = (datasize - shift_amount) % datasize;
    uint32_t imms = datasize - 1 - shift_amount;
    
    // Base opcode for UBFM is 0x53000000 (for 32-bit)
    BitPatcher patcher(0x53000000);

    if (rd_is_64) {
        patcher.patch(1, 31, 1); // sf bit
        patcher.patch(1, 22, 1); // N bit
    }

    patcher.patch(immr, 16, 6); // immr
    patcher.patch(imms, 10, 6); // imms
    patcher.patch(rn_num, 5, 5);  // Rn
    patcher.patch(rd_num, 0, 5);  // Rd
    
    std::string assembly_text = "LSL " + xd + ", " + xn + ", #" + std::to_string(shift_amount);

    Instruction instr(patcher.get_value(), assembly_text);
    instr.opcode = InstructionDecoder::OpType::LSL;
    instr.dest_reg = Encoder::get_reg_encoding(xd);
    instr.src_reg1 = Encoder::get_reg_encoding(xn);
    instr.immediate = shift_amount;
    instr.uses_immediate = true;
    return instr;
}

