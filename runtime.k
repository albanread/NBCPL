// runtime.c
// Standalone C runtime for BCPL
// This file is only compiled for standalone builds, not for JIT.

#include "runtime/runtime.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Forward declaration of the compiled BCPL entry point
// This function will be defined in the assembly generated by the BCPL compiler
extern int64_t START(void);

// Simple C-based allocator implementations for standalone builds

void* bcpl_alloc_words(int64_t num_words, const char* func, const char* var) {
    if (num_words <= 0) return NULL;

    // Allocate memory with header: [size][data...]
    // The size is stored as a 64-bit value before the actual data
    size_t total_size = sizeof(uint64_t) + num_words * sizeof(uint64_t);
    uint64_t* vec = (uint64_t*)malloc(total_size);
    
    if (!vec) {
        fprintf(stderr, "ERROR: Failed to allocate %lld words in %s for %s\n",
                (long long)num_words, func ? func : "unknown", var ? var : "unknown");
        return NULL;
    }
    
    // Store the size in the header
    vec[0] = num_words;
    
    // Return a pointer to the data section (after the header)
    return (void*)(vec + 1);
}

void* bcpl_alloc_chars(int64_t num_chars) {
    if (num_chars < 0) return NULL;

    // For strings, we allocate: [size][data...][0]
    // The data is an array of uint32_t values, and we add space for a null terminator
    size_t total_size = sizeof(uint64_t) + (num_chars + 1) * sizeof(uint32_t);
    uint64_t* str = (uint64_t*)malloc(total_size);
    
    if (!str) {
        fprintf(stderr, "ERROR: Failed to allocate string with %lld chars\n",
                (long long)num_chars);
        return NULL;
    }
    
    // Store the size in the header
    str[0] = num_chars;
    
    // Get a pointer to the data section
    uint32_t* payload = (uint32_t*)(str + 1);
    
    // Add null terminator
    payload[num_chars] = 0;
    
    // Clear the string for safety
    memset(payload, 0, num_chars * sizeof(uint32_t));
    
    // Return a pointer to the data section
    return (void*)payload;
}

void bcpl_free(void* ptr) {
    if (!ptr) return;
    
    // The actual block starts before the payload pointer
    // We offset by one header word (uint64_t) to get the original allocation
    void* actual_block = (uint64_t*)ptr - 1;
    free(actual_block);
}

// UTF-8 output helper for WRITEC
static void write_utf8_char(int64_t ch) {
    if (ch < 0 || ch > 0x10FFFF) {
        // Invalid Unicode codepoint
        putchar('?');
        return;
    }

    if (ch < 0x80) {
        // 1-byte sequence (ASCII)
        putchar((char)ch);
    } else if (ch < 0x800) {
        // 2-byte sequence
        putchar(0xC0 | ((ch >> 6) & 0x1F));
        putchar(0x80 | (ch & 0x3F));
    } else if (ch < 0x10000) {
        // 3-byte sequence
        putchar(0xE0 | ((ch >> 12) & 0x0F));
        putchar(0x80 | ((ch >> 6) & 0x3F));
        putchar(0x80 | (ch & 0x3F));
    } else {
        // 4-byte sequence
        putchar(0xF0 | ((ch >> 18) & 0x07));
        putchar(0x80 | ((ch >> 12) & 0x3F));
        putchar(0x80 | ((ch >> 6) & 0x3F));
        putchar(0x80 | (ch & 0x3F));
    }
}

// String functions

// Encodes a Unicode codepoint as UTF-8
// Returns the number of bytes written
static size_t encode_utf8_char(uint32_t codepoint, char* buffer) {
    if (codepoint < 0x80) {
        // 1-byte sequence (ASCII)
        buffer[0] = (char)codepoint;
        return 1;
    } else if (codepoint < 0x800) {
        // 2-byte sequence
        buffer[0] = (char)(0xC0 | ((codepoint >> 6) & 0x1F));
        buffer[1] = (char)(0x80 | (codepoint & 0x3F));
        return 2;
    } else if (codepoint < 0x10000) {
        // 3-byte sequence
        buffer[0] = (char)(0xE0 | ((codepoint >> 12) & 0x0F));
        buffer[1] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
        buffer[2] = (char)(0x80 | (codepoint & 0x3F));
        return 3;
    } else if (codepoint <= 0x10FFFF) {
        // 4-byte sequence
        buffer[0] = (char)(0xF0 | ((codepoint >> 18) & 0x07));
        buffer[1] = (char)(0x80 | ((codepoint >> 12) & 0x3F));
        buffer[2] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
        buffer[3] = (char)(0x80 | (codepoint & 0x3F));
        return 4;
    }

    // Invalid Unicode codepoint, output replacement character
    buffer[0] = (char)0xEF;
    buffer[1] = (char)0xBF;
    buffer[2] = (char)0xBD; // UTF-8 for U+FFFD (replacement character)
    return 3;
}

// Decodes a UTF-8 sequence to a Unicode codepoint
// Updates the pointer to point to the next character
// Returns the decoded codepoint
static uint32_t decode_utf8_char(const unsigned char** ptr, const unsigned char* end) {
    const unsigned char* p = *ptr;

    if (p >= end) {
        return 0; // End of buffer
    }

    uint32_t c = *p++;

    // Single byte (ASCII)
    if ((c & 0x80) == 0) {
        *ptr = p;
        return c;
    }

    // Multi-byte sequence
    int extra_bytes = 0;
    uint32_t min_code = 0;

    if ((c & 0xE0) == 0xC0) {
        // 2-byte sequence
        extra_bytes = 1;
        min_code = 0x80;
        c &= 0x1F;
    } else if ((c & 0xF0) == 0xE0) {
        // 3-byte sequence
        extra_bytes = 2;
        min_code = 0x800;
        c &= 0x0F;
    } else if ((c & 0xF8) == 0xF0) {
        // 4-byte sequence
        extra_bytes = 3;
        min_code = 0x10000;
        c &= 0x07;
    } else {
        // Invalid UTF-8 sequence, skip this byte
        *ptr = p;
        return 0xFFFD; // Replacement character
    }

    // Read continuation bytes
    for (int i = 0; i < extra_bytes; i++) {
        if (p >= end || (*p & 0xC0) != 0x80) {
            // Incomplete or invalid sequence
            *ptr = p;
            return 0xFFFD; // Replacement character
        }
        c = (c << 6) | (*p++ & 0x3F);
    }

    // Check for overlong encodings and invalid codepoints
    if (c < min_code || (c >= 0xD800 && c <= 0xDFFF) || c > 0x10FFFF) {
        *ptr = p;
        return 0xFFFD; // Replacement character
    }

    *ptr = p;
    return c;
}

uint32_t* STRCOPY(uint32_t* dst, const uint32_t* src) {
    if (!dst) return NULL;
    if (!src) {
        dst[0] = 0; // Empty string if source is NULL
        return dst;
    }

    int i = 0;
    while (src[i] != 0) {
        dst[i] = src[i];
        i++;
    }
    dst[i] = 0; // Add null terminator

    return dst;
}

void WRITES(uint32_t* s) {
    if (!s) {
        fputs("(null)", stdout);
        return;
    }

    for (int i = 0; s[i] != 0; i++) {
        write_utf8_char(s[i]);
    }

    fflush(stdout);
}

void WRITEF(double f) {
    printf("%g", f);
    fflush(stdout);
}

void WRITEN(int64_t n) {
    printf("%lld", (long long)n);
    fflush(stdout);
}

void WRITEC(int64_t ch) {
    write_utf8_char(ch);
    fflush(stdout);
}

int64_t RDCH(void) {
    // This is a simplified implementation that only handles ASCII.
    // A full implementation would need to decode UTF-8 sequences.
    int c = getchar();
    if (c == EOF) return -1;
    return (int64_t)c;
}

void finish(void) {
    exit(0);
}

int64_t STRLEN(const uint32_t* s) {
    if (!s) return 0;

    int64_t len = 0;
    while (s[len] != 0) {
        len++;
    }

    return len;
}

int64_t STRCMP(const uint32_t* s1, const uint32_t* s2) {
    if (!s1 && !s2) return 0;
    if (!s1) return -1;
    if (!s2) return 1;

    int i = 0;
    while (s1[i] == s2[i]) {
        if (s1[i] == 0) return 0; // Equal strings
        i++;
    }

    return (int64_t)s1[i] - (int64_t)s2[i];
}

// Helper to convert a BCPL string to a temporary C string for file operations
static char* bcpl_to_c_string(const uint32_t* bcpl_str) {
    if (!bcpl_str) return NULL;

    // Calculate length of BCPL string
    size_t len = 0;
    while (bcpl_str[len] != 0) {
        len++;
    }

    // Allocate a zero-initialized buffer using calloc for safety.
    // This guarantees null termination even if the loop fails.
    char* c_str = (char*)calloc(len * 4 + 1, sizeof(char));
    if (!c_str) return NULL;

    // Convert the string
    size_t pos = 0;
    for (size_t i = 0; i < len; i++) {
        uint32_t codepoint = bcpl_str[i];

        if (codepoint < 0x80) {
            // ASCII
            c_str[pos++] = (char)codepoint;
        } else if (codepoint < 0x800) {
            // 2-byte sequence
            c_str[pos++] = (char)(0xC0 | ((codepoint >> 6) & 0x1F));
            c_str[pos++] = (char)(0x80 | (codepoint & 0x3F));
        } else if (codepoint < 0x10000) {
            // 3-byte sequence
            c_str[pos++] = (char)(0xE0 | ((codepoint >> 12) & 0x0F));
            c_str[pos++] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
            c_str[pos++] = (char)(0x80 | (codepoint & 0x3F));
        } else {
            // 4-byte sequence
            c_str[pos++] = (char)(0xF0 | ((codepoint >> 18) & 0x07));
            c_str[pos++] = (char)(0x80 | ((codepoint >> 12) & 0x3F));
            c_str[pos++] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
            c_str[pos++] = (char)(0x80 | (codepoint & 0x3F));
        }
    }
    // Final null terminator is already set by calloc, but we set it again for clarity.
    c_str[pos] = '\0';

    return c_str;
}

void* PACKSTRING(uint32_t* bcpl_string) {
    if (!bcpl_string) return NULL;

    // Calculate required byte length first
    size_t byte_len = 0;
    for (int i = 0; bcpl_string[i] != 0; ++i) {
        uint32_t ch = bcpl_string[i];
        if (ch < 0x80) byte_len += 1;
        else if (ch < 0x800) byte_len += 2;
        else if (ch < 0x10000) byte_len += 3;
        else byte_len += 4;
    }

    // Allocate a byte vector using the C-style wrapper
    uint8_t* packed_vec = (uint8_t*)bcpl_alloc_words(byte_len, "PACKSTRING", "result");
    if (!packed_vec) return NULL;

    // Re-iterate and fill the allocated vector
    char* ptr = (char*)packed_vec;
    for (int i = 0; bcpl_string[i] != 0; ++i) {
        ptr += encode_utf8_char(bcpl_string[i], ptr);
    }

    return packed_vec;
}

uint32_t* UNPACKSTRING(const uint8_t* byte_vector) {
    if (!byte_vector) return NULL;

    uint64_t* vec_header = (uint64_t*)byte_vector - 1;
    size_t byte_len = vec_header[0];

    // Count the number of characters first to allocate correctly
    size_t char_count = 0;
    const unsigned char* p_count = byte_vector;
    const unsigned char* end = byte_vector + byte_len;
    while (p_count < end) {
        decode_utf8_char(&p_count, end);
        char_count++;
    }

    // Allocate the BCPL string using the C-style wrapper
    uint32_t* unpacked_str = (uint32_t*)bcpl_alloc_chars(char_count);
    if (!unpacked_str) return NULL;

    // Re-iterate and decode into the new string
    const unsigned char* p_decode = byte_vector;
    for (size_t i = 0; i < char_count && p_decode < end; ++i) {
        unpacked_str[i] = decode_utf8_char(&p_decode, end);
    }
    unpacked_str[char_count] = 0; // Ensure null termination

    return unpacked_str;
}

uint32_t* SLURP(uint32_t* filename_str) {
    if (!filename_str) return NULL;

    char* c_filename = bcpl_to_c_string(filename_str);
    if (!c_filename) return NULL;

    FILE* file = fopen(c_filename, "rb");
    if (!file) {
        free(c_filename);
        return NULL;
    }

    // Get file size
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    if (file_size < 0) {
        fclose(file);
        free(c_filename);
        return NULL;
    }

    // Allocate buffer for file contents
    uint8_t* buffer = (uint8_t*)malloc(file_size + 1); // +1 for a safety null byte
    if (!buffer) {
        fclose(file);
        free(c_filename);
        return NULL;
    }

    // Read file
    size_t bytes_read = fread(buffer, 1, file_size, file);
    buffer[bytes_read] = 0; // Ensure null termination for safety
    fclose(file);
    free(c_filename);

    if (bytes_read != (size_t)file_size) {
        free(buffer);
        return NULL;
    }

    // We'll create a BCPL vector with the file data
    uint8_t* temp_vec = (uint8_t*)bcpl_alloc_words(bytes_read, "SLURP", "temp_buffer");
    if (!temp_vec) {
        free(buffer);
        return NULL;
    }

    // Copy file data to the BCPL vector
    memcpy(temp_vec, buffer, bytes_read);
    free(buffer);

    // Unpack the data into a BCPL string
    uint32_t* result = UNPACKSTRING(temp_vec);

    // Free the temporary vector
    bcpl_free(temp_vec);

    return result;
}

void SPIT(uint32_t* bcpl_string, uint32_t* filename_str) {
    if (!bcpl_string || !filename_str) return;
    
    char* c_filename = bcpl_to_c_string(filename_str);
    if (!c_filename) return;
    
    FILE* file = fopen(c_filename, "wb");
    if (!file) {
        free(c_filename);
        return;
    }
    
    // Pack the BCPL string to UTF-8
    uint8_t* packed_bytes = PACKSTRING(bcpl_string);
    if (!packed_bytes) {
        fclose(file);
        free(c_filename);
        return;
    }
    
    // Get the byte length from the header
    uint64_t* vec_header = (uint64_t*)packed_bytes - 1;
    size_t byte_len = vec_header[0];
    
    // Write the bytes to the file
    fwrite(packed_bytes, 1, byte_len, file);
    
    // Clean up
    fclose(file);
    free(c_filename);
    bcpl_free(packed_bytes);
}

// Main entry point for standalone executables
int main(int argc, char *argv[]) {
    // Initialize the runtime environment
    printf("BCPL Runtime v%s initializing...\n", BCPL_RUNTIME_VERSION);
    
    // Process command line arguments if needed
    if (argc > 0) {
        printf("Program: %s\n", argv[0]);
    }
    
    // Create arguments for BCPL program if needed
    // This could be expanded to properly convert argc/argv to BCPL format
    
    // Call the BCPL program's entry point
    printf("Starting BCPL program...\n");
    int64_t result = START();
    printf("BCPL program finished with result: %lld\n", (long long)result);
    
    return (int)result;
}