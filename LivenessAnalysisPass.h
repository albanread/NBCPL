#pragma once

#include "ASTVisitor.h"
#include "ControlFlowGraph.h"
#include "SymbolTable.h"
#include <string>
#include <vector>
#include <set>
#include <map>
#include <memory>

class LivenessAnalysisPass : public ASTVisitor {
public:
    // A map to hold CFGs for each function, keyed by function name.
    using CFGMap = std::unordered_map<std::string, std::unique_ptr<ControlFlowGraph>>;

    // Constructor: Takes the map of CFGs generated by CFGBuilderPass, symbol table, and a trace flag.
    LivenessAnalysisPass(const CFGMap& cfgs, SymbolTable* symbol_table, bool trace_enabled);

    // A map to hold the resulting sets for each basic block.
    using LivenessSets = std::map<BasicBlock*, std::set<std::string>>;

    // Trace flag to control debug output.
    bool trace_enabled_;

    // Main entry point to run the analysis.
    void run();

    // Public methods to access the results.
    const std::set<std::string>& get_in_set(BasicBlock* block) const;
    const std::set<std::string>& get_out_set(BasicBlock* block) const;
    void print_results() const;

    // Returns a map where key is function name and value is the max register pressure.
    std::map<std::string, int> calculate_register_pressure() const;

    // --- ASTVisitor stubs for all required visit methods ---
    void visit(Program& node) override {}
    void visit(LetDeclaration& node) override {}
    void visit(ManifestDeclaration& node) override {}
    void visit(StaticDeclaration& node) override {}
    void visit(GlobalDeclaration& node) override {}
    void visit(FunctionDeclaration& node) override {}
    void visit(RoutineDeclaration& node) override {}
    void visit(LabelDeclaration& node) override {}
    void visit(NumberLiteral& node) override {}
    void visit(StringLiteral& node) override {}
    void visit(CharLiteral& node) override {}
    void visit(BooleanLiteral& node) override {}
    void visit(VariableAccess& node) override;
    void visit(BinaryOp& node) override;
    void visit(UnaryOp& node) override;
    void visit(VectorAccess& node) override;
    void visit(CharIndirection& node) override;
    void visit(FloatVectorIndirection& node) override;
    void visit(FunctionCall& node) override;
    void visit(ConditionalExpression& node) override;
    void visit(ValofExpression& node) override;
    void visit(AssignmentStatement& node) override;
    void visit(RoutineCallStatement& node) override;
    void visit(IfStatement& node) override;
    void visit(UnlessStatement& node) override;
    void visit(TestStatement& node) override;
    void visit(WhileStatement& node) override;
    void visit(UntilStatement& node) override;
    void visit(RepeatStatement& node) override;
    void visit(ForStatement& node) override;
    void visit(ForEachStatement& node) override;
    void visit(SwitchonStatement& node) override;
    void visit(CaseStatement& node) override;
    void visit(DefaultStatement& node) override;
    void visit(GotoStatement& node) override;
    void visit(ReturnStatement& node) override;
    void visit(FinishStatement& node) override;
    void visit(BreakStatement& node) override;
    void visit(LoopStatement& node) override;
    void visit(EndcaseStatement& node) override;
    void visit(ResultisStatement& node) override;
    void visit(CompoundStatement& node) override;
    void visit(BlockStatement& node) override;
    void visit(StringStatement& node) override;
    void visit(FreeStatement& node) override;
    void visit(LabelTargetStatement& node) override;
    void visit(ConditionalBranchStatement& node) override;
    void visit(SysCall& node) override;
    void visit(VecAllocationExpression& node) override;
    void visit(StringAllocationExpression& node) override;
    void visit(TableExpression& node) override;
    void visit(FloatValofExpression& node) override {}
    void visit(BrkStatement& node) override {}
    void visit(GlobalVariableDeclaration& node) override;
    
    // Missing Expression visitor methods
    void visit(PairExpression& node) override;
    void visit(PairAccessExpression& node) override;
    void visit(FPairExpression& node) override;
    void visit(FPairAccessExpression& node) override;
    void visit(QuadExpression& node) override;
    void visit(QuadAccessExpression& node) override;
    void visit(MemberAccessExpression& node) override;
    void visit(SuperMethodCallExpression& node) override;
    void visit(NewExpression& node) override;
    void visit(ListExpression& node) override;
    void visit(VecInitializerExpression& node) override;
    void visit(BitfieldAccessExpression& node) override;
    void visit(FVecAllocationExpression& node) override;

private:
    // Input: A reference to the map of CFGs.
    const CFGMap& cfgs_;
    
    // Symbol table for variable lookup
    SymbolTable* symbol_table_;

    // Storage for the results.
    LivenessSets use_sets_;
    LivenessSets def_sets_;
    LivenessSets in_sets_;
    LivenessSets out_sets_;
    
    // An empty set to return for blocks with no data.
    std::set<std::string> empty_set_;

    // --- Private Helper Methods ---
    
    // Phase 1: Compute use/def sets for all blocks.
    void compute_use_def_sets();
    
    // Phase 2: Run the iterative data-flow algorithm.
    void run_data_flow_analysis();
    
    // A helper to traverse the statements of a basic block.
    void analyze_block(BasicBlock* block);

    // Track the current sets being built for the block being analyzed.
    std::set<std::string> current_use_set_;
    std::set<std::string> current_def_set_;
    
    // Track which blocks contain function calls (for call interval fix)
    std::set<BasicBlock*> blocks_with_calls_;
    
    // Track variables that are used across calls within each block
    std::map<BasicBlock*, std::set<std::string>> vars_used_across_calls_per_block_;
    
    BasicBlock* current_block_being_analyzed_;
    
    // Helper methods for intra-block call interval analysis
    void collect_variable_uses(ASTNode* node, std::set<std::string>& vars);
    void collect_statement_variable_uses(ASTNode* stmt, std::set<std::string>& vars);
    void collect_variables_used_across_calls(ASTNode* expr, std::set<std::string>& vars);
    bool statement_contains_call(ASTNode* stmt);
    bool expression_contains_call(ASTNode* expr);
};