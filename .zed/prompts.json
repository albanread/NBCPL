{
    "build_and_run": "This project has a specific build and run process. First, build the runtime library by executing './buildruntime' from the project root. Second, build the compiler by executing './build' from the root. To compile and run a BCPL source file (e.g., 'test.bcl'), use the command './NewBCPL --run test.bcl'.",
    "writef_format": "When generating code that uses the 'WRITEF' routine, remember that it uses specific format specifiers. For integers, use '%d' or '%N'. For floating-point numbers, use '%f' or '%F'. For a newline character, use '*N'. Ensure the arguments passed to WRITEF match these specifiers in type and order.",
    "debugging": "To see a full list of debugging and tracing options for the compiler, run the command './NewBCPL --help'. This will display all available trace flags like '--trace-codegen' or '--trace-ast'.",
    "project_overview": "You are assisting with a JIT and AOT compiler for a BCPL-like language targeting the ARM64 architecture. Below is a summary of the project's design, pipeline, and key components. Please keep this context in mind for all suggestions. ### Core Architecture The compiler transforms BCPL source code into an Abstract Syntax Tree (AST), which then undergoes several analysis and optimization passes. The AST is then converted into a Control Flow Graph (CFG) for each function. The final code generation walks the CFG to produce ARM64 machine code. [cite_start]It can operate in both JIT mode for direct execution and AOT mode to produce assembly files[cite: 923, 948]. ### Key Data Structures * **AST (`AST.h`)**: The central tree representation of the code after parsing. [cite_start]All initial analysis and optimization passes operate directly on the AST[cite: 275]. * **SymbolTable (`SymbolTable.cpp`)**: Tracks all symbols (variables, functions, parameters, labels) and their properties, such as type, scope level, and function context. [cite_start]It supports scope-aware lookups[cite: 1455, 1456, 1457]. * **ClassTable (`ClassTable.cpp`)**: Manages object-oriented features. [cite_start]It stores class layouts, inheritance hierarchies, member variable offsets, and virtual method table (v-table) blueprints[cite: 359, 919]. * **Control Flow Graph (CFG)**: The `CFGBuilderPass` converts the AST for each function into a graph of `BasicBlock` nodes. [cite_start]Code generation is driven by traversing this CFG, not the AST[cite: 299, 307]. ### [cite_start]Compilation Pipeline 1.  **Preprocessor**: The `Preprocessor` handles `GET` directives to include other source files before parsing begins[cite: 1247]. 2.  **Lexer/Parser**: Scans the source and builds the initial AST. 3.  [cite_start]**ClassPass**: Populates the `ClassTable` by analyzing `CLASS` declarations to determine memory layouts, inheritance, and v-table structures[cite: 358]. 4.  [cite_start]**SymbolDiscoveryPass**: Performs a first pass over the AST to populate the `SymbolTable` with all global functions, routines, and variables[cite: 213]. 5.  **AST-to-AST Passes**: Several optimization and analysis passes run on the AST, including `ManifestResolutionPass`, `GlobalInitializerPass`, and `ConstantFoldingPass`. 6.  **ASTAnalyzer**: This is the main semantic analysis pass. [cite_start]It performs type inference, collects function metrics (like register pressure and parameter types), and performs critical checks[cite: 68]. It has a two-pass mechanism to handle function signatures before bodies. 7.  **CFGBuilderPass**: Traverses the AST to build a CFG for each function. [cite_start]This pass also lowers high-level constructs (like `LET` declarations within blocks) into simpler statements (like assignments) and injects scope-based cleanup code for heap-allocated objects[cite: 317, 327, 330]. 8.  [cite_start]**Liveness & Register Allocation**: The `LivenessAnalysisPass` runs on the CFG to determine the live ranges of variables[cite: 890]. [cite_start]The `LiveIntervalPass` builds intervals from this data, which are then fed to the `LinearScanAllocator`[cite: 180]. 9.  **NewCodeGenerator**: The final pass walks the CFG for each function and emits ARM64 machine code using the `Encoder`. ### Code Generation & Backend * **Target**: ARM64. * [cite_start]**Register Allocation**: Uses a `LinearScanAllocator`[cite: 180]. [cite_start]It correctly distinguishes between caller-saved scratch registers (`X9`-`X15`) and callee-saved variable registers (`X20`-`X27`)[cite: 1308, 181]. [cite_start]It handles spilling variables to the stack when registers are exhausted[cite: 190]. * **Stack Frames**: Managed by `CallFrameManager`. [cite_start]It generates function prologues/epilogues, calculates stack offsets for local variables and spilled registers, and supports stack canaries for security[cite: 294, 291]. * **Runtime Calls**: The compiler uses a `RuntimeManager` and a function pointer table. [cite_start]Register `X19` is reserved as a base pointer to this table, and `X28` is a base pointer for global data[cite: 1078]. ### [cite_start]Runtime System * **Heap Management**: The C++ `HeapManager` tracks all dynamic memory for `VEC`, `STRING`, `LIST` headers, and `OBJECT` instances[cite: 807, 808, 809, 811]. [cite_start]It provides a signal-safe heap dump for debugging crashes[cite: 815]. * [cite_start]**List Implementation**: Lists are implemented with a `ListHeader` and a linked list of `ListAtom` nodes, which are allocated from a freelist to improve performance[cite: 1352]. * [cite_start]**SDL2 Integration**: The runtime can be built with optional SDL2 and SDL2_mixer support for graphics and audio[cite: 1382, 1401]. ### Common Pitfalls / Known Issues * **Scope Context is Critical**: Multiple passes (`ASTAnalyzer`, `NewCodeGenerator`) rely on a `current_function_scope_` member. A common bug is visiting a function body without setting this correctly, leading to symbol lookup failures. * **Function-like LETs**: A function can be declared with `LET F(x) = VALOF...`. The analyzer must treat this as a function declaration, not a global variable, by setting the correct scope before analyzing the `VALOF` body. * **Register Allocation**: Variables live across function calls *must* be allocated to callee-saved registers (`X19`-`X28`) or spilled. [cite_start]The `LinearScanAllocator` handles this by partitioning live intervals[cite: 182]."
}
